
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>React 性能优化 | 包括原理、技巧、Demo、工具使用 - 默默默默燃</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="TriDiamond Obsidian,"> 
    <meta name="description" content="一枚前端搬砖队队员的记录册,

原文地址
本文分为三部分，首先介绍 React 的工作流，让读者对 React 组件更新流程有宏观的认识。然后列出笔者总结的一系列优化技巧，并为稍复杂的优化技巧准备了 CodeSandbox 源,"> 
    <meta name="author" content="张白告丶"> 
    <link rel="alternative" href="atom.xml" title="默默默默燃" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link href="https://fonts.loli.net/css?family=Roboto+Mono|Rubik&display=swap" rel="stylesheet">
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

<meta name="generator" content="Hexo 5.1.1"></head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">默默默默燃</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://ShinichiKudo-FE.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">React 性能优化 | 包括原理、技巧、Demo、工具使用</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(/img/cover.jpg) ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/React"><b>「
                    </b>REACT<b> 」</b></a>
                
                March 17, 2021
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2021/03/17/React/React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="React 性能优化 | 包括原理、技巧、Demo、工具使用" class="">React 性能优化 | 包括原理、技巧、Demo、工具使用</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    30k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    27 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/React/" rel="tag">React</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <meta name="referrer" content="no-referrer"/>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6935584878071119885">原文地址</a></p>
<p>本文分为三部分，首先介绍 React 的工作流，让读者对 React 组件更新流程有宏观的认识。然后列出笔者总结的一系列优化技巧，并为稍复杂的优化技巧准备了 CodeSandbox 源码，以便读者实操体验。最后分享笔者使用 React Profiler 的一点心得，帮助读者更快定位性能瓶颈。</p>
<h2 id="React-工作流"><a href="#React-工作流" class="headerlink" title="React 工作流"></a>React 工作流</h2><p>React 是声明式 UI 库，负责将 <code>State</code> 转换为页面结构（虚拟 DOM 结构）后，再转换成真实 DOM 结构，交给浏览器渲染。当 <code>State</code> 发生改变时，React 会先进行调和（<code>Reconciliation</code>）阶段，调和阶段结束后立刻进入提交（<code>Commit</code>）阶段，提交阶段结束后，新 <code>State</code> 对应的页面才被展示出来。</p>
<p>React 的调和阶段需要做两件事。 <strong>1、计算出目标 State 对应的虚拟 DOM 结构。2、寻找「将虚拟 DOM 结构修改为目标虚拟 DOM 结构」的最优更新方案。</strong> React 按照<strong>深度优先遍历</strong>虚拟 DOM 树的方式，在一个虚拟 DOM 上完成两件事的计算后，再计算下一个虚拟 DOM。</p>
<p>第一件事主要是<em>调用类组件的 render 方法或函数组件自身</em>。第二件事<em>为 React 内部实现的 <code>Diff</code> 算法</em>，<code>Diff</code> 算法会记录虚拟 DOM 的更新方式（如：Update、Mount、Unmount），为提交阶段做准备。</p>
<p>React 的提交阶段也需要做两件事。 <strong>1、将调和阶段记录的更新方案应用到 DOM 中。2、调用暴露给开发者的钩子方法，如：componentDidUpdate、useLayoutEffect 等</strong>。 </p>
<p>提交阶段中这两件事的执行时机与调和阶段不同，在提交阶段 React 会先执行 1，等 1 完成后再执行 2。因此在子组件的 componentDidMount 方法中，可以执行 <code>document.querySelector(&#39;.parentClass&#39;)</code> ，拿到父组件渲染的 <code>.parentClass</code> DOM 节点，尽管这时候父组件的 <code>componentDidMount</code> 方法还没有被执行。<code>useLayoutEffect</code> 的执行时机与 <code>componentDidMount</code> 相同，可参考<a target="_blank" rel="noopener" href="https://codesandbox.io/s/cdm-yu-commit-jieduanzhixingshunxu-fzu1w?file=/src/App.js">线上代码</a>进行验证。</p>
<p>由于调和阶段的<code>「Diff 过程」</code>和提交阶段的<code>「应用更新方案到 </code>DOM」都属于 React 的内部实现，开发者能提供的优化能力有限，本文仅有一条优化技巧（<a target="_blank" rel="noopener" href="https://juejin.cn/post/6935584878071119885#heading-7">列表项使用 key 属性</a>)与它们有关。实际工程中大部分优化方式都集中在<strong>调和阶段的「计算目标虚拟 DOM 结构」过程</strong>，该过程是优化的重点，React 内部的 <code>Fiber</code> 架构和并发模式也是在减少该过程的耗时阻塞。对于提交阶段的<code>「执行钩子函数」</code>过程，开发者应<strong>保证钩子函数中的代码尽量轻量，避免耗时阻塞</strong>，相关的优化技巧参考本文的避免在 <code>didMount、didUpdate</code> 中更新组件 State。</p>
<blockquote>
<p>拓展知识</p>
</blockquote>
<blockquote>
<ol>
<li>建议对 React 生命周期不熟悉的读者结合 React 组件的生命周期图阅读本文。记得勾选该网站上的复选框。</li>
<li>因为理解事件循环后才知道页面会在什么时候被更新，所以推荐一个<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=u1kqx6AenYw&t=853s">介绍事件循环的视频</a>。该视频中事件循环的伪代码如下图，非常清晰易懂。<br><a target="_blank" rel="noopener" href="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc1d13c2d24f4c63995f7d8a8a70b0ce~tplv-k3u1fbpfcp-watermark.image">事件循环</a></li>
</ol>
</blockquote>
<h2 id="定义-Render-的过程"><a href="#定义-Render-的过程" class="headerlink" title="定义 Render 的过程"></a>定义 Render 的过程</h2><p>本文为了叙述方便， 将调和阶段中「计算目标虚拟 DOM 结构」过程称为 <code>Render</code> 过程 。触发 React 组件的 <code>Render</code> 过程目前有三种方式，分别为 forceUpdate、State 更新、父组件 <code>Render</code> 触发子组件 <code>Render</code> 过程。</p>
<h3 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h3><h4 id="PureComponent、React-memo"><a href="#PureComponent、React-memo" class="headerlink" title="PureComponent、React.memo"></a>PureComponent、React.memo</h4><p>在 React 工作流中，如果只有父组件发生状态更新，即使父组件传给子组件的所有 Props 都没有修改，也会引起子组件的 Render 过程。从 React 的声明式设计理念来看，如果子组件的 Props 和 State 都没有改变，那么其生成的 DOM 结构和副作用也不应该发生改变。当子组件符合声明式设计理念时，就可以忽略子组件本次的 Render 过程。</p>
<p><code>PureComponent</code> 和 <code>React.memo</code> 就是应对这种场景的，<code>PureComponent</code> 是对[类组件的 Props 和 State 进行浅比较]，<code>React.memo</code> 是对[函数组件的 Props 进行浅比较]。</p>
<h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><p>在 React 刚开源的那段时期，数据不可变性还没有现在这样流行。当时 <code>Flux</code> 架构就使用的模块变量来维护 State，并在状态更新时直接修改该模块变量的属性值，而不是使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法</a>生成新的对象引用。例如要往数组中添加一项数据时，当时的代码很可能是 <code>state.push(item)</code>，而不是 <code>const newState = [...state, item]</code>。这点可参考 Dan Abramov 在演讲 Redux 时演示的 <code>Flux</code> 代码。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3768dc0ce2941c99caaced1ccbee351~tplv-k3u1fbpfcp-watermark.image" alt="shouldCompoentUpdate"></p>
<p>在此背景下，当时的开发者经常使用 <code>shouldComponentUpdate</code> 来<strong>深比较 Props</strong>，只在 Props 有修改才执行组件的 Render 过程。如今由于数据不可变性和函数组件的流行，这样的优化场景已经不会再出现了。</p>
<p>接下来介绍另一种可以使用 <code>shouldComponentUpdate</code> 来优化的场景。在项目初始阶段，开发者往往图方便会给子组件传递一个大对象作为 Props，后面子组件想用啥就用啥。当大对象中某个「子组件未使用的属性」发生了更新，子组件也会触发 Render 过程。在这种场景下，<strong>通过实现子组件的 <code>shouldComponentUpdate</code> 方法，仅在「子组件使用的属性」发生改变时才返回 true，便能避免子组件重新 Render</strong>。</p>
<p>但使用 <code>shouldComponentUpdate</code> 优化第二个场景有两个弊端。</p>
<ol>
<li>如果存在很多子孙组件，「找出所有子孙组件使用的属性」就会有很多工作量，也容易因为漏测导致 bug。</li>
<li>存在潜在的工程隐患。举例来说，假设组件结构如下。</li>
</ol>
<pre><code class="jsx">&lt;A data=&quot;&#123;data&#125;&quot;&gt;
  &#123;/* B 组件只使用了 data.a 和 data.b */&#125;
  &lt;B data=&quot;&#123;data&#125;&quot;&gt;
    &#123;/* C 组件只使用了 data.a */&#125;
    &lt;C data=&quot;&#123;data&#125;&quot;&gt;&lt;/C&gt;
  &lt;/B&gt;
&lt;/A&gt;</code></pre>
<p>B 组件的 <code>shouldComponentUpdate</code> 中只比较了 <code>data.a</code> 和 <code>data.b</code>，目前是没任何问题的。之后开发者想在 C 组件中使用 <code>data.c</code>，假设项目中 <code>data.a</code> 和 <code>data.c</code> 是一起更新的，所以也没任何问题。但这份代码已经变得脆弱了，如果某次修改导致 <code>data.a</code> 和 <code>data.c</code> 不一起更新了，那么系统就会出问题。而且实际业务中代码往往更复杂，从 B 到 C 可能还有若干中间组件，这时就很难想到是 <code>shouldComponentUpdate</code> 引起的问题了。</p>
<blockquote>
<p>拓展知识</p>
</blockquote>
<blockquote>
<ol>
<li>第二个场景最好的解决方案是使用发布者订阅者模式，只是代码改动要稍多一些，可参考本文的优化技巧「<a target="_blank" rel="noopener" href="https://juejin.cn/post/6935584878071119885#heading-10">发布者订阅者跳过中间组件 Render 过程</a>」。</li>
<li>第二个场景也可以在父子组件间增加中间组件，中间组件负责从父组件中选出子组件关心的属性，再传给子组件。相比于 <code>shouldComponentUpdate</code> 方法，会增加组件层级，但不会有第二个弊端。</li>
<li>本文中的<a target="_blank" rel="noopener" href="https://juejin.cn/post/6935584878071119885#heading-16">跳过回调函数改变触发的 Render 过程</a>也可以用 <code>shouldComponentUpdate</code> 实现，因为回调函数并不参与组件的 Render 过程。</li>
</ol>
</blockquote>
<h4 id="useMemo、useCallback-实现稳定的-Props-值"><a href="#useMemo、useCallback-实现稳定的-Props-值" class="headerlink" title="useMemo、useCallback 实现稳定的 Props 值"></a>useMemo、useCallback 实现稳定的 Props 值</h4><p>如果传给子组件的派生状态或函数，每次都是新的引用，那么 <code>PureComponent</code> 和 <code>React.memo</code> 优化就会失效。所以需要使用 <code>useMemo</code> 和 <code>useCallback</code> 来生成稳定值，并结合 <code>PureComponent</code> 或 <code>React.memo</code> 避免子组件重新 Render。</p>
<blockquote>
<p>拓展知识</p>
</blockquote>
<blockquote>
<p><code>useCallback</code> 是「useMemo 的返回值为函数」时的特殊情况，是 React 提供的便捷方式。在 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/ee432635724d5a50301448016caa137ac3c0a7a2/packages/react-dom/src/server/ReactPartialRendererHooks.js#L452">React Server Hooks</a> 代码 中，<code>useCallback</code> 就是基于 useMemo 实现的。尽管 React Client Hooks 没有使用同一份代码，但<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/ee432635724d5a50301448016caa137ac3c0a7a2/packages/react-reconciler/src/ReactFiberHooks.new.js#L1590"> useCallback</a> 的代码逻辑和 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/ee432635724d5a50301448016caa137ac3c0a7a2/packages/react-reconciler/src/ReactFiberHooks.new.js#L1613">useMemo</a> 的代码逻辑仍是一样的。</p>
</blockquote>
<h4 id="useMemo-减少组件-Render-过程耗时"><a href="#useMemo-减少组件-Render-过程耗时" class="headerlink" title="useMemo 减少组件 Render 过程耗时"></a>useMemo 减少组件 Render 过程耗时</h4><p><code>useMemo</code> 是一种<strong>缓存机制提速</strong>，当它的依赖未发生改变时，就不会触发重新计算。一般用在「计算派生状态的代码」非常耗时的场景中，如：遍历大列表做统计信息。</p>
<blockquote>
<p>拓展知识</p>
</blockquote>
<blockquote>
<ol>
<li>React 官方并不保证 useMemo 一定会进行缓存，所以可能在依赖不改变时，仍然执行重新计算。参考 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations">How to memoize calculations</a></li>
<li>缓存优化往往是最简单有效的优化方式，但 useMemo 缓存加速只能缓存最近一次函数执行的结果，如果想缓存更多次函数执行的结果，可使用 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/memoizee">memoizee</a>。</li>
</ol>
</blockquote>
<h4 id="列表项使用-key-属性"><a href="#列表项使用-key-属性" class="headerlink" title="列表项使用 key 属性"></a>列表项使用 key 属性</h4><p>当渲染列表项时，如果不给组件设置不相等的属性 <code>key</code>，就会收到如下报警。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e07825b27f64c9c860838973063c35e~tplv-k3u1fbpfcp-watermark.image" alt="key"></p>
<p>相信很多开发者已经见过该报警成百上千次了，那 <code>key</code> 属性到底在优化了什么呢？举个 🌰，在不使用 <code>key</code> 时，组件两次 Render 的结果如下。</p>
<pre><code class="html">&lt;!-- 前一次 Render 结果 --&gt;
&lt;ul&gt;
  &lt;li&gt;Duke&lt;/li&gt;
  &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 新的 Render 结果 --&gt;
&lt;ul&gt;
  &lt;li&gt;Connecticut&lt;/li&gt;
  &lt;li&gt;Duke&lt;/li&gt;
  &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>此时 React 的 <code>Diff</code> 算法会按照 <code>&lt;li&gt;</code> 出现的先后顺序进行比较，得出结果为需要更新前两个<code>&lt;li&gt;</code>并创建内容为 <code>Villanova</code> 的li，一共会执行两次 DOM 更新、一次 DOM 创建。</p>
<p>如果加上 React 的 key 属性，两次 Render 结果如下。</p>
<pre><code class="html">&lt;!-- 前一次 Render 结果 --&gt;
&lt;ul&gt;
  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- 新的 Render 结果 --&gt;
&lt;ul&gt;
  &lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;
  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p><code>React Diff</code> 算法会把 <code>key</code> 值为 2015 的虚拟 DOM 进行比较，发现 <code>key</code> 为 2015 的虚拟 DOM 没有发生修改，不用更新。同样，<code>key</code> 值为 2016 的虚拟 DOM 也不需要更新。结果就只需要创建 <code>key</code> 值为 2014 的虚拟 DOM。相比于不使用 <code>key</code> 的代码，使用 <code>key</code> 节省了两次 DOM 更新操作。</p>
<p>如果把例子中的 <code>&lt;li&gt;</code> 换成自定义组件，并且自定义组件使用了 <code>PureComponent</code> 或 <code>React.memo</code> 优化。那么使用 <code>key</code> 属性就不只节省了 DOM 更新，还避免了组件的 Render 过程。</p>
<p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/lists-and-keys.html#keys">React 官方推荐</a>将每项数据的 ID 作为组件的 <code>key</code>，以达到上述的优化目的。并且不推荐使用每项的索引作为 <code>key</code>，因为传索引作为 <code>key</code> 时，就会退化为不使用 <code>key</code> 时的代码。那么是否在所有列表渲染的场景下，使用 ID 都优于使用索引呢？</p>
<p>答案是否定的，在常见的分页列表中，第一页和第二页的列表项 ID 都是不同，假设每页展示三条数据，那么切换页面前后组件 Render 结果如下。</p>
<pre><code class="html">&lt;!-- 第一页的列表项虚拟 DOM --&gt;
&lt;li key=&quot;a&quot;&gt;dataA&lt;/li&gt;
&lt;li key=&quot;b&quot;&gt;dataB&lt;/li&gt;
&lt;li key=&quot;c&quot;&gt;dataC&lt;/li&gt;

&lt;!-- 切换到第二页后的虚拟 DOM --&gt;
&lt;li key=&quot;d&quot;&gt;dataD&lt;/li&gt;
&lt;li key=&quot;e&quot;&gt;dataE&lt;/li&gt;
&lt;li key=&quot;f&quot;&gt;dataF&lt;/li&gt;</code></pre>
<p>切换到第二页后，由于所有 <code>&lt;li&gt;</code> 的 <code>key</code> 值不同，所以 Diff 算法会将第一页的所有 DOM 节点标记为删除，然后将第二页的所有 DOM 节点标记为新增。整个更新过程需要三次 DOM 删除、三次 DOM 创建。如果不使用 <code>key</code>，Diff 算法只会将三个 <code>&lt;li&gt;</code> 节点标记为更新，执行三次 DOM 更新。参考 Demo 没有<a target="_blank" rel="noopener" href="https://codesandbox.io/s/meiyoutianjiashanchupaixugongnengdefenyeliebiao-d6zqr?file=/src/App.js">添加、删除、排序功能的分页列表</a>，使用 <code>key</code> 时每次翻页耗时约为 140ms，而不使用 <code>key</code> 仅为 70ms。</p>
<p>尽管存在以上场景，React 官方仍然推荐使用 <code>ID</code> 作为每项的 <code>key</code> 值。其原因有两：</p>
<blockquote>
<p>1.在列表中执行删除、插入、排序列表项的操作时，使用 ID 作为 key 将更高效。而翻页操作往往伴随着 API 请求，DOM 操作耗时远小于 API 请求耗时，是否使用 ID 在该场景下对用户体验影响不大。</p>
</blockquote>
<blockquote>
<p>2.使用 ID 做为 key 可以维护该 ID 对应的列表项组件的 State。举个例子，某表格中每列都有普通态和编辑态两个状态，起初所有列都是普通态，用户点击第一行第一列，使其进入编辑态。然后用户又拖拽第二行，将其移动到表格的第一行。如果开发者使用索引作为 key，那么第一行第一列的状态仍然为编辑态，而用户实际希望编辑的是第二行的数据，在用户看来就是不符合预期的。尽管这个问题可以通过将「是否处于编辑态」存放在数据项的数据中，利用 Props 来解决，但是使用 ID 作为 key 不是更香吗？</p>
</blockquote>
<h4 id="批量更新，减少-Render-次数"><a href="#批量更新，减少-Render-次数" class="headerlink" title="批量更新，减少 Render 次数"></a>批量更新，减少 Render 次数</h4><p>我们先回忆一道前几年的 React 面试常考题，React 类组件中 <code>setState</code> 是同步的还是异步的？如果对类组件不熟悉也没关系，可以将 <code>setState</code> 理解为 <code>useState</code> 的第二个返回值。</p>
<p>答案是：在 React 管理的事件回调和生命周期中，<code>setState</code> 是异步的，而其他时候 <code>setState</code> 都是同步的。这个问题根本原因就是 React 在自己管理的事件回调和生命周期中，对于 <code>setState</code> 是批量更新的，而在其他时候是立即更新的。读者可参考线上示例 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/setstate-tongbuhuanshiyibu-1bo16">setState 同步还是异步</a>，并自行验证。</p>
<p>批量更新 <code>setState</code> 时，多次执行 <code>setState</code> 只会触发一次 Render 过程。相反在立即更新 <code>setState</code> 时，每次 <code>setState</code> 都会触发一次 Render 过程，就存在性能影响。</p>
<p>假设有如下组件代码，该组件在 <code>getData()</code> 的 API 请求结果返回后，分别更新了两个 State 。线上代码实操参考：<a target="_blank" rel="noopener" href="https://codesandbox.io/s/batchupdates-pilianggengxin-qqdsc">batchUpdates 批量更新</a>。</p>
<pre><code class="js">function NormalComponent()&#123;
  const [list,setList] = useState();
  const [info,setInfo] = useState();

  useEffect(() =&gt;&#123;
    ;(async()=&gt;&#123;
      const data = await getData();
      setList(data.list);
      setInfo(data.info);
    &#125;)()
  &#125;,[])

  return &lt;div&gt;非批量更新组件时Render 次数：&#123;renderOnce(&#39;normal&#39;)&#125;&lt;/div&gt;
&#125;</code></pre>
<p>该组件会在 <code>setList(data.list)</code> 后触发组件的 Render 过程，然后在 <code>setInfo(data.info)</code> 后再次触发 Render 过程，造成性能损失。遇到该问题，开发者有两种实现批量更新的方式来解决该问题：</p>
<ol>
<li><p>将多个 <code>State</code> 合并为单个 <code>State</code>。例如使用 <code>const [data, setData] = useState(&#123; list: null, info: null &#125;)</code> 替代 <code>list</code> 和 <code>info</code> 两个 <code>State。</code></p>
</li>
<li><p>使用 React 官方提供的 <code>unstable_batchedUpdates</code> 方法，将多次 <code>setState</code> 封装到 <code>unstable_batchedUpdates</code> 回调中。修改后代码如下。</p>
</li>
</ol>
<pre><code class="js">function BatchedComponent() &#123;
  const [list, setList] = useState(null)
  const [info, setInfo] = useState(null)

  useEffect(() =&gt; &#123;
    ;(async () =&gt; &#123;
      const data = await getData()
      unstable_batchedUpdates(() =&gt; &#123;
        setList(data.list)
        setInfo(data.info)
      &#125;)
    &#125;)()
  &#125;, [])

  return &lt;div&gt;批量更新组件时 Render 次数：&#123;renderOnce(&quot;batched&quot;)&#125;&lt;/div&gt;
&#125;</code></pre>
<blockquote>
<p>拓展知识</p>
<ol>
<li>推荐阅读<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/11527#issuecomment-360199710">为什么 setState 是异步的</a>？</li>
<li>为什么面试官不会问“函数组件中的 setState 是同步的还是异步的？”？因为函数组件中生成的函数是通过闭包引用了 state，而不是通过 <code>this.state</code> 的方式引用 state，所以函数组件的处理函数中 state 一定是旧值，不可能是新值。可以说函数组件已经将这个问题屏蔽掉了，所以面试官也就不会问了。可参考线上示例。</li>
<li>根据官方文档，在 React 并发模式中，将默认以批量更新方式执行 setState。到那时候，也可能就不需要这个优化了。<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25ccf66ab735427faf9d55556bb83525~tplv-k3u1fbpfcp-watermark.image" alt="并发模式"></li>
</ol>
</blockquote>
<h4 id="按优先级更新，及时响应用户"><a href="#按优先级更新，及时响应用户" class="headerlink" title="按优先级更新，及时响应用户"></a>按优先级更新，及时响应用户</h4><p>优先级更新是批量更新的逆向操作，其思想是：<strong>优先响应用户行为，再完成耗时操作</strong>。</p>
<p>常见的场景是：页面弹出一个 <code>Modal</code>，当用户点击 <code>Modal</code> 中的确定按钮后，代码将执行两个操作。a) 关闭 <code>Modal</code>。b) 页面处理 <code>Modal</code> 传回的数据并展示给用户。当 b) 操作需要执行 500ms 时，用户会明显感觉到从点击按钮到 <code>Modal</code> 被关闭之间的延迟。</p>
<p>例子参考：<a target="_blank" rel="noopener" href="https://codesandbox.io/s/youxianjigengxinlijixiangyingyonghucaozuo-eb740">CodeSandbox 在线 Demo</a>。在该例子中，用户添加一个整数后，页面要隐藏输入框，并将新添加的整数加入到整数列表，将列表排序后再展示。以下为一般的实现方式，将 <code>slowHandle</code> 函数作为用户点击按钮的回调函数。</p>
<pre><code class="js">const slowHandle = () =&gt; &#123;
  setShowInput(false)
  setNumbers([...numbers, +inputValue].sort((a, b) =&gt; a - b))
&#125;</code></pre>
<p><code>slowHandle()</code> 执行过程耗时长，用户点击按钮后会明显感觉到页面卡顿。如果让页面优先隐藏输入框，用户便能立刻感知到页面更新，不会有卡顿感。 <strong>实现优先级更新的要点是将耗时任务移动到下一个宏任务中执行，优先响应用户行为</strong>。 例如在该例中，将 <code>setNumbers</code> 移动到 <code>setTimeout</code> 的回调中，用户点击按钮后便能立即看到输入框被隐藏，不会感知到页面卡顿。优化后的代码如下。</p>
<pre><code class="js">const fastHandle = () =&gt;&#123;
  setShowInput(false);
  setTimeout(()=&gt;&#123;
    setNumber([...numbers, +inputValue].sort((a, b) =&gt; a - b))
  &#125;)
&#125;</code></pre>
<h4 id="发布者订阅者跳过中间组件-Render-过程"><a href="#发布者订阅者跳过中间组件-Render-过程" class="headerlink" title="发布者订阅者跳过中间组件 Render 过程"></a>发布者订阅者跳过中间组件 Render 过程</h4><p>React 推荐将公共数据放在所有「需要该状态的组件」的公共祖先上，但将状态放在公共祖先上后，该状态就需要层层向下传递，直到传递给使用该状态的组件为止。</p>
<p>每次状态的更新都会涉及中间组件的 Render 过程，但中间组件并不关心该状态，它的 Render 过程只负责将该状态再传给子组件。在这种场景下<strong>可以将状态用发布者订阅者模式维护</strong>，只有关心该状态的组件才去订阅该状态，不再需要中间组件传递该状态。当状态更新时，发布者发布数据更新消息，只有订阅者组件才会触发 Render 过程，中间组件不再执行 Render 过程。</p>
<p>只要是发布者订阅者模式的库，都可以进行该优化。比如：<code>redux、use-global-state、React.createContext</code> 等。例子参考：<a target="_blank" rel="noopener" href="https://codesandbox.io/s/fabuzhedingyuezhemoshitiaoguozhongjianzujiande-render-guocheng-nm7nt?file=/src/PubSubCommunicate.js">发布者订阅者模式跳过中间组件的渲染阶段</a>，本示例使用 <code>React.createContext</code> 进行实现。</p>
<pre><code class="jsx">import &#123; useState, useEffect, createContext, useContext &#125; from &quot;react&quot;

const renderCntMap = &#123;&#125;
const renderOnce = name =&gt; &#123;
  return (renderCntMap[name] = (renderCntMap[name] || 0) + 1)
&#125;

// 将需要公共访问的部分移动到 Context 中进行优化
// Context.Provider 就是发布者
// Context.Consumer 就是消费者
const ValueCtx = createContext()
const CtxContainer = (&#123; children &#125;) =&gt; &#123;
  const [cnt, setCnt] = useState(0)
  useEffect(() =&gt; &#123;
    const timer = window.setInterval(() =&gt; &#123;
      setCnt(v =&gt; v + 1)
    &#125;, 1000)
    return () =&gt; clearInterval(timer)
  &#125;, [setCnt])

  return &lt;ValueCtx.Provider value=&#123;cnt&#125;&gt;&#123;children&#125;&lt;/ValueCtx.Provider&gt;
&#125;

function CompA(&#123;&#125;) &#123;
  const cnt = useContext(ValueCtx)
  // 组件内使用 cnt
  return &lt;div&gt;组件 CompA Render 次数：&#123;renderOnce(&quot;CompA&quot;)&#125;&lt;/div&gt;
&#125;

function CompB(&#123;&#125;) &#123;
  const cnt = useContext(ValueCtx)
  // 组件内使用 cnt
  return &lt;div&gt;组件 CompB Render 次数：&#123;renderOnce(&quot;CompB&quot;)&#125;&lt;/div&gt;
&#125;

function CompC(&#123;&#125;) &#123;
  return &lt;div&gt;组件 CompC Render 次数：&#123;renderOnce(&quot;CompC&quot;)&#125;&lt;/div&gt;
&#125;

export const PubSubCommunicate = () =&gt; &#123;
  return (
    &lt;CtxContainer&gt;
      &lt;div&gt;
        &lt;h1&gt;优化后场景&lt;/h1&gt;
        &lt;div&gt;
          将状态提升至最低公共祖先的上层，用 CtxContainer 将其内容包裹。
        &lt;/div&gt;
        &lt;div style=&#123;&#123; marginTop: "20px" &#125;&#125;&gt;
          每次 Render 时，只有组件A和组件B会重新 Render 。
        &lt;/div&gt;

        &lt;div style=&#123;&#123; marginTop: "40px" &#125;&#125;&gt;
          父组件 Render 次数：&#123;renderOnce(&quot;parent&quot;)&#125;
        &lt;/div&gt;
        &lt;CompA /&gt;
        &lt;CompB /&gt;
        &lt;CompC /&gt;
      &lt;/div&gt;
    &lt;/CtxContainer&gt;
  )
&#125;

export default PubSubCommunicate</code></pre>
<p>从图中可看出，优化后只有使用了公共状态的组件 CompA 和 CompB 发生了更新，减少了父组件和 CompC 组件的 Render 次数。</p>
<h4 id="useMemo-返回虚拟-DOM-可跳过该组件-Render-过程"><a href="#useMemo-返回虚拟-DOM-可跳过该组件-Render-过程" class="headerlink" title="useMemo 返回虚拟 DOM 可跳过该组件 Render 过程"></a>useMemo 返回虚拟 DOM 可跳过该组件 Render 过程</h4><p>利用 <code>useMemo</code> 可以缓存计算结果的特点，如果 <code>useMemo</code> 返回的是组件的虚拟 DOM，则将在 <code>useMemo</code> 依赖不变时，跳过组件的 Render 阶段。该方式与 <code>React.memo</code> 类似，但与 <code>React.memo</code> 相比有以下优势：</p>
<ol>
<li>更方便。<code>React.memo</code> 需要对组件进行一次包装，生成新的组件。而 <code>useMemo</code> 只需在存在性能瓶颈的地方使用，不用修改组件。</li>
<li>更灵活。<code>useMemo</code> 不用考虑组件的所有 Props，而只需考虑当前场景中用到的值，也可使用 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/usememo-tiaoguozujian-render-guocheng-bzz9r">useDeepCompareMemo</a> 对用到的值进行深比较。</li>
</ol>
<pre><code class="jsx">import &#123; useEffect, useMemo, useState &#125; from &quot;react&quot;
import &quot;./styles.css&quot;

const renderCntMap = &#123;&#125;

function Comp(&#123; name &#125;) &#123;
  renderCntMap[name] = (renderCntMap[name] || 0) + 1
  return (
    &lt;div&gt;
      组件「&#123;name&#125;」 Render 次数：&#123;renderCntMap[name]&#125;
    &lt;/div&gt;
  )
&#125;

export default function App() &#123;
  const setCnt = useState(0)[1]
  useEffect(() =&gt; &#123;
    const timer = window.setInterval(() =&gt; &#123;
      setCnt(v =&gt; v + 1)
    &#125;, 1000)
    return () =&gt; clearInterval(timer)
  &#125;, [setCnt])

  const comp = useMemo(() =&gt; &#123;
    return &lt;Comp name=&quot;使用 useMemo 作为 children&quot; /&gt;
  &#125;, [])

  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;Comp name=&quot;直接作为 children&quot; /&gt;
      &#123;comp&#125;
    &lt;/div&gt;
  )
&#125;</code></pre>
<h4 id="debounce、throttle-优化频繁触发的回调"><a href="#debounce、throttle-优化频繁触发的回调" class="headerlink" title="debounce、throttle 优化频繁触发的回调"></a>debounce、throttle 优化频繁触发的回调</h4><p>在搜索组件中，当 input 中内容修改时就触发搜索回调。当组件能很快处理搜索结果时，用户不会感觉到输入延迟。但实际场景中，中后台应用的列表页非常复杂，组件对搜索结果的 Render 会造成页面卡顿，明显影响到用户的输入体验。</p>
<p>在搜索场景中一般使用 <a target="_blank" rel="noopener" href="https://github.com/xnimorz/use-debounce#simple-values-debouncing">useDebounce</a> + useEffect 的方式获取数据。</p>
<p>例子参考：<a target="_blank" rel="noopener" href="https://codesandbox.io/s/debounce-search-4dkn3">debounce-search</a>。</p>
<pre><code class="jsx">import &#123; useState, useEffect &#125; from &quot;react&quot;
import &#123; useDebounce &#125; from &quot;use-debounce&quot;

export default function App() &#123;
  const [text, setText] = useState(&quot;Hello&quot;)
  const [debouncedValue] = useDebounce(text, 300)

  useEffect(() =&gt; &#123;
    // 根据 debouncedValue 进行搜索
  &#125;, [debouncedValue])

  return (
    &lt;div&gt;
      &lt;input
        defaultValue=&#123;&quot;Hello&quot;&#125;
        onChange=&#123;e =&gt; &#123;
          setText(e.target.value)
        &#125;&#125;
      /&gt;
      &lt;p&gt;Actual value: &#123;text&#125;&lt;/p&gt;
      &lt;p&gt;Debounce value: &#123;debouncedValue&#125;&lt;/p&gt;
    &lt;/div&gt;
  )
&#125;</code></pre>
<p>为什么搜索场景中是使用 <code>debounce</code>，而不是 <code>throttle</code> 呢？</p>
<p>throttle 是 debounce 的特殊场景，throttle 给 debounce 传了 maxWait 参数，可参考 <a target="_blank" rel="noopener" href="https://github.com/xnimorz/use-debounce/blob/master/src/useThrottledCallback.ts#L57">useThrottleCallback</a>。在搜索场景中，只需响应用户最后一次输入，无需响应用户的中间输入值，debounce 更适合使用在该场景中。而 throttle 更适合需要实时响应用户的场景中更适合，如通过拖拽调整尺寸或通过拖拽进行放大缩小（如：window 的 resize 事件）。实时响应用户操作场景中，如果回调耗时小，甚至可以用  <code>requestAnimationFrame</code> 代替 throttle。</p>
<h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>在 SPA 中，懒加载优化一般用于从一个路由跳转到另一个路由。还可用于用户操作后才展示的复杂组件，比如点击按钮后展示的弹窗模块（有时候弹窗就是一个复杂页面 😌）。在这些场景下，结合 Code Split 收益较高。<br>懒加载的实现是通过 <code>Webpack</code> 的动态导入和 <code>React.lazy</code> 方法，</p>
<p>参考例子 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/lazy-loading-bmyd7">lazy-loading</a>。实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。</p>
<pre><code class="jsx">import &#123; lazy, Suspense, Component &#125; from &quot;react&quot;
import &quot;./styles.css&quot;

// 对加载失败进行容错处理
class ErrorBoundary extends Component &#123;
  constructor(props) &#123;
    super(props)
    this.state = &#123; hasError: false &#125;
  &#125;

  static getDerivedStateFromError(error) &#123;
    return &#123; hasError: true &#125;
  &#125;

  render() &#123;
    if (this.state.hasError) &#123;
      return &lt;h1&gt;这里处理出错场景&lt;/h1&gt;
    &#125;

    return this.props.children
  &#125;
&#125;

const Comp = lazy(() =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
      if (Math.random() &gt; 0.5) &#123;
        reject(new Error(&quot;模拟网络出错&quot;))
      &#125; else &#123;
        resolve(import(&quot;./Component&quot;))
      &#125;
    &#125;, 2000)
  &#125;)
&#125;)

export default function App() &#123;
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;div style=&#123;&#123; marginBottom: 20 &#125;&#125;&gt;
        实现懒加载优化时，不仅要考虑加载态，还需要对加载失败进行容错处理。
      &lt;/div&gt;
      &lt;ErrorBoundary&gt;
        &lt;Suspense fallback=&quot;Loading...&quot;&gt;
          &lt;Comp /&gt;
        &lt;/Suspense&gt;
      &lt;/ErrorBoundary&gt;
    &lt;/div&gt;
  )
&#125;</code></pre>
<h4 id="懒渲染"><a href="#懒渲染" class="headerlink" title="懒渲染"></a>懒渲染</h4><p>懒渲染指当组件进入或即将进入可视区域时才渲染组件。常见的组件 Modal/Drawer 等，当 visible 属性为 true 时才渲染组件内容，也可以认为是懒渲染的一种实现。</p>
<p>懒渲染的使用场景有：</p>
<ol>
<li>页面中出现多次的组件，且组件渲染费时、或者组件中含有接口请求。如果渲染多个带有请求的组件，由于浏览器限制了同域名下并发请求的数量，就可能会阻塞可见区域内的其他组件中的请求，导致可见区域的内容被延迟展示。</li>
<li>需用户操作后才展示的组件。这点和懒加载一样，但懒渲染不用动态加载模块，不用考虑加载态和加载失败的兜底处理，实现上更简单。</li>
</ol>
<p>懒渲染的实现中判断组件是否出现在可视区域内是通过 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-visibility-observer">react-visibility-observer</a> 进行监听。</p>
<p>例子参考：<a target="_blank" rel="noopener" href="https://codesandbox.io/s/lanxuanran-ls65r">懒渲染</a></p>
<pre><code class="jsx">import &#123; useState, useEffect &#125; from &quot;react&quot;
import VisibilityObserver, &#123;
  useVisibilityObserver,
&#125; from &quot;react-visibility-observer&quot;

const VisibilityObserverChildren = (&#123; callback, children &#125;) =&gt; &#123;
  const &#123; isVisible &#125; = useVisibilityObserver()
  useEffect(() =&gt; &#123;
    callback(isVisible)
  &#125;, [callback, isVisible])

  return &lt;&gt;&#123;children&#125;&lt;/&gt;
&#125;

export const LazyRender = () =&gt; &#123;
  const [isRendered, setIsRendered] = useState(false)

  if (!isRendered) &#123;
    return (
      &lt;VisibilityObserver rootMargin=&#123;&quot;0px 0px 0px 0px&quot;&#125;&gt;
        &lt;VisibilityObserverChildren
          callback=&#123;isVisible =&gt; &#123;
            if (isVisible) &#123;
              setIsRendered(true)
            &#125;
          &#125;&#125;
        &gt;
          &lt;span /&gt;
        &lt;/VisibilityObserverChildren&gt;
      &lt;/VisibilityObserver&gt;
    )
  &#125;

  console.log(&quot;滚动到可视区域才渲染&quot;)
  return &lt;div&gt;我是 LazyRender 组件&lt;/div&gt;
&#125;

export default LazyRender</code></pre>
<h4 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h4><p>虚拟列表是懒渲染的一种特殊场景。虚拟列表的组件有  <a target="_blank" rel="noopener" href="https://react-window.now.sh/#/examples/list/fixed-size">react-window</a> 和 react-virtualized，它们都是同一个作者开发的。react-window 是 react-virtualized 的轻量版本，其 API 和文档更加友好。所以新项目中推荐使用 react-window，而不是使用 Star 更多的 react-virtualized。</p>
<p>使用 react-window 很简单，只需要计算每项的高度即可。下面代码中每一项的高度是 35px。</p>
<p>例子参考：<a target="_blank" rel="noopener" href="https://react-window.now.sh/#/examples/list/fixed-size">官方示例</a></p>
<p>如果每项的高度是变化的，可给 <code>itemSize</code> 参数传一个函数。</p>
<p>对于这个优化点，笔者遇到一个真实案例。在公司的招聘项目中，通过下拉菜单可查看某个候选人的所有投递记录。平常这个列表也就几十条，但后来用户反馈『下拉菜单点击后要很久才能展示出投递列表』。该问题的原因就是这个候选人在我们系统中有上千条投递，一次性展示上千条投递导致页面卡住了。所以在开发过程中，遇到接口返回的是所有数据时，需提前预防这类 bug，使用虚拟列表优化。。</p>
<h4 id="跳过回调函数改变触发的-Render-过程"><a href="#跳过回调函数改变触发的-Render-过程" class="headerlink" title="跳过回调函数改变触发的 Render 过程"></a>跳过回调函数改变触发的 Render 过程</h4><p>React 组件的 Props 可以分为两类。a) 一类是在对组件 Render 有影响的属性，如：页面数据、<a target="_blank" rel="noopener" href="https://ant.design/components/dropdown/">getPopupContainer</a> 和 renderProps 函数。b) 另一类是组件 Render 后的回调函数，如：onClick、<a target="_blank" rel="noopener" href="https://ant.design/components/dropdown/">onVisibleChange</a>。<br>b) 类属性并不参与到组件的 Render 过程，因为可以对 b) 类属性进行优化。当 b)类属性发生改变时，不触发组件的重新 Render ，而是在回调触发时调用最新的回调函数。</p>
<p>Dan Abramov 在 <a target="_blank" rel="noopener" href="https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-event-handlers">A Complete Guide to useEffect</a> 文章中认为，每次 Render 都有自己的事件回调是一件很酷的特性。但该特性要求每次回调函数改变就触发组件的重新 Render ，这在性能优化过程中是可以取舍的。</p>
<p>例子参考：<a target="_blank" rel="noopener" href="https://codesandbox.io/s/tiaoguohuidiaohanshugaibianhongfade-render-guocheng-3i59n">跳过回调函数改变触发的 Render 过程</a>。以下代码比较难以理解，可通过调试该例子，帮助理解消化。</p>
<h4 id="动画库直接修改-DOM-属性，跳过组件-Render-阶段"><a href="#动画库直接修改-DOM-属性，跳过组件-Render-阶段" class="headerlink" title="动画库直接修改 DOM 属性，跳过组件 Render 阶段"></a>动画库直接修改 DOM 属性，跳过组件 Render 阶段</h4><p>这个优化在业务中应该用不上，但还是非常值得学习的，将来可以应用到组件库中。参考 <a target="_blank" rel="noopener" href="https://github.com/pmndrs/react-spring">react-spring</a>  的动画实现，当一个动画启动后，每次动画属性改变不会引起组件重新 Render ，而是直接修改了 dom 上相关属性值。</p>
<p>例子演示：<a target="_blank" rel="noopener" href="https://codesandbox.io/s/donghuakuzhijiexiugai-domtiaoguoxuanranjieduan-ij7px">CodeSandbox 在线 Demo</a></p>
<h4 id="避免在-didMount、didUpdate-中更新组件-State"><a href="#避免在-didMount、didUpdate-中更新组件-State" class="headerlink" title="避免在 didMount、didUpdate 中更新组件 State"></a>避免在 didMount、didUpdate 中更新组件 State</h4><p>这个技巧不仅仅适用于 <code>didMount、didUpdate</code>，还包括 <code>willUnmount、useLayoutEffect</code> 和特殊场景下的 <code>useEffect</code>（当父组件的 cDU/cDM 触发时，子组件的 useEffect 会同步调用），本文为叙述方便将他们统称为「提交阶段钩子」。</p>
<p>React 工作流提交阶段的第二步就是执行提交阶段钩子，它们的执行会阻塞浏览器更新页面。如果在提交阶段钩子函数中更新组件 State，会再次触发组件的更新流程，造成两倍耗时。</p>
<p>一般在提交阶段的钩子中更新组件状态的场景有：</p>
<ol>
<li><p>计算并更新组件的派生状态（Derived State）。在该场景中，类组件应使用 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops">getDerivedStateFromProps</a> 钩子方法代替，函数组件<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops">应使用函数调用时执行 setState的方式</a>代替。使用上面两种方式后，React 会将新状态和派生状态在一次更新内完成。</p>
</li>
<li><p>根据 DOM 信息，修改组件状态。在该场景中，除非想办法不依赖 DOM 信息，否则两次更新过程是少不了的，就只能用其他优化技巧了。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/vercel/swr/blob/0.3.8/src/use-swr.ts#L536">use-swr</a> 的源码就使用了该优化技巧。当某个接口存在缓存数据时，use-swr 会先使用该接口的缓存数据，并在 <code>requestIdleCallback</code> 时再重新发起请求，获取最新数据。如果 use-swr 不做该优化的话，就会在 <code>useLayoutEffect</code> 中触发重新验证并设置 <code>isValidating</code> 状态为 true，引起组件的更新流程，造成性能损失。</p>
<h3 id="React-Profiler-定位-Render-过程瓶颈"><a href="#React-Profiler-定位-Render-过程瓶颈" class="headerlink" title="React Profiler 定位 Render 过程瓶颈"></a>React Profiler 定位 Render 过程瓶颈</h3><p><a href="">React Profiler</a> 是 React 官方提供的性能审查工具，</p>
<h4 id="Profiler-只记录了-Render-过程耗时"><a href="#Profiler-只记录了-Render-过程耗时" class="headerlink" title="Profiler 只记录了 Render 过程耗时"></a>Profiler 只记录了 Render 过程耗时</h4><p>通过 <code>React Profiler</code>，开发者可以查看组件 Render 过程耗时，但无法知晓提交阶段的耗时。尽管 Profiler 面板中有 Committed at 字段，但这个字段是相对于录制开始时间，根本没有意义。所以提醒读者<strong>不要通过 Profiler 定位非 Render 过程的性能瓶颈问题</strong>。</p>
<p>通过在 React v16 版本上进行实验，同时开启 Chrome 的 Performance 和 React Profiler 统计。如下图，在 Performance 面板中，调和阶段和提交阶段耗时分别为 642ms 和 300ms，而 Profiler 面板中只显示了 642ms。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0b1a42188ca4a89a6828a96b7d4d0fe~tplv-k3u1fbpfcp-watermark.image" alt="profiler"></p>
<blockquote>
<p>拓展知识</p>
<ol>
<li>React 在 v17 版本后已移除 User Timing 统计功能，具体原因可参考 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/pull/18417">PR#18417</a>。</li>
<li>在 v17 版本上，笔者也通过测试代码验证了 <a target="_blank" rel="noopener" href="https://codesandbox.io/s/react-profiler-shifoutongji-componentdidmount-zhixingshijian-yosid">Profiler</a> 中的统计信息并不包含提交阶段，有兴趣的读者可以看看。</li>
</ol>
</blockquote>
<h4 id="开启「记录组件更新原因」"><a href="#开启「记录组件更新原因」" class="headerlink" title="开启「记录组件更新原因」"></a>开启「记录组件更新原因」</h4><p>点击面板上的齿轮，然后勾选「Record why each component rendered while profiling.」，如下图。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7a8dc5bbda040cab31fce9905684c1f~tplv-k3u1fbpfcp-watermark.image" alt="Record"></p>
<p>然后点击面板中的虚拟 DOM 节点，右侧便会展示该组件重新 Render 的原因。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd269110256a4f7c93cdc9a1b59365bb~tplv-k3u1fbpfcp-watermark.image" alt="Render"></p>
<h4 id="定位产生本次-Render-过程原因"><a href="#定位产生本次-Render-过程原因" class="headerlink" title="定位产生本次 Render 过程原因"></a>定位产生本次 Render 过程原因</h4><p>由于 React 的批量更新（Batch Update）机制，产生一次 Render 过程可能涉及到很多个组件的状态更新。那么如何定位是哪些组件状态更新导致的呢？</p>
<p><strong>在 Profiler 面板左侧的虚拟 DOM 树结构中，从上到下审查每个发生了渲染的（不会灰色的）组件</strong>。如果组件是由于 State 或 Hook 改变触发了 Render 过程，那它就是我们要找的组件，如下图。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e042df82947445539ee0068835637e3d~tplv-k3u1fbpfcp-watermark.image" alt="profiler"></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='ec894e2b66f752e8b7fb'
        data-cs='3ccc2e92bb350688fe2c2dc2930189b62622bfb1'
        data-r='blog-comments'
        data-o='TriDiamond'
        data-a='TriDiamond'
        data-d=''
    >Comments</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/favicon.png" height=300 width=300></img>
                    <p>张白告丶</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        <dd><a href="https://github.com/zhanghao-web" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                        <!-- <dd><a href="" target="_blank"><span
                                    class=" iconfont icon-twitter"></span></a></dd>
                        <dd><a href="" target="_blank"><span
                                    class=" iconfont icon-stack-overflow"></span></a></dd> -->
                    </dl>
                </div>
                <ul>
                    <li><a href="/">211 <p>Articles</p></a></li>
                    <li><a href="/categories">29 <p>Categories</p></a></li>
                    <li><a href="/tags">59 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#React-%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">React 工作流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-Render-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">定义 Render 的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="toc-number">2.1.</span> <span class="toc-text">优化技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Profiler-%E5%AE%9A%E4%BD%8D-Render-%E8%BF%87%E7%A8%8B%E7%93%B6%E9%A2%88"><span class="toc-number">2.2.</span> <span class="toc-text">React Profiler 定位 Render 过程瓶颈</span></a></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>
    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2021
        <span class="gradient-text">
            张白告丶
        </span>.
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>



    
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">

    
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>


<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>


<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>


<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>

    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>




    
<script src="/js/busuanzi.min.js"></script>

    <script>
        $(document).ready(function () {
            if ($('span[id^="busuanzi_"]').length) {
                initialBusuanzi();
            }
        });
    </script>



<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="//www.googletagmanager.com/gtag/js?id=UA-149874671-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-149874671-1');
    </script>





<script>
    function initialTyped () {
        var typedTextEl = $('.typed-text');
        if (typedTextEl && typedTextEl.length > 0) {
            var typed = new Typed('.typed-text', {
                strings: ["Think like an artist, develop like an artisan", "艺术家思维去思考问题，工匠创造精神去开发"],
                typeSpeed: 90,
                loop: true,
                loopCount: Infinity,
                backSpeed: 20,
            });
        }
    }

    if ($('.article-header') && $('.article-header').length) {
        $(document).ready(function () {
            initialTyped();
        });
    }
</script>




</html>
