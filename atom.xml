<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>默默默默燃</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="https://shinichikudo-fe.github.io/atom.xml" rel="self"/>
  
  <link href="https://shinichikudo-fe.github.io/"/>
  <updated>2020-09-18T09:59:40.151Z</updated>
  <id>https://shinichikudo-fe.github.io/</id>
  
  <author>
    <name>张白告丶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习Javascript应懂得33个概念之变量提升</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/18/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/18/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</id>
    <published>2020-09-18T09:00:43.000Z</published>
    <updated>2020-09-18T09:59:40.151Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/6844903490989342728">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在不同作用域下变量与函数的提升表现也是不一致的。在 <code>JavaScript</code> 中，所有绑定的声明会在控制流到达它们出现的作用域时被初始化；这里的作用域其实就是所谓的<code>执行上下文（Execution Context）</code>，每个执行上下文分为<code>内存分配（Memory Creation Phase）</code>与<code>执行（Execution）</code>这两个阶段。在执行上下文的内存分配阶段会进行变量创建，即开始进入了变量的生命周期；变量的生命周期包含了<code>声明（Declaration phase）</code>、<code>初始化（Initialization phase）</code>与<code>赋值（Assignment phase）</code>过程这三个过程。</p><p>传统的 <code>var</code> 关键字声明的变量允许在声明之前使用，此时该变量被赋值为 <code>undefined</code>；而函数作用域中声明的函数同样可以在声明前使用，其函数体也被<strong>提升到了头部</strong>。这种特性表现也就是所谓的<code>提升（Hoisting）</code>；</p><p>虽然在 <code>ES6</code> 中以 <code>let 与 const</code> 关键字声明的变量同样会在作用域头部被初始化，不过这些变量仅允许在实际声明之后使用。在作用域头部与变量实际声明处之间的区域就称为所谓的<code>暂时死域（Temporal Dead Zone）</code>，，TDZ 能够避免传统的提升引发的潜在问题。</p><p>由于 ES6 <strong>引入了块级作用域，在块级作用域中声明的函数会被提升到该作用域头部，即允许在实际声明前使用</strong>；而在部分实现中该函数同时被提升到了所处函数作用域的头部，不过此时被赋值为 <code>undefined</code>。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><code>作用域（Scope）</code>即代码执行过程中的变量、函数或者对象的可访问区域，<strong>作用域决定了变量或者其他资源的可见性</strong>；计算机安全中一条基本原则即是<strong>用户只应该访问他们需要的资源，而作用域就是在编程中遵循该原则来保证代码的安全性</strong>。除此之外，<strong>作用域还能够帮助我们提升代码性能、追踪错误并且修复它们</strong>。<code>JavaScript</code> 中的作用域主要分为<code>全局作用域（Global Scope）</code>与<code>局部作用域（Local Scope）</code>两大类，在 ES5 中定义在函数内的变量即是属于某个局部作用域，而定义在函数外的变量即是属于<code>全局作用域</code>。</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>当我们在浏览器控制台或者 Node.js 交互终端中开始编写 JavaScript 时，即进入了所谓的全局作用域：</p><pre><code class="js">// the scope is by default globalvar name = &#39;Hammad&#39;;// 定义在全局作用域中的变量能够被任意的其他作用域中访问：var name = &#39;Hammad&#39;;console.log(name); // logs &#39;Hammad&#39;function logName() &#123;    console.log(name); // &#39;name&#39; is accessible here and everywhere else&#125;logName(); // logs &#39;Hammad&#39;</code></pre><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p><strong>定义在某个函数内的变量即从属于当前函数作用域</strong>，在每次函数调用中都会创建出新的上下文；换言之，我们可以在不同的函数中定义同名变量，这些变量会被绑定到各自的函数作用域中：</p><pre><code class="js">// Global Scopefunction someFunction() &#123;    // Local Scope #1    function someOtherFunction() &#123;        // Local Scope #2    &#125;&#125;// Global Scopefunction anotherFunction() &#123;    // Local Scope #3&#125;// Global Scope</code></pre><p><strong>函数作用域的缺陷在于粒度过大，在使用闭包或者其他特性时导致异常的变量传递</strong>：</p><pre><code class="js">var callbacks = [];// 这里的 i 被提升到了当前函数作用域头部for (var i = 0; i &lt;= 2; i++) &#123;    callbacks[i] = function () &#123;            return i * 2;        &#125;;&#125;console.log(callbacks[0]()); //6console.log(callbacks[1]()); //6console.log(callbacks[2]()); //6</code></pre><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>类似于 <code>if、switch</code> 条件选择或者 <code>for、while</code> 这样的循环体即是所谓的块级作用域；在 ES5 中，要实现块级作用域，即需要<strong>在原来的函数作用域上包裹一层</strong>，即<strong>在需要限制变量提升的地方手动设置一个变量来替代原来的全局变量</strong>，譬如：</p><pre><code class="js">var callbacks = [];for (var i = 0; i &lt;= 2; i++) &#123;    (function (i) &#123;        // 这里的 i 仅归属于该函数作用域        callbacks[i] = function () &#123;            return i * 2;        &#125;;    &#125;)(i);&#125;callbacks[0]() === 0;callbacks[1]() === 2;callbacks[2]() === 4;</code></pre><p>而在 ES6 中，可以直接利用 let 关键字达成这一点：</p><pre><code class="js">let callbacks = []for (let i = 0; i &lt;= 2; i++) &#123;    // 这里的 i 属于当前块作用域    callbacks[i] = function () &#123;        return i * 2    &#125;&#125;callbacks[0]() === 0callbacks[1]() === 2callbacks[2]() === 4</code></pre><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>。一般来说，在编程语言里我们常见的变量作用域就是词法作用域与动态作用域（Dynamic Scope），绝大部分的编程语言都是使用的词法作用域。词法作用域注重的是所谓的 Write-Time，即编程时的上下文，而动态作用域以及常见的 this 的用法，都是 Run-Time，即运行时上下文。<strong>词法作用域关注的是函数在何处被定义，而动态作用域关注的是函数在何处被调用</strong>JavaScript 是典型的词法作用域的语言，即一个符号参照到语境中符号名字出现的地方，局部变量缺省有着词法作用域</p><pre><code class="js">function foo() &#123;    console.log( a ); // 2 in Lexical Scope ，But 3 in Dynamic Scope&#125;function bar() &#123;    var a = 3;    foo();&#125;var a = 2;bar();</code></pre><h2 id="执行上下文与提升"><a href="#执行上下文与提升" class="headerlink" title="执行上下文与提升"></a>执行上下文与提升</h2><p><code>作用域（Scope）</code>与<code>上下文（Context）</code>常常被用来描述相同的概念，不过上下文更多的关注于代码中 <code>this</code> 的使用，而作用域则与变量的可见性相关；而 JavaScript 规范中的<code>执行上下文（Execution Context</code>）其实描述的是变量的作用域。众所周知，JavaScript 是单线程语言，同时刻仅有单任务在执行，而其他任务则会被压入执行上下文队列中；<strong>每次函数调用时都会创建出新的上下文，并将其添加到执行上下文队列中</strong>。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>每个执行上下文又会分为<code>内存创建（Creation Phase）</code>与<code>代码执行（Code Execution Phase）</code>两个步骤，在创建步骤中会进行变量对象的创建（<code>Variable Object</code>）、作用域链的创建以及设置当前上下文中的 this 对象。所谓的 <code>Variable Object</code> ，又称为 <code>Activation Object</code>，包含了当前执行上下文中的所有变量、函数以及具体分支中的定义。当某个函数被执行时，解释器会先扫描所有的函数参数、变量以及其他声明：</p><pre><code class="js">&#39;variableObject&#39;: &#123;    // contains function arguments, inner variable and function declarations&#125;</code></pre><p>在 <code>Variable Object</code> 创建之后，解释器会继续创建<code>作用域链（Scope Chain）</code>；作用域链往往指向其副作用域，往往被用于解析变量。当需要解析某个具体的变量时，JavaScript 解释器会在作用域链上递归查找，直到找到合适的变量或者任何其他需要的资源。作用域链可以被认为是包含了其自身 <code>Variable Object</code> 引用以及所有的父 <code>Variable Object</code> 引用的对象：</p><pre><code class="js">&#39;scopeChain&#39;: &#123;    // contains its own variable object and other variable objects of the parent execution contexts&#125;</code></pre><p>而执行上下文则可以表述为如下抽象对象：</p><pre><code class="js">executionContextObject = &#123;    &#39;scopeChain&#39;: &#123;&#125;, // contains its own variableObject and other variableObject of the parent execution contexts    &#39;variableObject&#39;: &#123;&#125;, // contains function arguments, inner variable and function declarations    &#39;this&#39;: valueOfThis&#125;</code></pre><h3 id="变量的生命周期与提升"><a href="#变量的生命周期与提升" class="headerlink" title="变量的生命周期与提升"></a>变量的生命周期与提升</h3><ul><li>变量的生命周期包含着<strong>变量声明（Declaration Phase）、变量初始化（Initialization Phase）以及变量赋值（Assignment Phase）</strong>三个步骤；</li></ul><p>其中声明步骤会在作用域中注册变量，初始化步骤负责为变量分配内存并且创建作用域绑定，此时变量会被初始化为 <code>undefined</code>，最后的分配步骤则会将开发者指定的值分配给该变量。</p><p>传统的使用 var 关键字声明的变量的生命周期如下：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/13/b9b8aa1b2352bd9c153d8dd502c8eae9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="varlife"></p><p>而 let 关键字声明的变量生命周期如下：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/13/b1963cb58e148aad82a6c26215f8754d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="letlife"></p><p>如上文所说，我们可以在某个变量或者函数定义之前访问这些变量，这即是所谓的<code>变量提升（Hoisting）</code>。传统的 var 关键字声明的变量会被提升到作用域头部，并被赋值为 <code>undefined</code>：</p><pre><code class="js">// var hoistingnum;     // =&gt; undefined  var num;  num = 10;  num;     // =&gt; 10  // function hoistinggetPi;   // =&gt; function getPi() &#123;...&#125;  getPi(); // =&gt; 3.14  function getPi() &#123;    return 3.14;&#125;</code></pre><p>变量提升只对 var 命令声明的变量有效，如果一个变量不是用 var 命令声明的，就不会发生变量提升。</p><pre><code class="js">console.log(b);b = 1;</code></pre><p>上面的语句将会报错，提示 <code>ReferenceError: b is not defined</code>，即变量 b 未声明，这是因为 b 不是用 var 命令声明的，JavaScript 引擎不会将其提升，而只是视为对顶层对象的 b 属性的赋值。ES6 引入了块级作用域，<strong>块级作用域中使用 let 声明的变量同样会被提升，只不过不允许在实际声明语句前使用</strong>：</p><pre><code class="js">&gt; let x = x;ReferenceError: x is not defined    at repl:1:9    at ContextifyScript.Script.runInThisContext (vm.js:44:33)    at REPLServer.defaultEval (repl.js:239:29)    at bound (domain.js:301:14)    at REPLServer.runBound [as eval] (domain.js:314:12)    at REPLServer.onLine (repl.js:433:10)    at emitOne (events.js:120:20)    at REPLServer.emit (events.js:210:7)    at REPLServer.Interface._onLine (readline.js:278:10)    at REPLServer.Interface._line (readline.js:625:8)&gt; let x = 1;SyntaxError: Identifier &#39;x&#39; has already been declared</code></pre><h3 id="函数的生命周期与提升"><a href="#函数的生命周期与提升" class="headerlink" title="函数的生命周期与提升"></a>函数的生命周期与提升</h3><p>基础的函数提升同样会将声明提升至作用域头部，不过不同于变量提升，函数同样会将其函数体定义提升至头部；譬如：</p><pre><code class="js">function b() &#123;     a = 10;     return;     function a() &#123;&#125; &#125;</code></pre><p>会被编译器修改为如下模式：</p><pre><code class="js">function b() &#123;  function a() &#123;&#125;  a = 10;  return;&#125;</code></pre><p>在内存创建步骤中，JavaScript 解释器会通过<code> function 关键字</code>识别出函数声明并且将其提升至头部；函数的生命周期则比较简单，声明、初始化与赋值三个步骤都被提升到了作用域头部：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/13/1715ccbd677cc0eccecdffb48764756d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="functionlife"></p><p>如果我们在作用域中<strong>重复地声明同名函数，则会由后者覆盖前者</strong>：</p><pre><code class="js">sayHello();function sayHello () &#123;    function hello () &#123;        console.log(&#39;Hello!&#39;);    &#125;    hello();    function hello () &#123;        console.log(&#39;Hey!&#39;);    &#125;&#125;// Hey!</code></pre><p>而 JavaScript 中提供了两种函数的创建方式，<code>函数声明（Function Declaration）</code>与<code>函数表达式（Function Expression）</code>；函数声明即是以 <strong>function 关键字开始，跟随者函数名与函数体</strong>。而函数表达式则是<strong>先声明函数名，然后赋值匿名函数给它</strong>；典型的函数表达式如下所示：</p><pre><code class="js">var sayHello = function() &#123;  console.log(&#39;Hello!&#39;);&#125;;sayHello();// Hello!</code></pre><p><strong>函数表达式遵循变量提升的规则，函数体并不会被提升至作用域头部</strong>：</p><pre><code class="js">sayHello();function sayHello () &#123;    function hello () &#123;        console.log(&#39;Hello!&#39;);    &#125;    hello();    var hello = function () &#123;        console.log(&#39;Hey!&#39;);    &#125;&#125;// Hello!</code></pre><p><strong>在 ES5 中，是不允许在块级作用域中创建函数的；而 ES6 中允许在块级作用域中创建函数</strong>,块级作用域中创建的函数同样会被提升至当前块级作用域头部与函数作用域头部。不同的是函数体并不会再被提升至函数作用域头部，而仅会被提升到块级作用域头部：</p><pre><code class="js">f; // Uncaught ReferenceError: f is not defined(function () &#123;  f; // undefined  x; // Uncaught ReferenceError: x is not defined  if (true) &#123;    f();    let x;    function f() &#123; console.log(&#39;I am function!&#39;); &#125;  &#125;&#125;());</code></pre><h2 id="避免全局变量"><a href="#避免全局变量" class="headerlink" title="避免全局变量"></a>避免全局变量</h2><p><strong>全局变量的不好</strong>：在计算机编程中，全局变量指的是在所有作用域中都能访问的变量。全局变量是一种不好的实践，因为它会导致一些问题，比如一个已经存在的方法和全局变量的覆盖，当我们不知道变量在哪里被定义的时候，代码就变得很难理解和维护了。</p><p>在 ES6 中可以利用 <code>let</code> 关键字来声明本地变量，好的 JavaScript 代码就是没有定义全局变量的。在 JavaScript 中，我们有时候会无意间创建出全局变量，即如果我们在使用某个变量之前忘了进行声明操作，那么该变量会被自动认为是全局变量，譬如:</p><pre><code class="js">function sayHello()&#123;  hello = &quot;Hello World&quot;;  return hello;&#125;sayHello();console.log(hello);</code></pre><p>在上述代码中因为我们在使用 <code>sayHello</code> 函数的时候并没有声明 <code>hello</code> 变量，因此其会创建作为某个全局变量。如果我们想要避免这种偶然创建全局变量的错误，可以通过强制使用 <code>strict mode</code> 来禁止创建全局变量。</p><h3 id="函数包裹"><a href="#函数包裹" class="headerlink" title="函数包裹"></a>函数包裹</h3><p>为了避免全局变量，第一件事情就是要确保所有的代码都被包在函数中。最简单的办法就是把所有的代码都直接放到一个函数中去:</p><pre><code class="js">(function(win) &#123;    &quot;use strict&quot;; // 进一步避免创建全局变量    var doc = window.document;    // 在这里声明你的变量    // 一些其他的代码&#125;(window));</code></pre><h3 id="声明命名空间"><a href="#声明命名空间" class="headerlink" title="声明命名空间"></a>声明命名空间</h3><pre><code class="js">var MyApp = &#123;    namespace: function(ns) &#123;        var parts = ns.split(&quot;.&quot;),            object = this, i, len;        for(i = 0, len = parts.lenght; i &lt; len; i ++) &#123;            if(!object[parts[i]]) &#123;                object[parts[i]] = &#123;&#125;;            &#125;            object = object[parts[i]];        &#125;    return object;    &#125;&#125;;// 定义命名空间MyApp.namespace(&quot;Helpers.Parsing&quot;);// 你现在可以使用该命名空间了MyApp.Helpers.Parsing.DateParser = function() &#123;    //做一些事情&#125;;</code></pre><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>另一项开发者用来避<strong>免全局变量的技术就是封装到模块 Module 中</strong>。一个模块就是不需要创建新的全局变量或者命名空间的通用的功能。不要将所有的代码都放一个负责执行任务或者发布接口的函数中。这里以异步模块定义 <code>Asynchronous Module Definition (AMD)</code> 为例</p><pre><code class="js">//定义define( &quot;parsing&quot;, //模块名字        [ &quot;dependency1&quot;, &quot;dependency2&quot; ], // 模块依赖        function( dependency1, dependency2) &#123; //工厂方法            // Instead of creating a namespace AMD modules            // are expected to return their public interface            var Parsing = &#123;&#125;;            Parsing.DateParser = function() &#123;              //do something            &#125;;            return Parsing;        &#125;);// 通过 Require.js 加载模块require([&quot;parsing&quot;], function(Parsing) &#123;    Parsing.DateParser(); // 使用模块&#125;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903490989342728&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之表达式和语句</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/17/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/17/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/</id>
    <published>2020-09-17T09:39:52.000Z</published>
    <updated>2020-09-17T10:19:18.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表达式与语句的区分"><a href="#表达式与语句的区分" class="headerlink" title="表达式与语句的区分"></a>表达式与语句的区分</h1><p>引子：表达式和语句很基础，但是有时会犯错，比如：</p><pre><code class="js">function()&#123;&#125;//报错(function()&#123;&#125;)//不报错function f(x)&#123; return x + 1 &#125;()//报错function f(x)&#123; return x + 1 &#125;(1)//不报错，为什么返回 1</code></pre><p>能明白为什么？</p><ul><li><p>第一行代码：因为<code>JavaScript</code> 将 <code>function</code> 关键字当作一个 <strong>函数声明语句</strong> 的开始，而函数声明语句 <code>function</code> 关键字后面应该是 函数名，这里后面跟圆括号，当然会报错。</p></li><li><p>第二行代码：给它加上一对圆括号，解析器会把()里的当做表达式去解析，在这里就会当做匿名函数表达式解析，所以不会报错。</p></li><li><p>第三行代码：在一条语句后面加上()会被当做分组操作符，分组操作符里必须要有表达式，所以这里报错；</p></li><li><p>第四行代码：在一条函数声明语句后面加上(1)，仅仅是相当于在声明语句之后又跟了一条毫无关系的表达式，等价于下面代码：</p></li></ul><pre><code class="js">function f(x)&#123; return x + 1 &#125;(1)//1</code></pre><p>所以返回了无关紧要的答案；</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="表达式（expression）"><a href="#表达式（expression）" class="headerlink" title="表达式（expression）"></a>表达式（expression）</h3><p>js 中的一个短语，js 解释器会将其计算出一个结果。程序中的常量是最简单的一类表达式。</p><p><strong>变量名也是一种简单的表达式</strong>，它的值就是赋值给变量的值。<br>复杂表达式是由简单表达式组成的。</p><p>比如，数据访问表达式是由一个表示数组的表达式、左方括号、一个整数表达式和右方括号构成。它们所组成的新的表达式的运算结果是该数组的特定位置的元素值。</p><p>同样的，函数调用表达式由一个表示函数对象的表达式和0个或多个参数表达式构成。</p><p>将简单表达式组合成复杂表达式最常用的方法就是使用运算符（opetator）。</p><p>运算符按照特定的运算规则对操作数（通常是两个）进行运算，并计算出新值。</p><p>乘法运算符<code>*</code>是比较简单的例子。表达式<code>x*y</code>是对两个变量表达式x和y进行运算并得出结果。有时我们更愿意说运算符返回了一个值而不是“计算”出了一个值。</p><h3 id="语句（statement）"><a href="#语句（statement）" class="headerlink" title="语句（statement）"></a>语句（statement）</h3><p><strong>js 整句或命令。js 语句是以分号结束；表达式计算出一个值，但语句用来自行以使某件事发生。</strong><br><strong>“使某件事发生”的一个方法是计算带有副作用的表达式。</strong></p><p>诸如赋值和函数调用这些有副作用的表达式，是可以作为单独的语句的，这种把表达式当做语句的用法也称作表达式语句（expression statement）。类似的语句还有声明语句（declaration statement），声明语句用来声明新变量或定义新函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;表达式与语句的区分&quot;&gt;&lt;a href=&quot;#表达式与语句的区分&quot; class=&quot;headerlink&quot; title=&quot;表达式与语句的区分&quot;&gt;&lt;/a&gt;表达式与语句的区分&lt;/h1&gt;&lt;p&gt;引子：表达式和语句很基础，但是有时会犯错，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code cl</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之map,reduce,filter等高阶函数</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/16/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bmap-reduce-filter%E7%AD%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/16/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bmap-reduce-filter%E7%AD%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</id>
    <published>2020-09-16T07:27:16.000Z</published>
    <updated>2020-09-16T08:36:28.605Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">原文地址来自MDN</a><br>跟着写一遍，加强下记录</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>map()</code> 方法<strong>创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值</strong>。</p><pre><code class="js">const array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32]</code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><pre><code class="js">var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array &#125;[, thisArg])</code></pre><p><strong>callback</strong><br>生成新数组元素的函数，使用三个参数：<br><strong>currentValue</strong><br>callback 数组中正在处理的当前元素。<br><strong>index可选</strong><br>callback 数组中正在处理的当前元素的索引。</p><p><strong>array可选</strong><br>map 方法调用的数组。<br>thisArg可选<br>执行 callback 函数时值被用作this。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><blockquote><p>一个由原数组每个元素执行回调函数的结果成的新数组</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通常情况下，<code>map</code> 方法中的 <code>callback</code> 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 <code>map</code> 只给 <code>callback</code> 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。</p><pre><code class="js">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt); // [1,NaN,NaN]</code></pre><p>我们期望输出 <code>[1, 2, 3]</code>, 而实际结果是 <code>[1, NaN, NaN]</code>.</p><p><code>parseInt</code> 经常被带着一个参数使用, 但是这里接受两个。第一个参数是一个表达式而第二个是<code>callback function</code>的基, <code>Array.prototype.map</code> 传递3个参数:</p><ul><li>the element</li><li>the index</li><li>the array</li></ul><pre><code class="js">// parseInt(string, radix) -&gt; map(parseInt(value, index))/*  first iteration (index is 0): */ parseInt(&quot;1&quot;, 0); // 1/* second iteration (index is 1): */ parseInt(&quot;2&quot;, 1); // NaN/*  third iteration (index is 2): */ parseInt(&quot;3&quot;, 2); // NaN</code></pre><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><p><code>filter</code> 为数组中的每个元素<strong>调用一次 callback 函数，并利用所有使得 callback 返回 true 或等价于 true 的值</strong>的元素创建一个新数组。</p><p><strong>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</strong></p><pre><code class="js">const words = [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</code></pre><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><pre><code class="js">var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</code></pre><p><strong>callback</strong><br>用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。它接受以下三个参数：<br>element<br>数组中当前正在处理的元素。<br><strong>index可选</strong><br>正在处理的元素在数组中的索引。<br><strong>array可选</strong><br>调用了 filter 的数组本身。<br><strong>thisArg可选</strong><br>执行 callback 时，用于 this 的值。</p><h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p><p>filter 不会改变原数组，它返回过滤后的新数组。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><pre><code class="js">var fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;grapes&#39;, &#39;mango&#39;, &#39;orange&#39;];/** * Array filters items based on search criteria (query) */function filterItems(query) &#123;  return fruits.filter(function(el) &#123;      return el.toLowerCase().indexOf(query.toLowerCase()) &gt; -1;  &#125;)&#125;console.log(filterItems(&#39;ap&#39;)); // [&#39;apple&#39;, &#39;grapes&#39;]console.log(filterItems(&#39;an&#39;)); // [&#39;banana&#39;, &#39;mango&#39;, &#39;orange&#39;]</code></pre><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><p><code>reduce()</code> 方法对**数组中的每个元素执行一个由您提供的reducer函数(升序执行)**，将其结果汇总为单个返回值。</p><pre><code class="js">const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15</code></pre><blockquote><p>reducer 函数接收4个参数:</p></blockquote><ul><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ul><h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>函数累计处理的结果</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>数组里所有值的和</p><pre><code class="js">var sum = [0, 1, 2, 3].reduce(function (accumulator, currentValue) &#123;  return accumulator + currentValue;&#125;, 0);// 和为 6</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;原文地址来自MDN&lt;/a&gt;&lt;br&gt;跟着写一遍，加强下记录&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之闭包</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/15/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/15/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%AD%E5%8C%85/</id>
    <published>2020-09-15T05:22:11.000Z</published>
    <updated>2020-09-15T05:52:47.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MDN上对闭包的解释是：函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起构成<strong>闭包（closure）</strong>。也就是说，闭包可以<strong>让你从内部函数访问外部函数作用域</strong>。在 JavaScript 中，每当函数被创建，就会<strong>在函数生成时生成闭包</strong>。</p><p>JavaScript中的函数会形成了闭包。 闭包是由<strong>函数以及声明该函数的词法环境组合而成的</strong>。该环境包含了这个闭包创建时作用域内的任何局部变量</p><h2 id="产生闭包"><a href="#产生闭包" class="headerlink" title="产生闭包"></a>产生闭包</h2><p>创建闭包最常见方式，就是在<strong>一个函数内部创建另一个函数</strong>。下面例子中的 <code>closure</code> 就是一个闭包：</p><pre><code class="js">function func()&#123;  var a = 1,b = 2;  function closure()&#123;    return a+b;  &#125;  return closure;&#125;</code></pre><p><strong>闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域</strong>。</p><h2 id="闭包的注意事项"><a href="#闭包的注意事项" class="headerlink" title="闭包的注意事项"></a>闭包的注意事项</h2><blockquote><p>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会<strong>一直保存到闭包不存在为止</strong>。</p></blockquote><pre><code class="js">function makeAdder(x) &#123;  return function(y) &#123;    return x + y;  &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2));  // 7console.log(add10(2)); // 12// 释放对闭包的引用add5 = null;add10 = null;</code></pre><p><code>add5</code> 和 <code>add10</code> 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 <code>add5</code> 的环境中，x 为 5。而在 <code>add10</code> 中，x 则为 10。最后通过 null 释放了 <code>add5</code> 和 <code>add10</code> 对闭包的引用。</p><blockquote><p>在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；<br>如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。</p></blockquote><ul><li>闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。</li></ul><pre><code class="js">function test()&#123;  var arr = [];  for(var i = 0;i &lt; 10;i++)&#123;    arr[i] = function()&#123;      return i;    &#125;;  &#125;  for(var a = 0;a &lt; 10;a++)&#123;    console.log(arr[a]());  &#125;&#125;test(); // 连续打印 10 个 10</code></pre><p>对于上面的情况，如果我们改变代码如下：</p><pre><code class="js">function test()&#123;  var arr = [];  for(let i = 0;i &lt; 10;i++)&#123;  // 仅在这里作出了改动    arr[i] = function()&#123;      return i;    &#125;;  &#125;  for(var a = 0;a &lt; 10;a++)&#123;    console.log(arr[a]());  &#125;&#125;test(); // 打印 0 到 9</code></pre><ul><li>闭包中的 this 对象</li></ul><pre><code class="js">var name = &quot;The Window&quot;;var obj = &#123;  name: &quot;My Object&quot;,  getName: function()&#123;    return function()&#123;      return this.name;    &#125;;  &#125;&#125;;console.log(obj.getName()());  // The Window</code></pre><p><code>obj.getName()()</code>实际上是<strong>在全局作用域中调用了匿名函数，this指向了window</strong>。这里要理解函数名与函数功能（或者称函数值）是分割开的，不要认为函数在哪里，其内部的this就指向哪里。<strong>匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window</strong>。</p><pre><code class="js">var name = &quot;The Window&quot;;var obj = &#123;  name: &quot;My Object&quot;,  getName: function()&#123;    var that = this;    return function()&#123;      return that.name;    &#125;;  &#125;&#125;;console.log(obj.getName()());  // My Object</code></pre><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="应用闭包的主要场合是：设计私有的方法和变量。"><a href="#应用闭包的主要场合是：设计私有的方法和变量。" class="headerlink" title="应用闭包的主要场合是：设计私有的方法和变量。"></a>应用闭包的主要场合是：设计私有的方法和变量。</h3><p>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。私有变量包括函数的参数、局部变量和函数内定义的其他函数。</p><p>把有权访问私有变量的公有方法称为<code>特权方法（privileged method）</code>。</p><pre><code class="js">function Animal()&#123;  // 私有变量  var series = &quot;哺乳动物&quot;;  function run()&#123;    console.log(&quot;Run!!!&quot;);  &#125;  // 特权方法  this.getSeries = function()&#123;    return series;  &#125;;&#125;</code></pre><blockquote><p><code>模块模式（The Module Pattern）</code>：为单例创建私有变量和方法。</p></blockquote><blockquote><p><code>单例（singleton）</code>：指的是只有一个实例的对象。JavaScript 一般以对象字面量的方式来创建一个单例对象。</p></blockquote><pre><code class="js">var singleton = &#123;  name: &quot;percy&quot;,  speak:function()&#123;    console.log(&quot;speaking!!!&quot;);  &#125;,  getName: function()&#123;    return this.name;  &#125;&#125;;</code></pre><p>上面是普通模式创建的单例，下面使用模块模式创建单例：</p><pre><code class="js">var singleton = (function()&#123;  // 私有变量  var age = 22;  var speak = function()&#123;    console.log(&quot;speaking!!!&quot;);  &#125;;  // 特权（或公有）属性和方法  return &#123;    name: &quot;percy&quot;,    getAge: function()&#123;      return age;    &#125;  &#125;;&#125;)();</code></pre><h2 id="匿名函数最大的用途是创建闭包"><a href="#匿名函数最大的用途是创建闭包" class="headerlink" title="匿名函数最大的用途是创建闭包"></a>匿名函数最大的用途是创建闭包</h2><p>并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。</p><pre><code class="js">var objEvent = objEvent || &#123;&#125;;(function()&#123;     var addEvent = function()&#123;       // some code    &#125;;    function removeEvent()&#123;      // some code    &#125;    objEvent.addEvent = addEvent;    objEvent.removeEvent = removeEvent;&#125;)();</code></pre><p>在这段代码中函数 <code>addEvent</code> 和 <code>removeEvent</code> 都是局部变量，但我们可以通过全局变量 <code>objEvent</code> 使用它，这就大大减少了全局变量的使用，增强了网页的安全性</p><h3 id="一个闭包计数器"><a href="#一个闭包计数器" class="headerlink" title="一个闭包计数器"></a>一个闭包计数器</h3><pre><code class="js">var countNumber = (function()&#123;  var num = 0;  return function()&#123;    return ++num;  &#125;;&#125;)();</code></pre><h2 id="闭包的缺陷"><a href="#闭包的缺陷" class="headerlink" title="闭包的缺陷"></a>闭包的缺陷</h2><ul><li>闭包的缺点就是<strong>常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露</strong>。</li><li>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MDN上对闭包的解释是：函数和对其周围状态（&lt;strong&gt;lexical environment，词法环境&lt;/strong&gt;）的引用捆绑在</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习JavaScript应懂得33个概念之函数作用域,块级作用域和词法作用域</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-09-14T07:25:47.000Z</published>
    <updated>2020-09-14T09:37:41.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><blockquote><p>作用域：作用域是程序源代码中定义变量的区域。</p></blockquote><blockquote><p>作用域目的：作用域规定了如何查找、在哪查找变量的规则，也就是确定了当前执行代码对变量的访问权限。</p></blockquote><blockquote><p>作用域（Scope）即代码执行过程中的变量、函数或者对象的可访问区域，作用域决定了变量或者其他资源的可见性</p></blockquote><p><code>ECMAScript6 之前只有全局作用域和函数作用域，let const 之后才有块级作用域</code></p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><blockquote><p>一个变量的作用域 (scope) 是程序源代码中定义这个变量的区域。</p></blockquote><p><strong>注意点</strong> : <strong>在函数体内，局部变量相对于同名全局变量拥有高优先级。</strong></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>函数声明和变量声明总是被 <code>JavaScript</code> 解释器<strong>隐式地提升 (hoist) 到包含他们的作用域的最顶端</strong>。很明显的，语言自身定义和函数形参已经处于作用域顶端, 并被赋值为 <code>undefined</code></p><p>变量赋值不会被提升。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><blockquote><p>函数作用域：变量在声明他们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p></blockquote><p>我的理解就是<strong>函数体的子嵌套函数可以访问父函数体的变量</strong>。这种关系是可以继承的，子嵌套函数可以访问父、爷函数体的变量。</p><pre><code class="js">function ()&#123;  function foo()&#123;    var tom = &#39;Tom&#39;    console.log(tom) // Tom  &#125;  foo()  console.log(tom) // ReferenceError Tom is not defined&#125;test()// 全局var name = &#39;zyc&#39;; // 全局变量function foo() &#123; // 全局变量    console.log(name);&#125;foo(); // zycfunction bar() &#123;    var name = 2;    foo(); // zyc 这里调用全局变量&#125;bar()</code></pre><blockquote><p>JavaScript 函数的执行用到了作用域链，这个作用域链是<strong>在函数定义的时候创建的</strong>。嵌套的函数 <code>f()</code> 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 <code>f()</code> ，这种绑定在执行 <code>f()</code> 时依然有效。</p></blockquote><h2 id="词法作用域-静态作用域"><a href="#词法作用域-静态作用域" class="headerlink" title="词法作用域(静态作用域)"></a>词法作用域(静态作用域)</h2><p>全局变量在程序中始终都是有定义的。局部变量在声明它的函数体内以及所嵌套的函数内始终是有定义的。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当 <code>JavaScript</code> 需要查找变量的值的时候，会从链中的第一个对象开始查找，如果有就会直接使用这个值，如果没有就会继续查找下一个对象，如果链上不存在就会抛出一个引用错误 (ReferenceError)。</p><p>在 <code>JavaScript</code> 的最顶层代码中 (不包含在任何函数定义内的代码)，作用域链是由一个全局对象组成。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块级作用域：在一些类似 c 语言的编程语言中，{ 内的每一段代码都具有各自的作用域，而且变量在声明他们的代码段之外是不可见的。</p><p>块级作用非常严格，就是作用域之外无法访问作用域内的变量。</p><p>ECMAScript5 中规定了 let 和 const 来支持块级作用域(只是效果一样)。</p><p>同时 ECMAScript5 之前 for if switch 是不会产生作用域的</p><p>下面题目的答案是 <code>5</code> </p><pre><code class="js">var a = 5; // 全局变量function todo()&#123;  var a = 9  return function()&#123;      a = 7  &#125;&#125;todo()()console.log(a) // 指向的是window</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作用域：作用域是程序源代码中定义变量的区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之this,call,apply和bind</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bthis-call-apply%E5%92%8Cbind/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bthis-call-apply%E5%92%8Cbind/</id>
    <published>2020-09-14T07:24:55.000Z</published>
    <updated>2020-09-14T09:11:51.320Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/6844903496253177863">原文地址</a></p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>在 ES5 中，其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象</strong></p><blockquote><p>改变 this 的指向我总结有以下几种方法：</p></blockquote><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply、call、bind</code></li><li><code>new关键字</code> 实例化一个对象</li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>箭头函数的 this 始终指向函数定义时的 this</strong>，而非执行时。，箭头函数需要记着这句话：“<strong>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值</strong>，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p><pre><code class="js">var name = &quot;windowsName&quot;;var a = &#123;  name : &quot;Cherry&quot;,  func1: function () &#123;    console.log(this.name)       &#125;,  func2: function () &#123;    setTimeout( () =&gt; &#123;        this.func1()    &#125;,100);  &#125;&#125;;a.func2()     // Cherry</code></pre><h3 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 _this = this</h3><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。</p><h3 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h3><p><code>apply、call、bind</code> 都是可以改变 this 的指向的，但是这三个函数稍有不同。</p><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p></blockquote><blockquote><p> apply 和 call 基本类似，区别是 call 方法接受的是<strong>若干个参数列表</strong>，而 apply 接收的是一个包含<strong>多个参数的数组</strong>。</p></blockquote><blockquote><p>bind()方法<strong>创建一个新的函数</strong>, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><p>bind 是创建一个新的函数，我们必须<strong>要手动去调用</strong>：</p><pre><code class="js">var a =&#123;    name : &quot;Cherry&quot;,    fn : function (a,b) &#123;        console.log( a + b)    &#125;&#125;var b = a.fn;b.bind(a,1,2)()           // 3</code></pre><h2 id="JS-中的函数调用"><a href="#JS-中的函数调用" class="headerlink" title="JS 中的函数调用"></a>JS 中的函数调用</h2><blockquote><p>函数调用的方法一共有 4 种</p></blockquote><ul><li>作为一个函数调用</li><li>函数作为方法调用</li><li>使用构造函数调用函数</li><li>作为函数方法调用函数（call、apply）</li></ul><h3 id="作为一个函数调用"><a href="#作为一个函数调用" class="headerlink" title="作为一个函数调用"></a>作为一个函数调用</h3><pre><code class="js">var name = &quot;windowsName&quot;;function a() &#123;  var name = &quot;Cherry&quot;;  console.log(this.name);          // windowsName  console.log(&quot;inner:&quot; + this);    // inner: Window&#125;a();console.log(&quot;outer:&quot; + this)         // outer: Window</code></pre><h3 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h3><pre><code class="js">var name = &quot;windowsName&quot;;var a = &#123;    name: &quot;Cherry&quot;,    fn : function () &#123;        console.log(this.name);      // Cherry    &#125;&#125;a.fn();</code></pre><h3 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h3><blockquote><p>如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p></blockquote><pre><code class="js">// 构造函数:function myFunction(arg1, arg2) &#123;    this.firstName = arg1;    this.lastName  = arg2;&#125;// This    creates a new objectvar a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);a.lastName;                             // 返回 &quot;Cherry&quot;</code></pre><h3 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h3><blockquote><p>在 JavaScript 中, 函数是对象。<br>JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身<br>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p></blockquote><pre><code class="js">var name = &quot;windowsName&quot;;function fn() &#123;    var name = &#39;Cherry&#39;;    innerFunction();    function innerFunction() &#123;        console.log(this.name);      // windowsName    &#125;&#125;fn()</code></pre><p>这里的 <code>innerFunction()</code> 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的）</p><p><strong>匿名函数的 this 永远指向 window</strong> 匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903496253177863&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;this的指向&quot;&gt;&lt;a href=&quot;#this的指向&quot; class=&quot;headerlink&quot; title=&quot;this的指向&quot;&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之==与===，typeof与intanceof</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B-%E4%B8%8E-%EF%BC%8Ctypeof%E4%B8%8Eintanceof/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B-%E4%B8%8E-%EF%BC%8Ctypeof%E4%B8%8Eintanceof/</id>
    <published>2020-09-14T07:24:08.000Z</published>
    <updated>2020-09-14T09:44:05.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过js中判断类型是否相等及检测数据类型的方法，来更深入的了解js的奥秘</p><h2 id="与"><a href="#与" class="headerlink" title="==与==="></a>==与===</h2><ul><li>严格相等比较 (也被称作”strict equality”, “identity”, “triple equals”)，使用 <code>===</code> ,</li><li>抽象相等比较 (“loose equality”，”double equals”) ，使用 <code>==</code></li><li><code>Object.is</code> （ECMAScript 2015/ ES6 新特性）</li></ul><p>简而言之，在比较两件事情时，双等号将执行<strong>类型转换</strong>; 三等号将进行相同的比较，而<strong>不进行类型转换</strong> (如果类型不同, 只是总会返回 false );  而Object.is的行为方式与三等号相同，但是对于<code>NaN和-0和+0</code>进行特殊处理，所以最后两个不相同，而Object.is（NaN，NaN）将为 true。</p><h3 id=""><a href="#" class="headerlink" title="==="></a>===</h3><p>全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等。最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。</p><pre><code class="js">var num = 0;var obj = new String(&quot;0&quot;);var str = &quot;0&quot;;var b = false;console.log(num === num); // trueconsole.log(obj === obj); // trueconsole.log(str === str); // trueconsole.log(num === obj); // falseconsole.log(num === str); // falseconsole.log(obj === str); // falseconsole.log(null === undefined); // falseconsole.log(obj === null); // falseconsole.log(obj === undefined); // false</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="=="></a>==</h2><p><code>相等操作符</code>比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。在转换后（<strong>等式的一边或两边都可能被转换</strong>），最终的比较方式等同于全等操作符 === 的比较方式。 相等操作符满足交换律。</p><p>相等操作符对于不同类型的值，进行的比较如下图所示：</p><p><img src="https://github.com/ShinichiKudo-FE/PictureBed/blob/master/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200914155706.png" alt="非严格相等"></p><pre><code class="js">var num = 0;var obj = new String(&quot;0&quot;);var str = &quot;0&quot;;var b = false;console.log(num == num); // trueconsole.log(obj == obj); // trueconsole.log(str == str); // trueconsole.log(num == obj); // trueconsole.log(num == str); // trueconsole.log(obj == str); // trueconsole.log(null == undefined); // true// both false, except in rare casesconsole.log(obj == null);console.log(obj == undefined)</code></pre><p><img src="https://github.com/ShinichiKudo-FE/PictureBed/blob/master/blogImg/%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89.png" alt="判等"></p><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p><strong>typeof 实现原理</strong></p><p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断<code>number,  string,  object,  boolean,  function, undefined,  symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 <code>object</code> 类型的数据的时候，<code>typeof</code>能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof 在判断一个 <code>object</code>的数据的时候只能告诉我们这个数据是 <code>object</code>, 而不能细致的具体到是哪一种 <code>object</code>, 比如</p><pre><code class="js">let s = new String(&#39;abc&#39;);typeof s === &#39;object&#39;// trues instanceof String // true</code></pre><p>要想判断一个数据具体是哪一种 <code>object</code> 的时候，我们需要利用 <strong><code>instanceof</code></strong> 这个操作符来判断，这个我们后面会说到。</p><p>其实，js 在底层存储变量的时候，会在变量的机器码的低位<code>1-3</code>位存储其类型信息</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li></ul><p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。<br><code>null</code>：所有机器码均为<strong>0</strong><br><code>undefined</code>：用 −2^30 整数来表示</p><p>所以，typeof 在判断 <code>null</code> 的时候就出现问题了，由于 <code>null</code> 的所有机器码均为<strong>0</strong>，因此直接被当做了对象来看待。;</p><p>然而用 <code>instanceof</code> 来判断的话</p><pre><code class="js">null instanceof null // TypeError: Right-hand side of &#39;instanceof&#39; is not an object</code></pre><p><strong>null 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug</strong></p><p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括symbol），避免对 null 的判断。</p><p>还有一个不错的判断类型的方法，就是 **<code>Object.prototype.toString.call</code>**，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p><pre><code class="js">Object.prototype.toString.call(1) // &quot;[object Number]&quot;Object.prototype.toString.call(&#39;hi&#39;) // &quot;[object String]&quot;Object.prototype.toString.call(&#123;a:&#39;hi&#39;&#125;) // &quot;[object Object]&quot;Object.prototype.toString.call([1,&#39;a&#39;]) // &quot;[object Array]&quot;Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;Object.prototype.toString.call(() =&gt; &#123;&#125;) // &quot;[object Function]&quot;Object.prototype.toString.call(null) // &quot;[object Null]&quot;Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;Object.prototype.toString.call(Symbol(1)) // &quot;[object Symbol]&quot;Object.prototype.toString.call(BigInt(9)) // &quot;[object BigInt]&quot;</code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><strong>instanceof</strong> 主要的作用就是判断一个实例是否属于某种类型,也可以判断一个实例是否是其父类型或者祖先类型的实例</p><pre><code class="js">let person = function () &#123;&#125;let nicole = new person()nicole instanceof person // truelet person = function () &#123;&#125;let programmer = function () &#123;&#125;programmer.prototype = new person()let nicole = new programmer()nicole instanceof person // truenicole instanceof programmer // true</code></pre><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><pre><code class="js">function new_instance_of(leftVaule, rightVaule) &#123;     let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值    while (true) &#123;        if (leftVaule === null) &#123;            return false;            &#125;        if (leftVaule === rightProto) &#123;            return true;            &#125;         leftVaule = leftVaule.__proto__     &#125;&#125;</code></pre><p>其实 instanceof 主要的实现原理就是<strong>只要右边变量的 prototype 在左边变量的原型链上</strong>即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过js中判断类型是否相等及检测数据类型的方法，来更深入的了解js的奥秘&lt;/p&gt;
&lt;h2 id=&quot;与&quot;&gt;&lt;a href=&quot;#与&quot; class</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习javascript应懂得33个概念之隐式，显式，名义和鸭子类型</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/11/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%9A%90%E5%BC%8F%EF%BC%8C%E6%98%BE%E5%BC%8F%EF%BC%8C%E5%90%8D%E4%B9%89%E5%92%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/11/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%9A%90%E5%BC%8F%EF%BC%8C%E6%98%BE%E5%BC%8F%EF%BC%8C%E5%90%8D%E4%B9%89%E5%92%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-09-11T06:12:55.000Z</published>
    <updated>2020-09-11T06:50:32.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>javasciprt是属于弱类型的语言。灵活的同时也带来一些问题，有时我们修改一些代码时，看上去是对的，结果出现了我们意想不到的结果。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>在 JavaScript 中，当我们进行比较操作或者加减乘除四则运算操作时，常常会触发 JavaScript 的隐式类型转换机制；而这部分也往往是令人迷惑的地方。譬如浏览器中的 <code>console.log</code> 操作常常会将<strong>任何值都转化为字符串</strong>然后展示，而数学运算则会首先将值<strong>转化为数值类型</strong>（除了 <code>Date</code> 类型对象）然后进行操作。</p><h3 id="关系操作符（-lt-gt-lt-gt-）"><a href="#关系操作符（-lt-gt-lt-gt-）" class="headerlink" title="关系操作符（&lt;, &gt;, &lt;=, &gt;=）"></a>关系操作符（&lt;, &gt;, &lt;=, &gt;=）</h3><p>与上述操作符一样，<code>关系操作符</code>的操作值也可以是任意类型的，所以使用<code>非数值类型</code>参与比较时也需要系统进行<code>隐式类型转换</code>：<br>（1）如果两个操作值都是数值，则进行数值比较<br>（2）如果两个操作值都是字符串，则比较字符串对应的字符编码值<br>（3）如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较<br>（4）如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较<br>（5）如果一个操作值是布尔值，则将其转换为数值，再进行比较<br>注：NaN是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回false。</p><h3 id="相等操作符（-）"><a href="#相等操作符（-）" class="headerlink" title="相等操作符（==）"></a>相等操作符（==）</h3><p><code>相等操作符</code>会对操作值进行隐式转换后进行比较：<br>（1）如果一个操作值为布尔值，则在比较之前先将其转换为数值<br>（2）如果一个操作值为字符串，另一个操作值为数值，则通过Number()函数将字符串转换为数值<br>（3）如果一个操作值是对象，另一个不是，则调用对象的valueOf()方法，得到的结果按照前面的规则进行比较<br>（4）null与undefined是相等的<br>（5）如果一个操作值为NaN，则相等比较返回false<br>（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><pre><code class="js">function Person()&#123;&#125;Person.prototype = &#123;  toString() &#123; return &quot;ooo&quot;;&#125;,  valueOf() &#123; return 123;&#125;&#125;var p = new Person() ;// ️ result in chrome</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/2591556-6e772a8971dd0cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="demo"></p><h3 id="date类型转换出现的问题"><a href="#date类型转换出现的问题" class="headerlink" title="date类型转换出现的问题"></a>date类型转换出现的问题</h3><pre><code class="js">var date = new Date(&quot;1970/1/2 8:00:00&quot;);date.valueOf() ; //console of Chrome : 86400000date.toString(); //console of Chrome : &quot;Fri Jan 02 1970 08:00:00 GMT+0800 (CST)&quot; // &#39;&lt;=&#39; &#39;&lt;&#39; &#39;==&#39; don&#39;t have self-consistentdate &lt;= 86400000 //console of Chrome : truedate &lt;  86400000 //console of Chrome : falsedate == 86400000 //console of Chrome : false // Oh! It&#39;s awesome!//This make sensedate == date.toString() //console of Chrome : truedate &lt;= date.toString() //console of Chrome : false// Oh! It really make sense because 864000 &lt;= &quot;string&quot; is equal to 864000 &lt;= 0</code></pre><p>date 在遇到<code>&#39;&lt;&#39; &#39;&lt;=&#39;</code>的时候会默认转换至<code>.valueOf()</code> ,<br>而它遇到<code> &#39;==&#39;</code> 的时候明明有<code>.valueOf()</code>却还是选择转换为<code> .toString()</code></p><p><a href="https://juejin.im/post/5a7172d9f265da3e3245cbca#heading-6">解决该疑惑可以看</a></p><h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><p>显示的转换数据类型主要通过JS定义的数据转换方法。</p><h3 id="转换为布尔值："><a href="#转换为布尔值：" class="headerlink" title="转换为布尔值："></a>转换为布尔值：</h3><p>Boolean() :将一个值转换为其对应的Boolean值</p><pre><code class="js">var message = “Hello world!”;var messageAsBoolean = Boolean(message)console.log(messageAsBoolean);   //true</code></pre><p>各种数据类型及其对应的转换规则。</p><table><thead><tr><th align="left">数据类型</th><th align="center">转换为true的值</th><th align="right">转换为false的值</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="center">true</td><td align="right">false</td></tr><tr><td align="left">String</td><td align="center">任何非空字符串</td><td align="right">“” (空字符串)</td></tr><tr><td align="left">Number</td><td align="center">任何非零数字值(包括无穷大)</td><td align="right">0和NaN</td></tr></tbody></table><p>Object                     任何对象                                    null</p><p>Underfined                   n/a                                    undefined</p><h3 id="转换为数字："><a href="#转换为数字：" class="headerlink" title="转换为数字："></a>转换为数字：</h3><p>有3个函数可以把非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>。第一个函数，即转型函数<code>Number()</code>可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这三个函数对于同样的输入会返回不同的结果。</p><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的<code>toString()</code>方法，这个方法唯一要做的就是返回相应值的字符串表现。数值、布尔值、对象、和字符串值(没错，每个字符串也都有一个<code>toString()</code>方法，该方法返回字符串的一个副本)都有<code>toString()</code>方法。但<code>null</code>和<code>undefined</code>值没有这个方法。</p><h2 id="动态类型及鸭子类型"><a href="#动态类型及鸭子类型" class="headerlink" title="动态类型及鸭子类型"></a>动态类型及鸭子类型</h2><p>动态类型语言的优点是<strong>编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面</strong>。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。</p><p>动态类型语言的缺点是<strong>无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误</strong>。这好像在商店买了一包牛肉辣条，但是要真正吃到嘴里才知道是不是牛肉味。</p><p>在JavaScript中，当我们对一个变量赋值时，显然不需要考虑它的类型，因此，JavaScript是一门典型的<strong>动态类型</strong>语言</p><p>这一切都建立在<code>鸭子类型（duck typing）</code>的概念上，鸭子类型的通俗说法是：<strong>“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”</strong></p><p><code>鸭子类型</code>指导我们<strong>只关注对象的行为，而不关注对象本身</strong>，也就是关注HAS-A, 而不是IS-A。</p><pre><code class="js">var duck = &#123;      duckSinging: function()&#123;          console.log( &#39;嘎嘎嘎&#39; );      &#125;  &#125;;  var chicken = &#123;      duckSinging: function()&#123;          console.log( &#39;嘎嘎嘎&#39; );      &#125;  &#125;;  var choir = [];    // 合唱团  var joinChoir = function( animal )&#123;      if ( animal &amp;&amp; typeof animal.duckSinging === &#39;function&#39; )&#123;          choir.push( animal );          console.log( &#39;恭喜加入合唱团&#39; );          console.log( &#39;合唱团已有成员数量:&#39; + choir.length );      &#125;  &#125;;  joinChoir( duck );    // 恭喜加入合唱团  joinChoir( chicken );    // 恭喜加入合唱团 </code></pre><p>在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用<code>鸭子类型</code>的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：<strong>“面向接口编程，而不是面向实现编程”</strong>。例如，一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;javasciprt是属于弱类型的语言。灵活的同时也带来一些问题，有时我们修改一些代码时，看上去是对的，结果出现了我们意想不到的结果。&lt;/p</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之值类型与引用类型</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/10/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/10/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-09-10T02:03:16.000Z</published>
    <updated>2020-09-10T06:44:27.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.cnblogs.com/leiting/p/8081413.html#1959818612">原文地址</a></p><p><strong>值类型（基本数据类型）</strong>：字符串（string）、数值（number）、布尔值（boolean）、undefined、null  （这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值）(ECMAScript 2016新增了一种基本数据类型：symbol)、BigInt(ECMAScript 2020新增)</p><p><strong>引用类型</strong>：对象（Object）、数组（Array）、函数（Function）</p><h2 id="值类型与引用类型的区别"><a href="#值类型与引用类型的区别" class="headerlink" title="值类型与引用类型的区别"></a>值类型与引用类型的区别</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>1、<strong>占用空间固定，保存在栈中</strong>（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，<code>基础变量的值是存储在栈中</code>，而引用变量存储在栈中的是指向<code>堆中的数组或者对象的地址</code>，这就是<strong>为何修改引用类型总会影响到其他指向这个地址的引用变量</strong>。）</p><p>2、保存与复制的是值本身</p><p>3、使用<code>typeof</code>检测数据的类型</p><p>4、基本类型数据是值类型</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>1、<strong>占用空间不固定，保存在堆中</strong>（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象<code>依然不会被销毁</code>，只有当一个对象<strong>没有任何引用变量引用它时</strong>，系统的垃圾回收机制才会在核实的时候回收它。）</p><p>2、保存与复制的是<strong>指向对象的一个指针</strong></p><p>3、使用<code>instanceof</code>检测数据类型</p><p>4、使用<code>new()</code>方法构造出的对象是引用型</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><pre><code class="js">// 值类型：Number、string、bollean、undefinedvar a = 100var b = aa = 200console.log(b) // 100 保存与复制的是值本身// 引用类型：对象、数组、函数、null(空指针)// 可以扩展属性var a = &#123;age:20&#125;var b = ab.age = 21 console.log(a.age) // 21 // 利用typeof来区分typeof undefined // undefinedtypeof &#39;abc&#39; // stringtypeof 123 // numbertypeof true // boolean// typeof 区分不出来引用类型（除了函数）typeof &#123;&#125; // objecttypeof [] // objecttypeof null // objecttypeof console.log //function// 用instanceof来区分引用类型// 如果变量是给定引用类型（根据它的原型链来识别）的实例，那么instanceof 操作符就会返回 true。console.log(person instanceof Object); // 变量 person 是 Object 吗？console.log(colors instanceof Array); // 变量 colors 是 Array 吗？console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？</code></pre><h2 id="几方面的区别举例："><a href="#几方面的区别举例：" class="headerlink" title="几方面的区别举例："></a>几方面的区别举例：</h2><p>（1）<strong>动态的属性</strong>： 定义基本类型值和引用类型值的方式是类似的。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法，但是，我们不能给基本类型的值添加属性，只能给引用类型值动态地添加属性，以便将来使用。例如</p><pre><code class="js">var person = new Object(); person.name = &quot;Nicholas&quot;; alert(person.name); //&quot;Nicholas&quot;</code></pre><p>（2）<strong>复制变量值</strong>： 如果从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</p><pre><code class="js">var num1 = 5;var num2 = num1</code></pre><p>上述例子中，num1保存的值是5，当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。此后，<strong>这两个变量可以参与任何操作而不会相互影响</strong>。</p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储<em>在变量对象中的值复制一份放到为新变量分配的空间中</em>。不同的是，这个值的副本<strong>实际上是一个指针，而这个指针指向存储在堆中的一个对象</strong>。复制操作结束后，两个变量实际上引用同一个对象。因此，改变其中一个变量，就会影响另外一个变量：例</p><pre><code class="js">var obj1 = new Object(); var obj2 = obj1; obj1.name = &quot;Nicholas&quot;; alert(obj2.name); //&quot;Nicholas&quot; </code></pre><p>首先，变量 obj1 保存了一个对象的新实例。然后，这个值被复制到了 obj2 中；换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，因为这两个变量引用的都是同一个对象。<br>复制值类型的过程如下图：</p><p><img src="https://img2018.cnblogs.com/blog/1207871/201901/1207871-20190102110222496-978852296.png" alt="复制值类型"></p><p>（3）<strong>传递参数</strong>：在<em>向参数传递基本类型的值时，被传递的值会被复制给一个局部变量</em>（即命名参数，或者用ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p><pre><code class="js">function addTen(num) &#123;  num += 10;  return num; &#125; var count = 20; var result = addTen(count); alert(count); //20，没有变化alert(result); //30 </code></pre><p>在函数内部，参数 num 的值被加上了 10，但这一变化不会影响函数外部的 count 变量。参数num 与变量 count 互不相识，它们仅仅是具有相同的值。</p><pre><code class="js">function setName(obj) &#123;  obj.name = &quot;Nicholas&quot;; &#125; var person = new Object(); setName(person); alert(person.name); //&quot;Nicholas&quot; </code></pre><p>为了证明<strong>对象是按值传递的</strong>，我们再看一看下面这个经过修改的例子：</p><pre><code class="js">function setName(obj) &#123;  obj.name = &quot;Nicholas&quot;;  obj = new Object();  obj.name = &quot;Greg&quot;; &#125; var person = new Object(); setName(person); alert(person.name); //&quot;Nicholas&quot; </code></pre><p>如果 <code>person</code> 是按引用传递的，那么 <code>person</code> 就会自动被修改为指向其 <code>name</code> 属性值为”<code>Greg</code>“的新对象。但是，当接下来再访问 <code>person.name</code> 时，显示的值仍然是”<code>Nicholas</code>“。</p><p>这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p><h2 id="变量计算–强制类型转换"><a href="#变量计算–强制类型转换" class="headerlink" title="变量计算–强制类型转换"></a>变量计算–强制类型转换</h2><pre><code class="js">// 字符串拼接var a = 100 + 10 //100var b = 100 + &#39;10&#39; // &#39;10010&#39;// == 运算符100 == &#39;100&#39; //true0 == &#39;&#39; //truenull == undefined //true//  语句var a = trueif(a)&#123;&#125;var b = 100if(b)&#123;&#125; // 把数字转换为truevar c = &#39;&#39;if(c)&#123;&#125; // 把空字符串转换为false// 逻辑运算console.log(10&amp;&amp;0); // 0 把10转换成trueconsole.log(&#39;&#39; || &#39;abc&#39;); // &#39;abc&#39; 把空字符串转换为falseconsole.log(!window.abc); // window.abc是undefined 把非undefined转换成true//判断一个变量会被当做true还是falsevar a = 100console.log(!!a); // true</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/leiting/p/8081413.html#1959818612&quot;&gt;原文</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之原始类型</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/09/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/09/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-09-09T08:16:55.000Z</published>
    <updated>2020-09-10T01:57:14.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">来自MDN</a></p><p>根据最新的ECMAScript的标准定义，<strong>基本类型</strong>（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有7种基本类型：<code>string</code>，<code>number</code>，<code>bigint(ECMCScript 2020新增)</code>，<code>boolean</code>，<code>null</code>，<code>undefined</code>，<code>symbol (ECMAScript 2016新增)</code>。</p><p>多数情况下，<strong>基本类型直接代表了最底层的语言实现</strong>。</p><p><strong>所有基本类型的值都是不可改变的</strong>。但需要注意的是，<em>基本类型本身和一个赋值为基本类型的变量</em>的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p><p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。</p><h2 id="JavaScript-中的基本类型包装对象"><a href="#JavaScript-中的基本类型包装对象" class="headerlink" title="JavaScript 中的基本类型包装对象"></a>JavaScript 中的基本类型包装对象</h2><p>除了<code>null</code>与<code>undefined</code>之外，所有的基本类型都应对应的包装对象</p><blockquote><p><code>Null</code> 类型只有一个值： <code>null</code><br>一个没有被赋值的变量会有个默认值 <code>undefined</code></p></blockquote><ul><li><code>String</code> 为字符串基本类型。<blockquote><p>JavaScript的字符串类型用于表示文本数据</p></blockquote></li></ul><p>不同于类 C 语言，<code>JavaScript</code> 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对<strong>原始字符串的操作来创建新的字符串</strong>。例如：</p><ul><li><p>获取一个字符串的子串可通过选择个别字母或者使用 <code>String.substr()</code>.</p></li><li><p>c两个字符串的连接使用连接操作符 (+) 或者 <code>String.concat()</code>.</p></li><li><p><code>Number</code> 为数值基本类型。</p><blockquote><p>基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。<strong>它并没有为整数给出一种特定的类型</strong>。除了能够表示浮点数外，还有一些带符号的值：<code>+Infinity</code>，<code>-Infinity</code> 和 <code>NaN</code>(非数值，Not-a-Number)</p></blockquote></li><li><p><code>BigInt</code> 为大整数基本类型。</p><blockquote><p><code>BigInt</code>类型是 <code>JavaScript</code> 中的一个基础的数值类型，可以用任意精度表示整数。使用 <code>BigInt</code>，您可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。<code>BigInt</code>是通过在整数末尾附加 n 或调用构造函数来创建的。通过使用常量<code>Number.MAX_SAFE_INTEGER</code>，您可以获得可以用数字递增的最安全的值。通过引入 BigInt，您可以操作超过<code>Number.MAX_SAFE_INTEGER</code>的数字。</p></blockquote></li></ul><p>可以对<code>BigInt</code>使用运算符<code>+、*、-、**和%</code>，就像对数字一样。<code>BigInt</code> 严格来说并不等于一个数字，但它是松散的。</p><p>在将<code>BigInt</code>转换为<code>Boolean</code>时，它的行为类似于一个数字：<code>if、||、&amp;&amp;、Boolean 和!</code>。</p><p><code>BigInt</code>不能与数字互换操作。否则，将抛出<code>TypeError</code>。</p><pre><code class="js">&gt; const x = 2n ** 53n;9007199254740992n&gt; const y = x + 1n; 9007199254740993n</code></pre><ul><li><p><code>Boolean</code> 为布尔基本类型。</p><blockquote><p>布尔表示一个逻辑实体，可以有两个值：true 和 false。</p></blockquote></li><li><p><code>Symbol</code> 为字面量基本类型。</p><blockquote><p>符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值(如下).</p></blockquote></li></ul><p>这个包裹对象的<code>valueOf()</code>方法返回基本类型值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive&quot;&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之调用堆栈</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/08/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/08/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/</id>
    <published>2020-09-08T05:53:13.000Z</published>
    <updated>2020-09-09T09:39:40.536Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.oschina.net/translate/how-does-javascript-actually-work-part-1">原文学习地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆栈的概念对于我来说是熟悉又陌生的感觉，之前看过很多相关的文章及写过一些demo可后面用不到后，就慢慢淡忘了，今天要好好理解并记录下</p><h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><p>Google V8引擎是一个比较流行的javascript引擎示例，该引擎包括两个主要组件：</p><ul><li><ol><li>Memory Heap内存堆 — 这是内存分配的地方</li></ol></li><li><ol start="2"><li>call stack调用堆栈 — 这是你代码执行时栈帧存放的位置</li></ol></li></ul><h2 id="RunTime-运行时"><a href="#RunTime-运行时" class="headerlink" title="RunTime 运行时"></a>RunTime 运行时</h2><p><img src="https://static.oschina.net/uploads/space/2017/1213/104047_yNc9_2896879.png" alt="runtime"></p><h2 id="Call-Stack-调用堆栈"><a href="#Call-Stack-调用堆栈" class="headerlink" title="Call Stack 调用堆栈"></a>Call Stack 调用堆栈</h2><p>JavaScript 是一种<strong>单线程编程语言</strong>，这意味着它只有一个 <code>Call Stack</code> 。因此，它一次仅能做一件事。</p><p><code>Call Stack</code> 是一个数据结构，它基本上记录了我们在程序中的所处的位置。如果我们进入一个函数，我们把它放在堆栈的顶部。如果我们从一个函数中返回，我们弹出堆栈的顶部。这是所有的堆栈可以做的东西。</p><p>我们看一个示例：</p><pre><code class="js">function multiply(x,y)&#123;  return x * y&#125;function printSqure(x)&#123;  var s = multiply(x,x)  console.log(s)&#125;printSqure(5)</code></pre><p>当引擎开始执行这个代码时，Call Stack 将会变成空的。之后，执行的步骤如下：</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104147_KJwy_2896879.png" alt="call stack"></p><p>Call Stack 的每个入口被称为 <strong>Stack Frame（栈帧）</strong>。</p><p>这正是在抛出异常时如何构建 <code>stack trace</code> 的方法 - 这基本上是在异常发生时的 <code>Call Stack</code> 的状态。看看下面的代码：</p><pre><code class="js">function foo()&#123;  throw new Error(&#39;SessionStack will help you resolve crashes :)&#39;);&#125;function bar()&#123;  foo()&#125;function start() &#123;  bar();&#125;start();</code></pre><p>如果这是在 Chrome 中执行的（假设这个代码在一个名为 foo.js 的文件中），那么会产生下面的 <code>stack trace</code>:</p><p><code>Blowing the stack</code>—当达到最大调用堆栈大小时，会发生这种情况。这可能会很容易发生，特别是如果你使用递归，而不是非常广泛地测试你的代码。看看这个示例代码：</p><pre><code class="js">function foo() &#123;    foo();&#125;foo();</code></pre><p>当引擎开始执行这个代码时，它首先调用函数“foo”。然而，这个函数是递归的，并且开始调用自己而没有任何终止条件。所以在执行的每个步骤中，同一个函数会一次又一次地添加到调用堆栈中。它看起来像这样：</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104326_4B9u_2896879.png" alt="call stack 递归"></p><p>然而，在某些情况下，调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器通过抛出一个错误（如下所示）来决定采取行动：</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104350_JCtB_2896879.png" alt="max stack"></p><p>在单线程上运行代码可能非常容易，因为你不必处理多线程环境中出现的复杂场景，例如<strong>死锁</strong>。</p><p>但是在单线程上运行也是非常有限的。由于<code>JavaScript</code>只有一个调用堆栈，所以当事情很慢时会发生什么？</p><h2 id="并发与事件循环"><a href="#并发与事件循环" class="headerlink" title="并发与事件循环"></a>并发与事件循环</h2><p>如果在调用堆栈中执行的函数调用需要花费大量时间才能进行处理，会发生什么？ 例如，假设你想在浏览器中使用 <code>JavaScript</code> 进行一些复杂的图像转换。</p><p>你可能会问 - 为什么这会是一个问题？问题是，虽然调用堆栈有要执行的函数，浏览器实际上不能做任何事情 - 它被阻塞了。这意味着浏览器无法渲染，它不能运行任何其他代码，它就是被卡住了。如果你想在你的应用程序中使用流畅的 UI ，这就会产生问题。</p><p>而且这并不是唯一的问题。一旦你的浏览器开始在 Call Stack 中处理过多的任务，它可能会停止响应相当长的时间。大多数浏览器会通过触发错误来采取行动，询问你是否要终止网页。</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104412_G1jc_2896879.png" alt="阻塞"></p><p>所以，这并不是最好的用户体验，对吗？</p><p>那么，我们如何执行大量代码而不阻塞 UI 使得浏览器无法响应？ <strong>解决方案就是异步回调</strong>。</p><p>这将在“ JavaScript 工作原理”教程的第2部分中更详细地解释：<a href="https://www.oschina.net/translate/how-does-javascript-actually-work-part-2">“V8 引擎内部+关于如何编写优化代码的5个技巧”</a>。</p><p>同时，如果你在 JavaScript 应用程序中难以复现和理解问题，请查看 <code>SessionStack</code> 。 <code>SessionStack</code> 会记录你的 Web 应用中的所有东西：所有的 DOM 更改、用户交互、JavaScript 异常、堆栈跟踪、网络请求失败、调试消息等。</p><p>通过 SessionStack ，你可以以视频的方式重现问题，并查看发生在用户身上的所有事情。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然JavaScript是单线程，但Event Loop是javascript的执行机制，可以很好的处理事件，它也分为同步与异步，当为同步时JavaScript的顺序必须一个完成之后才会完成下一个，如果前面出现无限循环后就会出现爆栈，导致后面的无法执行；而异步时又分为宏观任务（script，setTimeout，setInterval）及微观任务（Promise，process.nextTick）进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/translate/how-does-javascript-actually-work-part-1&quot;&gt;原文学习地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>深入 TypeScript 中的子类型、逆变、协变</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/03/Ts/%E6%B7%B1%E5%85%A5-TypeScript-%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E5%8D%8F%E5%8F%98/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/03/Ts/%E6%B7%B1%E5%85%A5-TypeScript-%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E5%8D%8F%E5%8F%98/</id>
    <published>2020-09-03T07:58:12.000Z</published>
    <updated>2020-09-03T08:49:55.505Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/6855517117778198542">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TypeScript 中有很多地方涉及到子类型 <code>subtype</code>、父类型 <code>supertype</code>、逆变和协变<code>covariance and contravariance</code>的概念，如果搞不清这些概念，那么很可能被报错搞的无从下手，或者在写一些复杂类型的时候看到别人可以这么写，但是不知道为什么他可以生效。</p><h2 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a>子类型</h2><p>比如考虑如下的接口：</p><pre><code class="js">interface Animal &#123;  age: number&#125;interface Dog extends Animal &#123;  bark(): void&#125;</code></pre><p>在这个例子中，<code>Animal</code> 是 <code>Dog</code> 的父类，<code>Dog</code>是<code>Animal</code>的子类型，子类型的属性比父类型更多，更具体。</p><p>在类型系统中，属性更多的类型是子类型。<br>在集合论中，属性更少的集合是子集。</p><p>也就是说，子类型是父类型的超集，而父类型是子类型的子集，这是直觉上容易搞混的一点。<br>记住一个特征，<em>子类型比父类型更加具体</em>，这点很关键。</p><h2 id="可赋值性的assignable"><a href="#可赋值性的assignable" class="headerlink" title="可赋值性的assignable"></a>可赋值性的<font color="red">assignable</font></h2><p><code>assignable</code> 是类型系统中很重要的一个概念，当你把一个变量赋值给另一个变量时，就要检查这两个变量的类型之间是否可以相互赋值。</p><pre><code class="js">let animal: Animallet dog: Doganimal = dog // ✅okdog = animal // ❌error! animal 实例上缺少属性 &#39;bark&#39;</code></pre><p>从这个例子里可以看出，animal 是一个「更宽泛」的类型，它的属性比较少，所以更「具体」的子类型是可以赋值给它的，因为你是知道 animal 上只有 age 这个属性的，你只会去使用这个属性，dog 上拥有 animal 所拥有的一切类型，赋值给 animal 是不会出现类型安全问题的。</p><p>反之，如果 dog = animal，那么后续使用者会期望 dog 上拥有 bark 属性，当他调用了 dog.bark() 就会引发运行时的崩溃。</p><p>从可赋值性角度来说，子类型是可以赋值给父类型的，也就是<code> 父类型变量 = 子类型变量</code> 是安全的，因为子类型上涵盖了父类型所拥有的的一切属性。</p><p>当我初学的时候，我会觉得<code>T extends &#123;&#125;</code> 这样的语句很奇怪，为什么可以 <code>extends</code>一个空类型并且在传递任意类型时都成立呢？当搞明白上面的知识点，这个问题也自然迎刃而解了。</p><h2 id="在函数中的运用"><a href="#在函数中的运用" class="headerlink" title="在函数中的运用"></a>在函数中的运用</h2><p>假设我们有这样的一个函数：</p><pre><code class="js">function c(val:&#123;a:number,b:number&#125;)</code></pre><p>有这样两个变量：</p><pre><code class="js">let val1 = &#123; a: 1 &#125;let val2 = &#123; a: 1, b: 2, c: 3 &#125;</code></pre><p>调用 <code>f(val1)</code> 是会报错的，比较显而易见的来看是因为缺少属性 b，而函数 f 中很可能去访问 b 属性并且做一些操作，比如 <code>b.substr()</code>，这就会导致崩溃。</p><p>换成上面的知识点来看，val1 对应的类型是{ a: number }，它是 { a: number, b: number } 的父类型，调用 <code>f(val1)</code> 其实就相当于把函数定义中的形参 val 赋值成了 val1，把父类型的变量赋值给子类型的变量，这是危险的。</p><p>反之，调用 f(val2) 没有任何问题，因为 val2 的类型是 val类型的子类型，它拥有更多的属性，函数有可能使用的一切属性它都有。</p><p>假设我现在要开发一个 <code>redux</code>，在声明 <code>dispatch</code> 类型的时候，我就可以这样去做：</p><pre><code class="ts">interface Action &#123;  type: string&#125;declare function dispatch&lt;T extends Action&gt;(action: T)</code></pre><p>这样，就约束了传入的参数一定是 Action 的子类型。也就是说，必须有 type，其他的属性有没有，您随意。</p><h2 id="在联合类型中的运用"><a href="#在联合类型中的运用" class="headerlink" title="在联合类型中的运用"></a>在联合类型中的运用</h2><p>学习了以上知识点，再看联合类型的可赋值性，乍一看会比较反直觉， <code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 是 <code>&#39;a&#39; | &#39;b&#39;</code> 的子类型吗？它看起来属性更多诶？其实正相反，<code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 是 <code>&#39;a&#39; | &#39;b&#39;</code> 的父类型。因为<strong>前者比后者更「宽泛」，后者比前者更「具体」</strong>。</p><pre><code class="ts">type Parent = &#39;a&#39; | &#39;b&#39; | &#39;c&#39;type Son = &#39;a&#39; | &#39;b&#39;let parent: Parentlet son: Sonparent = son // ✅okson = parent // ❌error! parent 有可能是 &#39;c&#39;</code></pre><p>这里 son 是可以安全的赋值给 parent 的，因为 son 的所有可能性都被 parent 涵盖了。<br>而反之则不行，parent 太宽泛了，它有可能是 ‘c’，这是 Son 类型 hold 不住的。<br>这个例子看完以后，你应该可以理解为什么 <code>&#39;a&#39; | &#39;b&#39;</code> extends <code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 为 true 了，在书写 <code>conditional types</code>的时候更加灵活的运用吧。</p><h2 id="逆变和协变"><a href="#逆变和协变" class="headerlink" title="逆变和协变"></a>逆变和协变</h2><p>先来段<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">维基百科的定义</a>：</p><blockquote><p>协变与逆变(covariance and contravariance)是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p></blockquote><p>描述的比较晦涩难懂，但是用我们上面的动物类型的例子来解释一波，现在我们还是有 <code>Animal</code> 和 <code>Dog</code> 两个父子类型。</p><h3 id="协变（Covariance）"><a href="#协变（Covariance）" class="headerlink" title="协变（Covariance）"></a>协变（Covariance）</h3><p>那么想象一下，现在我们分别有这两个子类型的数组，他们之间的父子关系应该是怎么样的呢？没错，Animal[] 依然是 Dog[] 的父类型，对于这样的一段代码，把子类型赋值给父类型依然是安全的：</p><pre><code class="js">let animals: Animal[]let dogs: Dog[]animals = dogsanimals[0].age // ✅ok</code></pre><p>转变成数组之后，对于父类型的变量，我们依然只会去 <code>Dog</code> 类型中一定有的那些属性。</p><p>那么，对于 <code>type MakeArray&lt;T&gt; = T[]</code> 这个类型构造器来说，它就是 协变（Covariance） 的。</p><h3 id="逆变（Contravariance）"><a href="#逆变（Contravariance）" class="headerlink" title="逆变（Contravariance）"></a>逆变（Contravariance）</h3><p>有这样两个函数：</p><pre><code class="js">let visitAnimal = (animal: Animal) =&gt; void;let visitDog = (dog: Dog) =&gt; void;</code></pre><p><code>animal = dog</code> 是类型安全的，那么 <code>visitAnimal = visitDog</code> 好像也是可行的？其实不然，想象一下这两个函数的实现：</p><pre><code class="ts">let visitAnimal = (animal: Animal) =&gt; &#123;  animal.age&#125;let visitDog = (dog: Dog) =&gt; &#123;  dog.age  dog.bark()&#125;</code></pre><p>由于 visitDog 的参数期望的是一个更具体的带有 bark 属性的子类型，所以如果 visitAnimal = visitDog 后，我们可能会用一个不带 bark 属性的普通的 animal 类型来传给 visitDog。</p><pre><code class="ts">visitAnimal = visitDoglet animal = &#123; age: 5 &#125;visitAnimal(animal) // ❌</code></pre><p>这会造成运行时错误，<code>animal.bark</code> 根本不存在，去调用这个方法会引发崩溃。<br>但是反过来，<code>visitDog = visitAnimal</code> 却是完全可行的。因为后续调用方会传入一个比 animal 属性更具体的 dog，函数体内部的一切访问都是安全的。</p><p>在对 Animal 和 Dog 类型分别调用如下的类型构造器之后：</p><pre><code class="ts">  type MakeFunction&lt;T&gt; = (arg: T) =&gt; void</code></pre><p>父子类型关系逆转了，这就是 逆变（Contravariance）。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>当然，在 <code>TypeScript</code> 中，由于灵活性等权衡，对于函数参数默认的处理是<code>双向协变</code> 的。也就是既可以 visitAnimal = visitDog，也可以 visitDog = visitAnimal。在开启了 tsconfig 中的 <strong><code>strictFunctionType</code></strong> 后才会严格按照 <code>逆变</code> 来约束赋值关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6855517117778198542&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;T</summary>
      
    
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/categories/Ts/"/>
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>重学React(三)</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%B8%89)/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%B8%89)/</id>
    <published>2020-08-11T09:50:07.000Z</published>
    <updated>2020-09-04T02:18:38.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终于到了期盼已久的HOOK环节了，我最初学react的时候是版本为15.4.2(特地去看了react仓库看了<a href="https://github.com/facebook/react/blob/master/CHANGELOG.md#1562-september-25-2017">更新日志</a>)算是很早的学习，可惜自己学的东西在工作中实践不了，当时也刚参加工作，又推动不了新技术的落地。无奈过段时间就忘了。计算机技术只有不断敲，看了用不到7天内就会忘得差不多了。当时看到class组件的时候觉得帅呆了，因为那时es6正当时，看到很多人都是使用jsx语法，class声明组件等等，觉得自己赶上了好时机。后来情况就是用不到放弃了，虽然用不到但是平时关注一些新的技术，react HOOK 发布时，也看了一些文章，一些大佬也推荐使用hook的语法写react,到了现在版本16.13.1，我才开始真正接触HOOK</p><p>根据官网的介绍：</p><p><Big><strong>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</strong><Big>。</p><blockquote><p>Hook的三个特性</p></blockquote><ul><li>完全可选的</li><li>100%向后兼容的</li><li>现在就用 </li></ul><h2 id="使用Hook的动机"><a href="#使用Hook的动机" class="headerlink" title="使用Hook的动机"></a>使用Hook的动机</h2><p><a href="https://react.docschina.org/docs/hooks-intro.html#motivation">具体介绍</a><br>1.在组件之间复用状态逻辑很难</p><p>2.复杂组件变得难以理解</p><p>3.难以理解的 class</p><h2 id="使用State-Hook"><a href="#使用State-Hook" class="headerlink" title="使用State Hook"></a>使用State Hook</h2><pre><code class="js">// demoimport React, &#123; useState &#125; from &#39;react&#39;;function Example() &#123;  // 声明一个叫 &quot;count&quot; 的 state 变量  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;;// 等价class组件class Example extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      count: 0    &#125;;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;          Click me        &lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><p>在函数组件中，我们没有 this，所以我们不能分配或读取 this.state。</p><h2 id="使用Effect-Hook"><a href="#使用Effect-Hook" class="headerlink" title="使用Effect Hook"></a>使用Effect Hook</h2><p><code>Effect Hook</code> 可以让你在函数组件中执行副作用操作</p><pre><code class="js">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function Example() &#123;  const [count, setCount] = useState(0);  // Similar to componentDidMount and componentDidUpdate:  useEffect(() =&gt; &#123;    // Update the document title using the browser API    document.title = `You clicked $&#123;count&#125; times`;  &#125;);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><p><em>有些副作用可能需要清除，所以需要返回一个函数：</em></p><pre><code class="js">useEffect(() =&gt; &#123;  function handleStatusChange(status) &#123;    setIsOnline(status.isOnline);  &#125;  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);  return () =&gt; &#123;    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);  &#125;;&#125;);</code></pre><p><em>其他的 effect 可能不必清除，所以不需要返回。</em></p><pre><code class="js">useEffect(() =&gt; &#123;  document.title = `You clicked $&#123;count&#125; times`;&#125;);</code></pre><h2 id="Hook的规则"><a href="#Hook的规则" class="headerlink" title="Hook的规则"></a>Hook的规则</h2><p>1.只在最顶层使用 Hook</p><p><strong>不要在循环，条件或嵌套函数中调用 Hook</strong>， 确保总是在你的 React 函数的最顶层调用他们。</p><p>2.只在 React 函数中调用 Hook</p><p><strong>不要在普通的 JavaScript 函数中调用 Hook</strong></p><p>可以在：</p><ul><li>在 React 的函数组件中调用 Hook</li><li>在自定义 Hook 中调用其他 Hook</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><a href="https://react.docschina.org/docs/hooks-faq.html#which-versions-of-react-include-hooks">更多</a></p><p>为什么要在 effect 中返回一个函数？<br><strong>这是 effect 可选的清除机制</strong>。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p>React 何时清除 effect？<br><strong>React 会在组件卸载的时候执行清除操作</strong>。正如之前学到的，effect 在每次渲染的时候都会执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;终于到了期盼已久的HOOK环节了，我最初学react的时候是版本为15.4.2(特地去看了react仓库看了&lt;a href=&quot;https:/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重学React(二)</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%BA%8C)/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%BA%8C)/</id>
    <published>2020-08-11T09:45:34.000Z</published>
    <updated>2020-09-04T02:18:38.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇看了react的核心概念后，大概心里对react的五脏六腑有个形状了，接着看文档中的高级指引部分</p><h2 id="react文档中高级指引部分的重点"><a href="#react文档中高级指引部分的重点" class="headerlink" title="react文档中高级指引部分的重点"></a>react文档中高级指引部分的重点</h2><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>在通过动态 import() 语法。</p><pre><code class="js">import(&quot;./math&quot;).then(math =&gt; &#123;  console.log(math.add(16, 26));&#125;);</code></pre><p><strong>使用React.Lazy</strong></p><p><code>React.lazy</code> 函数能让你像渲染常规组件一样处理动态引入（的组件）</p><pre><code class="js">const OtherComponent = React.lazy(() =&gt; import(&#39;./OtherComponent&#39;));</code></pre><h3 id="context（常用）"><a href="#context（常用）" class="headerlink" title="context（常用）"></a>context（常用）</h3><p>内部的一个组件状态通信的一个方法</p><p>定义：<strong>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法</strong>。</p><p><code>theme-context.js</code></p><pre><code class="js">// 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！export const ThemeContext = React.createContext(&#123;  theme: themes.dark,  toggleTheme: () =&gt; &#123;&#125;,&#125;);</code></pre><p><code>theme-toggler-button.js</code></p><pre><code class="js">// 有两种显示方式&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt;&lt;MyContext.Consumer&gt;  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;&lt;/MyContext.Consumer&gt;</code></pre><pre><code class="js">import &#123;ThemeContext&#125; from &#39;./theme-context&#39;;function ThemeTogglerButton() &#123;  // Theme Toggler 按钮不仅仅只获取 theme 值，它也从 context 中获取到一个 toggleTheme 函数  return (    &lt;ThemeContext.Consumer&gt;      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (        &lt;button          onClick=&#123;toggleTheme&#125;          style=&#123;&#123;backgroundColor: theme.background&#125;&#125;&gt;          Toggle Theme        &lt;/button&gt;      )&#125;    &lt;/ThemeContext.Consumer&gt;  );&#125;export default ThemeTogglerButton;</code></pre><p><code>app.js</code></p><pre><code class="js">import &#123;ThemeContext, themes&#125; from &#39;./theme-context&#39;;import ThemeTogglerButton from &#39;./theme-toggler-button&#39;;class App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.toggleTheme = () =&gt; &#123;      this.setState(state =&gt; (&#123;        theme:          state.theme === themes.dark            ? themes.light            : themes.dark,      &#125;));    &#125;;    // State 也包含了更新函数，因此它会被传递进 context provider。    this.state = &#123;      theme: themes.light,      toggleTheme: this.toggleTheme,    &#125;;  &#125;  render() &#123;    // 整个 state 都被传递进 provider    return (      &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt;        &lt;Content /&gt;      &lt;/ThemeContext.Provider&gt;    );  &#125;&#125;function Content() &#123;  return (    &lt;div&gt;      &lt;ThemeTogglerButton /&gt;    &lt;/div&gt;  );&#125;ReactDOM.render(&lt;App /&gt;, document.root);</code></pre><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><strong>Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧,<code>render prop</code> 是一个用于告知组件需要渲染什么内容的函数 prop。</strong><br>类似vue中的 <code>refs</code>,获取真实dom的属性</p><h3 id="何时使用refs"><a href="#何时使用refs" class="headerlink" title="何时使用refs"></a>何时使用refs</h3><ul><li><ol><li>管理焦点，文本选择或媒体播放。</li></ol></li><li><ol start="2"><li>触发强制动画。</li></ol></li><li><ol start="3"><li>集成第三方 DOM 库。</li></ol></li></ul><h2 id="如何使用refs"><a href="#如何使用refs" class="headerlink" title="如何使用refs"></a>如何使用refs</h2><ol><li>创建Refs</li></ol><pre><code class="js">this.myRef = React.createRef()</code></pre><ol start="2"><li>访问Refs</li></ol><pre><code class="js">const node = this.myRef.current;</code></pre><p><strong>默认情况下，你不能在函数组件上使用 <code>ref</code> 属性，因为它们没有实例,在hook函数中useRef,指向一个DOM元素或class组件</strong></p><h2 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h2><p>指一种在 React 组件之间使用一个值为<strong>函数的 prop</strong>共享代码的简单技术</p><pre><code class="js">&lt;DataProvider render=&#123;data =&gt; (  &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;)&#125;/&gt;</code></pre><h2 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h2><p>有两种方式一种是<code>Flow</code>语法，这个我没有用过。所以重点学习另一种<code>TypeScript</code></p><ol><li>在 <code>Create React App</code> 中使用 TypeScript</li></ol><pre><code class="js">npx create-react-app my-app --template typescript</code></pre><ol start="2"><li>添加相关依赖包</li></ol><pre><code class="js">npm install --save typescript @types/node @types/react @types/react-dom @types/jest//oryarn add typescript @types/node @types/react @types/react-dom @types/jest</code></pre><h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>如果你还是不清楚在某个特殊场景中应该使用哪种组件，那么 这篇关于<a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">受控和非受控输入组件的文章</a> 会很有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇看了react的核心概念后，大概心里对react的五脏六腑有个形状了，接着看文档中的高级指引部分&lt;/p&gt;
&lt;h2 id=&quot;react文</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重学React(一)</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/06/React/%E9%87%8D%E5%AD%A6React(%E4%B8%80)/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/06/React/%E9%87%8D%E5%AD%A6React(%E4%B8%80)/</id>
    <published>2020-08-06T05:45:44.000Z</published>
    <updated>2020-09-04T02:18:38.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天手头里项目完成了一个阶段，下个阶段暂时有个星期的时间，正好有时间可以回顾下<code>react</code>。因为之前是选择react比vue要早，但是在之前公司里的技术栈是vue,没办法只有把react放到一旁，开始了<code>vue</code>的踩坑。</p><p>心里还是对react有感情的，这样说的我好像个渣男。。哈哈，确实挺喜欢这两个的框架。<br>既然是重学，自己就定位为react的初学者，要认真，充满激情，先从撸官网开始吧。<br><a href="https://react.docschina.org/">react中文文档</a></p><h2 id="新建一个react应用"><a href="#新建一个react应用" class="headerlink" title="新建一个react应用"></a>新建一个react应用</h2><p>我是通过<a href="https://www.html.cn/create-react-app/docs/getting-started/">create-react-app</a>脚手架工具搭建的react初始界面</p><p>简单的过了一遍<code>creact-react-app</code>的文档，发现自己使用vue开发过项目之后，再返回来学习react知识，感觉轻松多了，以前很多概念理解不了，不知道怎么实现，虽然现在看的是一些基础知识，但是给了自己很大的信心去重学react</p><p>使用下面命令，就可以看的一个简单的react应用了</p><pre><code class="js">npx create-react-app my-appcd my-appyarn start </code></pre><h2 id="开发前的准备"><a href="#开发前的准备" class="headerlink" title="开发前的准备"></a>开发前的准备</h2><ul><li><ol><li>下载了一些vscode中关于react的一些插件，如<code>Reactjs code snippets</code>等</li></ol></li><li><ol start="2"><li>安装<code>prettier，eslint</code>与vscode完美结合，减少一些格式上的错误</li></ol></li><li><ol start="3"><li>从react文档中的核心概念看起，边看边跟着敲敲</li></ol></li></ul><h2 id="文档中一些自己觉得常用的知识"><a href="#文档中一些自己觉得常用的知识" class="headerlink" title="文档中一些自己觉得常用的知识"></a>文档中一些自己觉得常用的知识</h2><h3 id="核心概念部分"><a href="#核心概念部分" class="headerlink" title="核心概念部分"></a>核心概念部分</h3><ul><li><ol><li>react是用jsx后缀名的文件来呈现代码的(ps:不是必须的),后面结合ts的话就是tsx后缀名的文件，总之jsx文件的概念就是<code>all in js</code>，react秉承的也是这种，vue则是数据和视图分离，<br><code>templete</code>标签里编写html部分，<code>script</code>标签中编写js部分，<code>style</code>标签中编写css部分，这种模式是和我们最初写一个网页的结构相似的，便于我们理解。react提倡的jsx理由是这样说的<strong>React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。</strong></li></ol></li></ul><p>一个简单的react示例：</p><pre><code class="js">const name = &#39;Josh Perez&#39;;const element = &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;;ReactDOM.render(  element,  document.getElementById(&#39;root&#39;));</code></pre><ul><li><ol start="2"><li>react 数据传递是通过<code>props</code>自上而下传递，是属于单向数据流，且<code>props</code>是只读的不可更改的。而vue是可以双向数据绑定</li></ol></li></ul><p>目前为止，在 React 中有两种流行的方式来共享组件之间的状态逻辑: <a href="https://react.docschina.org/docs/render-props.html">render props</a> 和<a href="https://react.docschina.org/docs/higher-order-components.html">高阶组件</a></p><ul><li><ol start="3"><li><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">react生命周期</a> <img src="https://static01.imgkr.com/temp/3d03a0c13a2f4da7a4763a1dba50289e.png" alt="react life"></li></ol></li></ul><ul><li><ol start="4"><li>react事件处理的几种方法<pre><code class="js">// 匿名箭头函数&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;// bind方法&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</code></pre></li></ol></li></ul><p>// 或者在方法中直接使用箭头函数，官网说这是实验性语法，不推荐使用，不过这个方法真的很简单明了啊<br> handleClick = () =&gt; {<br>  console.log(‘this is:’, this);<br>}</p><p>// 常见的方法 声明方法后在constructor中在声明一次，比较麻烦，<br>constructor(props) {<br>  super(props);<br>  this.state = {isToggleOn: true};</p><p>  // 为了在回调中使用 <code>this</code>，这个绑定是必不可少的<br>  this.handleClick = this.handleClick.bind(this);<br>}<br>handleClick() {<br>  this.setState(state =&gt; ({<br>    isToggleOn: !state.isToggleOn<br>  }));<br>}</p><pre><code>* 5. 通过花括号包裹代码，你可以在 [JSX 中嵌入任何表达式](https://react.docschina.org/docs/introducing-jsx.html#embedding-expressions-in-jsx), 就和写js文件一样* 6. 表单中的`受控组件`(如`&lt;input&gt;`、 `&lt;textarea&gt;` 和 `&lt;select&gt;`在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新)与`非受控组件 `(在 React 中，`&lt;input type=&quot;file&quot; /&gt;` 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。) </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这几天手头里项目完成了一个阶段，下个阶段暂时有个星期的时间，正好有时间可以回顾下&lt;code&gt;react&lt;/code&gt;。因为之前是选择reac</summary>
      
    
    
    
    <category term="React" scheme="https://shinichikudo-fe.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://shinichikudo-fe.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>如何规范你的git提交?</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/03/Tools/%E5%A6%82%E4%BD%95%E8%A7%84%E8%8C%83%E4%BD%A0%E7%9A%84git%E6%8F%90%E4%BA%A4/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/03/Tools/%E5%A6%82%E4%BD%95%E8%A7%84%E8%8C%83%E4%BD%A0%E7%9A%84git%E6%8F%90%E4%BA%A4/</id>
    <published>2020-08-03T05:33:53.000Z</published>
    <updated>2020-09-04T02:18:38.433Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/5522df15c9ec">原文地址</a></p><h1 id="一、为什么需要规范？"><a href="#一、为什么需要规范？" class="headerlink" title="一、为什么需要规范？"></a>一、为什么需要规范？</h1><p>无规矩不成方圆，编程也一样。</p><p>如果你有一个项目，从始至终都是自己写，那么你想怎么写都可以，没有人可以干预你。可是如果在团队协作中，大家都张扬个性，那么代码将会是一团糟，好好的项目就被糟践了。不管是开发还是日后维护，都将是灾难。</p><p>这时候，有人提出了何不统一标准，大家都按照这个标准来。于是 ESLint，JSHint 等代码工具如雨后春笋般涌现，成为了项目构建的必备良品。</p><p><code>Git Commit</code> 规范可能并没有那么夸张，但如果你在版本回退的时候看到一大段糟心的 Commit，恐怕会懊恼不已吧。所以，严格遵守规范，利人利己。</p><p>二、具体规则</p><p>先来看看公式：</p><p><strong><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></strong></p><blockquote><p>type 用于说明 commit 的类别，只允许使用下面7个标识。</p></blockquote><ul><li>feat：新功能(feature)</li><li>fix：修补</li><li>bugdocs：文档(documentation)</li><li>style：格式(不影响代码运行的变动);</li><li>refactor：重构(即不是新增功能，也不是修改bug的代码变动)</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><blockquote><p>scope 用于说明 commit 影响的范围，比如<code>数据层、控制层、视图层</code>等等，视项目不同而不同。</p></blockquote><blockquote><p>subject 是 commit 目的的简短描述，不超过50个字符。</p></blockquote><ul><li>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</li><li>第一个字母小写</li><li>结尾不加句号(.)</li></ul><h1 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h1><p>我们先来看看这个异常提醒：</p><pre><code class="js">INVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; ! jartto:fix bug </code></pre><p>这里之所以报出这个警告，是因为我的提交出现了两个问题：</p><ul><li>其一，使用了规范外的关键字;</li><li>其二，很细节的问题，<code>jartto：</code>后少了空格;</li></ul><p>这时候我才回忆起来，当时提交一直失败，情急之下直接强制提交，所以以后的提交都会抱出这个异常。大致意思就是：</p><blockquote><p>你的之前的 Commit 不合格～你的之前的 Commit 不合格～你的之前的 Commit 不合格</p></blockquote><p>这时候就很烦了，我们只能去将之前的错误修正，那么如何操作呢?</p><h1 id="四、如何修改之前的-commit-信息？"><a href="#四、如何修改之前的-commit-信息？" class="headerlink" title="四、如何修改之前的 commit 信息？"></a>四、如何修改之前的 commit 信息？</h1><p>其实并不复杂，我们只需要这样做:</p><ul><li>1、将当前分支无关的工作状态进行暂存 <code>git stash</code></li><li>2、将 HEAD 移动到需要修改的 commit 上 <code>git rebase 9633cf0919^ --interactive</code></li><li>3、找到需要修改的 commit ,将首行的 pick 改成 edit</li><li>4、开始着手解决你的 bug</li><li>5、<code>git add </code>将改动文件添加到暂存</li><li>6、<code>git commit –amend</code> 追加改动到提交</li><li>7、<code>git rebase –continue</code> 移动 HEAD 回最新的 commit</li><li>8、恢复之前的工作状态 <code>git stash pop</code></li></ul><p>大功告成，是不是想把整个 Commit 都修改一遍</p><h1 id="五、项目中使用"><a href="#五、项目中使用" class="headerlink" title="五、项目中使用"></a>五、项目中使用</h1><p>这时候问题又来了，为什么我提交的时候会有警告，这个又是如何做到的呢?</p><p>这时候，我们需要一款 Node 插件 <code>validate-commit-msg</code> 来检查项目中 <code>Commit message</code> 是否规范。</p><ul><li>1.首先，安装插件：</li></ul><pre><code class="js">npm install --save-dev validate-commit-msg </code></pre><ul><li><p>2.使用方式一，建立 .vcmrc 文件：</p><pre><code class="js">&#123; &quot;types&quot;: [&quot;feat&quot;, &quot;fix&quot;, &quot;docs&quot;, &quot;style&quot;, &quot;refactor&quot;, &quot;perf&quot;, &quot;test&quot;, &quot;build&quot;, &quot;ci&quot;, &quot;chore&quot;, &quot;revert&quot;], &quot;scope&quot;: &#123;   &quot;required&quot;: false,   &quot;allowed&quot;: [&quot;*&quot;],   &quot;validate&quot;: false,   &quot;multiple&quot;: false &#125;, &quot;warnOnFail&quot;: false, &quot;maxSubjectLength&quot;: 100, &quot;subjectPattern&quot;: &quot;.+&quot;, &quot;subjectPatternErrorMsg&quot;: &quot;subject does not match subject pattern!&quot;, &quot;helpMessage&quot;: &quot;&quot;, &quot;autoFix&quot;: false &#125;</code></pre></li><li><p>3.使用方式二：写入 package.json</p></li></ul><pre><code class="json">&#123;   &quot;config&quot;: &#123;     &quot;validate-commit-msg&quot;: &#123;       /* your config here */     &#125;   &#125; &#125;</code></pre><ul><li>4.可是我们如果想自动使用 ghooks 钩子函数呢？</li></ul><pre><code class="js">&#123;   …   &quot;config&quot;: &#123;     &quot;ghooks&quot;: &#123;       &quot;pre-commit&quot;: &quot;gulp lint&quot;,       &quot;commit-msg&quot;: &quot;validate-commit-msg&quot;,       &quot;pre-push&quot;: &quot;make test&quot;,       &quot;post-merge&quot;: &quot;npm install&quot;,       &quot;post-rewrite&quot;: &quot;npm install&quot;,       …     &#125;   &#125;   … &#125; </code></pre><p>在 ghooks 中我们可以做很多事情，当然不只是 <code>validate-commit-msg</code>哦。</p><h1 id="六、Commit-规范的作用"><a href="#六、Commit-规范的作用" class="headerlink" title="六、Commit 规范的作用"></a>六、Commit 规范的作用</h1><ul><li>提供更多的信息，方便排查与回退;</li><li>过滤关键字，迅速定位;</li><li>方便生成文档;</li></ul><h1 id="七、生成-Change-log"><a href="#七、生成-Change-log" class="headerlink" title="七、生成 Change log"></a>七、生成 Change log</h1><p>正如上文提到的生成文档，如果我们的提交都按照规范的话，那就很简单了。生成的文档包括以下三个部分：</p><p><strong>New features</strong></p><p><strong>Bug fixes</strong></p><p><strong>Breaking changes</strong></p><p>每个部分都会罗列相关的 <code>commit</code> ，并且有指向这些 <code>commit</code> 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p><p>这里需要使用工具 <code>Conventional Changelog</code> 生成 <code>Change log</code>：</p><pre><code class="js">npm install -g conventional-changelog cd jartto-domo conventional-changelog -p angular -i CHANGELOG.md -w</code></pre><p>为了方便使用，可以将其写入 <code>package.json</code> 的 scripts 字段。</p><pre><code class="js">&#123;   &quot;scripts&quot;: &#123;     &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;   &#125; &#125;</code></pre><p>这样，使用起来就很简单了：</p><pre><code class="js"> npm run changelog</code></pre><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>看完文章，你还会如此放荡不羁吗?你还会随心所欲的编写 Commit 吗?你还会如此 git commit -m “hello world”提交吗?</p><p>答案是否定的，因为使用了钩子函数，你没有机会了，否则将是无穷无尽的恢复 Commit。这倒可以养成良好的提交习惯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/5522df15c9ec&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、为什么需要规范？&quot;&gt;&lt;a href=&quot;#一、为什么需要规范？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么需要</summary>
      
    
    
    
    <category term="Tools" scheme="https://shinichikudo-fe.github.io/categories/Tools/"/>
    
    
    <category term="git" scheme="https://shinichikudo-fe.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>响应式布局新方案</title>
    <link href="https://shinichikudo-fe.github.io/2020/07/30/HTML5/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E6%96%B0%E6%96%B9%E6%A1%88/"/>
    <id>https://shinichikudo-fe.github.io/2020/07/30/HTML5/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E6%96%B0%E6%96%B9%E6%A1%88/</id>
    <published>2020-07-30T03:20:15.000Z</published>
    <updated>2020-09-04T02:18:38.383Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&mid=2247488692&idx=1&sn=5296bb93e4fcec284fe8dfe858634e9b&chksm=c0669522f7111c345f71416e84d2a6a32fe730be9e7734eee71a8c1bd93d61467df3c4075257&mpshare=1&scene=1&srcid=0730IrQ52ONYNC8eirsY5vf6&sharer_sharetime=1596079115612&sharer_shareid=857ca04011f1cc878c5f0c9e8e947d57&key=3c1b79f4d2f73bee114f16dcdfd3b504678f8d95031f428469c7a393e3314e043cbfa073c22cc8b27fd6e46074839d9dc6941a9801bc8145315e56cc9849f39ebd3a36532aadb9630bbd9d2ba5e887a6&ascene=1&uin=MTA4OTc2NTY3Mg==&devicetype=Windows+10+x64&version=62090538&lang=zh_CN&exportkey=A597mrIlaQ+2fkuWhB0UYgw=&pass_ticket=KFo0GUOexWMIpxp6jEIHplHkIy/bm272lNRA4DRRf+xq5hWFuvoJ7oFj7xf+oyh6">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>概念：融合响应式设计</p><p>本文中我们可以尝试得出一种新的解决方案，那就是利用 JavaScript 和 CSS 来进行媒体查询，是响应式设计与自适应设计结合的方案，我这里给起一个好记的名字叫做融合响应式设计（ <code>Fusion Web Design</code>，简称 FWD ）。</p><p>技术原则：</p><ul><li>JavaScript 判断尽量少</li><li>CSS 媒体查询的断点也尽量少</li></ul><p>UI效果</p><ul><li>在笔记本、平板电脑、智能手机上展示合适的 UI 效果</li><li>PC UI：给笔记本等设备上看的大屏效果</li><li>Mobile UI：给智能手机上看的小屏效果</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9F72dq8UWxDyh6qn8gbhYGKpZgmUTNUy5UibVnrzQ09SkYGwIOyiaaw79g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="demo"></p><p>但这里，还是有一个遗漏的为平板电脑上效果。</p><p>先前，<code>iPad Air</code> 或 <code>iPad Mini</code> 会被归类到智能手机的 Mobile UI 范围，但是这两年新出的 <code>iPad Pro</code> 的宽高单纯展示 PC UI 或 Mobile UI，效果都不是很理想。</p><ul><li>iPad Pro （横屏 1366px）展示 Mobile站点内容，中间内容区域只有 768px</li><li>iPad Mini （横屏 1024px）展示PC 站点内容，右侧容易被截取</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FphodDhHCJQFcApagNClp7u7d7Hjcf9U8V56qXPnZSuathD4H7ibaICA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="ipad Demo"></p><h2 id="先说为何不能以-UserAgent-来作为依据"><a href="#先说为何不能以-UserAgent-来作为依据" class="headerlink" title="先说为何不能以 UserAgent 来作为依据"></a>先说为何不能以 UserAgent 来作为依据</h2><p>iPad 装着 iOS 系统，其 UserAgent 中包含着 iPad 字眼，一般可用来判断 iPad。</p><pre><code class="js">Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1</code></pre><p>那么，这里的一个的难点为不能使用 <code>UserAgent</code> 来判断 <code>iPad Pro（iPad OS）</code>，因为它的 <code>UserAgent</code> 太像 MacBook Pro。</p><p>iPad Pro 上装着 iPad OS 系统，其 <code>UserAgent</code> 为</p><pre><code class="js">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.2 Safari/605.1.15</code></pre><p>MacBook Pro 的 Safari 浏览器的 <code>UserAgent</code> 为</p><pre><code class="js">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.1 Safari/605.1.15</code></pre><p>当然，也不能一直通过 UserAgent 来区分各种设备，因为以后新出的设备会更多。</p><ul><li>12.9 英寸 iPad Pro (第四、三、二、一代)</li><li>11 英寸 iPad Pro (第二、一代)</li><li>10.5 英寸 iPad Pro</li><li>9.7 英寸 iPad Pro</li><li>iPad (第七、六、五代)</li><li>iPad mini (第五、4代)</li><li>iPad Air (第三、2代)</li><li>…</li></ul><h2 id="依据设备横竖屏及宽高特点"><a href="#依据设备横竖屏及宽高特点" class="headerlink" title="依据设备横竖屏及宽高特点"></a>依据设备横竖屏及宽高特点</h2><p>这里，我先列举一下我的目标设备的网页宽高、设备特点。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FyjD73wjHTUiaZgcoWMWCd5KiaHLXUs9kzoG4D4CbfnHQptpbMUsBxs8Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="目标设备"></p><p>判断的主要依据：</p><ul><li>设备是否支持横竖屏切换</li><li>刚进页面时设备的宽高</li><li>设备在横竖屏切换后的宽高</li></ul><p>那么，常见的设备显示效果如下：</p><ul><li>常见笔记本电脑的最小宽高为 1280x800，显示的为 PC UI</li><li>常见智能手机的最大屏为 iPhone11 pro max，网页宽高为 414x896，无论是横竖屏都现实的是 Mobile UI。</li></ul><p>难点还是在 iPad 设备上，根据上面的表格我们发现，平板电脑支持横竖屏切换，竖屏范围在 768、834、1024 上，横屏范围在1024、1194、1366上。</p><p>最大的难点就在于，1024宽度应该显示 Mobile UI 还是PC UI呢？</p><p>这里我选择将判断的断点改为<code>1040px</code> 上，就是将最大宽不超过<code>1024px</code>的设备都认为 Mobile UI 。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FnvSymbRYKGqib8UHw5JR9a3RD7zEAqyPq7obdvB9xLvgSXM4Ek1Fdbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="决定设备大小"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FkX2A642fDoRVOia1Zle0o9Egll4pzkgABqOcCXgNbQIPbU9yXxFxA9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="效果图pc"><br><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9F9UGve7q7H6goDn42eY45Jn7RDDZ9xYT6PHVrKlF1UKPwia3Jgic3oO6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="效果图mobile"></p><blockquote><p>区分 Mobile UI 和 PC UI 的完整的判断逻辑如下：</p></blockquote><p>1.笔记本电脑，不支持 onorientationchange 横竖屏切换的，就认定为 PC</p><ul><li>不使用 onRisize 来监听网页的宽高，因为性能消耗大</li><li>并且当浏览器拖动小了，支持左右滚动</li></ul><p>2.进入页面时，竖屏时以 <code>window.innerWidth, window.innerHeight</code> 中数值小的那个来判断，横屏中以 <code>window.innerWidth, window.innerHeight</code> 数值大的来判断，当宽度大于 1040px 时认为是 PC ，宽度小于 1040px 时，认定为 Mobile 。</p><p>3.横竖屏切换时，重复第 2 步的判断</p><p>备注：</p><ul><li><code>window.innerWidth, window.innerHeight</code> 在安卓和 iOS 上的横竖屏切换上有不一致的地方，所以以最大值或最小值来做更准确。</li></ul><h2 id="源码示例"><a href="#源码示例" class="headerlink" title="源码示例"></a>源码示例</h2><pre><code class="js">import React from &#39;react&#39; // JavaScript 的媒体查询 const mqlMedia = window.matchMedia(&#39;(orientation: portrait)&#39;)function onMatchMediaChange(mql = window.matchMedia(&#39;(orientation: portrait)&#39;)) &#123;   if (mql.matches) &#123;     //竖屏     return &#39;portrait&#39;   &#125; else &#123;     //横屏     return &#39;horizontal&#39;   &#125; &#125; // 输出当前屏幕模式 const getUiMode = (uiMode = &#39;&#39;, mql) =&gt; &#123;   if (uiMode) return uiMode   if (!(&#39;onorientationchange&#39; in window)) return &#39;pc&#39;   let status = onMatchMediaChange(mql)   let width = status === &#39;portrait&#39; ? Math.min(window.innerWidth, window.innerHeight) : Math.max(window.innerWidth, window.innerHeight)   if (width &gt; 1040) return &#39;pc&#39;   return &#39;mobile&#39; &#125; const getIsPcMode = (uiMode) =&gt; uiMode === &#39;pc&#39; /**  * UI 模式，判断逻辑  * @export  * @param &#123;*&#125; Cmp  * @returns  */ export function withUiMode(Cmp, options = &#123;&#125;) &#123;   return class WithUIRem extends React.Component &#123;     constructor(props) &#123;       super(props)       let uiMode = getUiMode()       let isPCMode = getIsPcMode(uiMode)       this.state = &#123;         uiMode: uiMode,         isPCMode: isPCMode,       &#125;     &#125;     // 横竖屏切换监听     componentDidMount() &#123;       mqlMedia.addListener(this.changeUiMode)     &#125;     componentWillUnmount() &#123;       mqlMedia.removeListener(this.changeUiMode)     &#125;     changeUiMode = (mql) =&gt; &#123;       let newUiMode = getUiMode(&#39;&#39;, mql)       if (newUiMode !== this.state.uiMode) &#123;         this.setState(&#123;           isPCMode: getIsPcMode(newUiMode),           uiMode: newUiMode         &#125;)       &#125;     &#125;     render() &#123;       return &lt;Cmp &#123;...this.state&#125; &#123;...this.props&#125; /&gt;     &#125;   &#125; &#125; export default (options) =&gt; &#123;   return (Cmp) =&gt;  withUiMode(Cmp, options) &#125;</code></pre><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><pre><code class="js">// 装饰器的方式来使用 @withUiMode() export default class Video extends React.Component &#123;   render() &#123;     const &#123; isPCMode, uiMode &#125; = this.props     return (       &lt;Page isPCMode=&#123;isPCMode&#125;&gt;&lt;/Page&gt;     )   &#125; &#125;</code></pre><h2 id="符合设计师需求的细节"><a href="#符合设计师需求的细节" class="headerlink" title="符合设计师需求的细节"></a>符合设计师需求的细节</h2><p>在区分好 PC UI 和 Mobile UI 的判断设定后，我们还要关心的是在一些常见的设备上的显示效果，比如 iPad 横竖屏、大屏显示器。</p><h3 id="Mobile-UI-效果中的优化"><a href="#Mobile-UI-效果中的优化" class="headerlink" title="Mobile UI 效果中的优化"></a>Mobile UI 效果中的优化</h3><p>在 Mobile UI 模式下，iPad Mini 显示效果如下：</p><ul><li>竖屏的为 768px，此时显示的平铺拉伸版效果</li><li>横屏的为 1024px，此时显示的平铺拉伸版效果</li></ul><p>所以 Mobile UI 就有了如下的 CSS 最大宽的设定：</p><pre><code class="css">// Mobile 模式下页面最大宽 $max-body-width = 768px // Mobile 模式下的内容宽度 $max-body-width-center = $max-body-width - 40px</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FjNWVjE6XFHS03VicrNNs5Me6s031m48QNvXf9xm8GJfqZesUd0LACAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="mobile ui"></p><h3 id="PC-UI-效果中的优化"><a href="#PC-UI-效果中的优化" class="headerlink" title="PC UI 效果中的优化"></a>PC UI 效果中的优化</h3><p>在上面的 PC UI 的判定中，我们是以 1040px 作为判断区间的，那么在这个宽度下，推荐设计师以 960px 为设计宽度，这样两侧就各有 40px 的留白，以此来增加整个页面的呼吸感。</p><p>那么，市面上绝大部分的设备其实是比 1280px 还要大的。此时，可以选择以 1220px 作为更大屏的媒体查询断点。也就是说，我这里运用了响应式设计中的 CSS 媒体查询。</p><p>为何不选用 1400px 呢，因为在 CCtalk 上课的网师、学生所使用的主流设备分辨率宽度还是在 <code>1280px、1366px、1440px</code>这几个区间的。</p><p>所以，有如下 PC UI 的 CSS 最大宽设定：</p><pre><code class="css">// PC 模式下小屏的宽度断点 $page-min-width = 1040px // 小屏模式下的内容宽度 $page-min-width-center = $page-min-width - 80px // PC 模式下大屏的宽度断点 $page-max-width = 1220px // 触屏三合一上的最大宽 // 大屏模式下的内容宽度 $page-max-width-content = $page-max-width - 60px</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FPxUXzd4atVRN69Y2ya1ctHvbURjPhaHLiaz5uuBDuCOBTxWSjKN71fg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="pc ui"></p><h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><p>使用融合响应式设计时，需要尽量在设计师进行 UI 设计前就与其商量好设计规范。</p><p>我认为需要注意如下两点：</p><ul><li>1.只修改模块的宽度、边距</li><li>2.保证模块内的所有细节都不调整模块细节内容的 UI，如字体、宽高、间距</li></ul><p>如果 Mobile UI 与 PC UI 的细节差异很大，那无论是响应式设计、自适应设计，还是我认为的融合响应式设计，在网页制作过程中，都是非常难做的，后期维护成本也是非常高的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>融合响应式设计（ Fusion Web Design，简称 FWD），利用 JavaScript 和 CSS 来进行媒体查询，是响应式设计与自适应设计结合的方案。</p><ul><li>自适应设计：根据设备特点，使用 JavaScript 来区分 PC UI 和 Mobile UI</li><li>响应式设计：在需要调整出更好的 UI 时，可以加入一些 CSS 媒体查询的断点，比如常见的大屏显示效果</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&amp;mid=2247488692&amp;idx=1&amp;sn=5296bb93e4fcec284fe8dfe858634e9b&amp;chksm=c0669522f7111c3</summary>
      
    
    
    
    <category term="HTML5" scheme="https://shinichikudo-fe.github.io/categories/HTML5/"/>
    
    
    <category term="响应式" scheme="https://shinichikudo-fe.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>拥抱Vue3系列之jsx语法</title>
    <link href="https://shinichikudo-fe.github.io/2020/07/07/Vue/%E6%8B%A5%E6%8A%B1Vue3%E7%B3%BB%E5%88%97%E4%B9%8Bjsx%E8%AF%AD%E6%B3%95/"/>
    <id>https://shinichikudo-fe.github.io/2020/07/07/Vue/%E6%8B%A5%E6%8A%B1Vue3%E7%B3%BB%E5%88%97%E4%B9%8Bjsx%E8%AF%AD%E6%B3%95/</id>
    <published>2020-07-07T05:48:26.000Z</published>
    <updated>2020-09-04T02:18:38.447Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5f01d7886fb9a07e6835601a?utm_source=gold_browser_extension#heading-6">原文地址</a></p><p>在过去的一年中，Vue 团队一直都在开发 Vue.js 的下一个主要版本，就在 6 月底，尤大更新同步了 Vue 3 及其周边生态的状态(<a href="https://github.com/vuejs/rfcs/issues/183">Vue 3: mid 2020 status update</a>)。</p><pre><code class="js">if (isTrue(&quot;I am planning to use Vue 3 for a new project&quot;)) &#123;  if (isTrue(&quot;I need IE11 support&quot;)) &#123;    await IE11CompatBuild() // July 2020  &#125;  if (isTrue(&quot;RFCs are too dense, I need an easy-to-read guide&quot;)) &#123;    await migrationGuide() // July 2020  &#125;  if (isTrue(&quot;I&#39;d rather wait until it&#39;s really ready&quot;) &#123;      await finalRelease() // Targeting early August 2020  &#125;)  run(`npm init vite-app hello-vue3`)  return&#125;</code></pre><p>我们可以看到，如果一切顺利的话，预计在 8 月份，Vue 3 的正式版本就可以和我们见面了，目前距离发布正式版还有一定的差距，还要做一些兼容性的工作。同时还会提供对 IE11 的支持。</p><p>Vue 3 为了达到更快、更小、更易于维护、更贴近原生、对开发者更友好的目的，在很多方面进行了重构：</p><blockquote><p>全面拥抱 TypeScript<br>重构 complier<br>重构 Virtual DOM<br>…</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是该系列文章的第一篇，后续会持续更新，覆盖 <code>Vue 3</code>生态常用库。</p><p>JSX 是一个小众群体使用开发方式，第一篇以 JSX 为切入点，目标是让大多数开发 Vue 的同学也对 JSX 有一定的认知，在用 Vue 开发复杂应用时，也能有更加灵活的方式。<br>比如当开始写一个只能通过 <code>level prop</code> 动态生成标题 (heading) 的组件时，你可能很快想到这样实现：</p><pre><code class="js">&lt;script type=&quot;text/x-template&quot; id=&quot;anchored-heading-template&quot;&gt;  &lt;h1 v-if=&quot;level === 1&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/h1&gt;  &lt;h2 v-else-if=&quot;level === 2&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/h2&gt;  &lt;h3 v-else-if=&quot;level === 3&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/h3&gt;&lt;/script&gt;</code></pre><p>这里用模板并不是最好的选择，在每一个级别的标题中重复书写了 <code>&lt;slot&gt;&lt;/slot&gt;</code>，不够优雅。</p><p>如果尝试用 JSX 来写，代码就会变得简单很多。</p><pre><code class="js">const App = &#123;  render() &#123;    const tag = `h$&#123;this.level&#125;`    return &lt;tag&gt;&#123;this.$slots.default&#125;&lt;/tag&gt;  &#125;&#125;</code></pre><p>看过 <a href="https://github.com/vueComponent/ant-design-vue">Ant Design Vue</a> 源码 (下面简称为 <code>antdv</code>) 的同学应该知道， <code>antdv</code> 的底层是基于 JSX 来实现的，也是 Vue 生态中使用 JSX 的深度用户。</p><p>antd 为了尽快的兼容 Vue 3，和 Vue 官方展开合作，于是有了 <a href="https://github.com/vueComponent/jsx">@ant-design-vue/babel-plugin-jsx</a>。</p><h2 id="Vue-JSX-简介"><a href="#Vue-JSX-简介" class="headerlink" title="Vue JSX 简介"></a>Vue JSX 简介</h2><p>对于使用 React 的开发者来说，JSX 再熟悉不过了，但是如果你是一个 Vue 的重度用户，可能对 JSX 不是特别熟悉，甚至听到有同学说没有 template 的 Vue 项目没有灵魂。</p><p>先来看下面一段代码：</p><pre><code class="js">const el = &lt;div&gt;Vue 3&lt;/div&gt;;</code></pre><p>这段代码既不是 HTML 也不是字符串，被称之为 JSX，是 JavaScript 的扩展语法。JSX 可能会使人联想到模板语法，但是它具备 Javascript 的完全编程能力。</p><p>看到这里可能会有疑问，不少同学可能会以为 JSX 是 React 中特有的，其实不然。</p><p>大多数同学都知道，我们平常在 <code>.vue</code> 文件中开发的代码，实际上会被 vue-loader 处理，但可能少数同学去看过我们手把手写出的代码，会变编译成啥样。</p><p>有兴趣的同学可以戳这个地址来看下。<a href="https://vue-template-explorer.netlify.app/">vue-template-explorer</a> (因为众所周知的原因，可能访问略慢)</p><pre><code class="js">&lt;div id=&quot;app&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</code></pre><pre><code class="js">function render() &#123;  with(this) &#123;    return _c(&#39;div&#39;, &#123;      attrs: &#123;        &quot;id&quot;: &quot;app&quot;      &#125;    &#125;, [_v(_s(msg))])  &#125;&#125;</code></pre><p>观察上述代码我们发现，到运行阶段实际上都是 render 函数在执行。Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，就需要使用 render 函数，它比 template 更加灵活。</p><p>写过 render 函数的同学可能深有体会，书写复杂的 render 函数异常痛苦，而且难以维护，非常容易被称之为 “祖传代码”。好在2.0 的官方提供了一个 <a href="https://link.zhihu.com/?target=https://github.com/vuejs/babel-plugin-transform-vue-jsx">Babel 插件</a>，可以将更接近于模板语法的 JSX 转译成 JavaScript。</p><p>使用过 React 的同学对于如何写 JSX 语法一定非常熟悉了，然而，Vue 2 中 的 JSX 写法和 React 还是有一些略微的区别。React 中所有传递的数据都挂在顶层。</p><pre><code class="js">const App = &lt;A className=&quot;x&quot; style=&#123;style&#125; onChange=&#123;onChange&#125; /&gt;</code></pre><p>Vue 2 中，仅仅属性就有三种：<code>组件属性 props，普通 html 属性attrs，DOM 属性 domProps</code>。想要更多了解如何在 Vue 2 中写 JSX 语法，可以看这篇，<a href="https://zhuanlan.zhihu.com/p/37920151">在 Vue 中使用 JSX 的正确姿势</a>。</p><h2 id="Vue-3-中对-JSX-带来的改变"><a href="#Vue-3-中对-JSX-带来的改变" class="headerlink" title="Vue 3 中对 JSX 带来的改变"></a>Vue 3 中对 JSX 带来的改变</h2><h3 id="属性传递"><a href="#属性传递" class="headerlink" title="属性传递"></a>属性传递</h3><p>Vue 3 中，属性这块的传递和 React 类似，意味这不需要再传递 props，attrs 这些属性。</p><pre><code class="js">// before&#123;  class: [&#39;foo&#39;, &#39;bar&#39;],  style: &#123; color: &#39;red&#39; &#125;,  attrs: &#123; id: &#39;foo&#39; &#125;,  domProps: &#123; innerHTML: &#39;&#39; &#125;,  on: &#123; click: foo &#125;,  key: &#39;foo&#39;&#125;// after&#123;  class: [&#39;foo&#39;, &#39;bar&#39;],  style: &#123; color: &#39;red&#39; &#125;,  id: &#39;foo&#39;,  innerHTML: &#39;&#39;,  onClick: foo,  key: &#39;foo&#39;&#125;</code></pre><h3 id="指令改版"><a href="#指令改版" class="headerlink" title="指令改版"></a>指令改版</h3><p>Vue 3 把大多数全局 API 和 内部 helper 移到了 ES 模块中导出(譬如 <code>v-model、transition、teleport</code>)，从而使得 Vue 3 在增加了很多新特性之后，基线的体积反而小了。</p><p><code>v-model、v-show</code> 这些 API 全部通过模块导出的方式来引入</p><blockquote><p>基线体积： 无法舍弃的代码体积</p></blockquote><p>我们来看一段非常简单的代码 <code>&lt;input v-model=&quot;x&quot; /&gt;</code>，在 Vue 2 和 Vue 3 中的编译结果有何不同。</p><pre><code class="js">// Vue 2 beforefunction render() &#123;  with(this) &#123;    return _c(&#39;input&#39;, &#123;      directives: [&#123;        name: &quot;model&quot;,        rawName: &quot;v-model&quot;,        value: (x),        expression: &quot;x&quot;      &#125;],      domProps: &#123;        &quot;value&quot;: (x)      &#125;,      on: &#123;        &quot;input&quot;: function ($event) &#123;          if ($event.target.composing) return;          x = $event.target.value        &#125;      &#125;    &#125;)  &#125;&#125;</code></pre><pre><code class="js">// Vue 3 afterimport &#123; vModelText as _vModelText, createVNode as _createVNode, withDirectives as _withDirectives, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache) &#123;  return _withDirectives((_openBlock(), _createBlock(&quot;input&quot;, &#123;    &quot;onUpdate:modelValue&quot;: $event =&gt; (_ctx.x = $event)  &#125;, null, 8 /* PROPS */, [&quot;onUpdate:modelValue&quot;])), [    [_vModelText, _ctx.x]  ])&#125;</code></pre><p>可以看到在 Vue 3 中，对各个 API 做了更加细致的拆分，理想状态下，用户可以在构建时利用摇树优化 (<code>tree-shaking</code>) 去掉框架中不需要的特性，只保留自己用到的特性。</p><p>模版编译器会生成适合做 <code>tree-shaking</code> 的代码，不需要使用者去关心如何去做，这部分的改动同样需要在 JSX 写法中实现。</p><p>模板编译器中增加了 <code>PatchFlag</code>，在 JSX 的编译过程同样也做了处理，性能会有提升，但是考虑到 JSX 的灵活性，做了一些兼容处理，该功能还在测试阶段。</p><h2 id="从-Vue-2-到-Vue-3-的过渡"><a href="#从-Vue-2-到-Vue-3-的过渡" class="headerlink" title="从 Vue 2 到 Vue 3 的过渡"></a>从 Vue 2 到 Vue 3 的过渡</h2><p>Vue 3 虽然引入了一部分破坏性的更新，但对于绝大多数 Vue 2 的 API 还是兼容的。那么同样的，我们也要尽可能让使用 JSX 的用户通过最小的成本升级到 Vue 3，这是一个核心的目标。<br>写这篇文章的时候，antdv 已经使用 <a href="https://github.com/vueComponent/ant-design-vue">@ant-design-vue/babel-plugin-jsx</a> 重构了大约 70% 的功能，预计会在 Vue 3 正式版之前发布测试版，大概率会是东半球最快兼容 Vue 3 的企业级组件库。</p><h3 id="Vue-3-JSX-的-API-设计"><a href="#Vue-3-JSX-的-API-设计" class="headerlink" title="Vue 3 JSX 的 API 设计"></a>Vue 3 JSX 的 API 设计</h3><ul><li>函数式组件</li></ul><pre><code class="js">const App = () =&gt; &lt;div&gt;Vue 3 JSX&lt;/div&gt;</code></pre><ul><li>普通组件</li></ul><pre><code class="js">const App = &#123;  render() &#123;    return &lt;div&gt;Vue 3.0&lt;/div&gt;  &#125;&#125;</code></pre><pre><code class="js">const App = defineComponent(() =&gt; &#123;  const count = ref(0);  const inc = () =&gt; &#123;    count.value++;  &#125;;  return () =&gt; (    &lt;div onClick=&#123;inc&#125;&gt;      &#123;count.value&#125;    &lt;/div&gt;  )&#125;)</code></pre><ul><li>Fragment</li></ul><pre><code class="js">const App = () =&gt; (  &lt;&gt;    &lt;span&gt;I&#39;m&lt;/span&gt;    &lt;span&gt;Fragment&lt;/span&gt;  &lt;/&gt;)</code></pre><p>Fragment 参考 React 的写法，尽可能写起来更加方便。</p><ul><li>Attributes/Props</li></ul><pre><code class="js">const App = () =&gt; &lt;input type=&quot;email&quot; /&gt;const placeholderText = &#39;email&#39;const App = () =&gt; (  &lt;input    type=&quot;email&quot;    placeholder=&#123;placeholderText&#125;  /&gt;)</code></pre><ul><li>指令</li></ul><blockquote><p>建议在 JSX 中使用驼峰 (vModel)，但是 v-model 也能用</p></blockquote><p><strong>v-show</strong></p><pre><code class="js">const App = &#123;  data() &#123;    return &#123; visible: true &#125;;  &#125;,  render() &#123;    return &lt;input vShow=&#123;this.visible&#125; /&gt;;  &#125;,&#125;;</code></pre><p><strong>v-model</strong></p><blockquote><p>修饰符：使用 (_) 代替 (.) (vModel_trim={this.test})</p></blockquote><pre><code class="js">export default &#123; data: () =&gt; (&#123;   test: &#39;Hello World&#39;, &#125;), render() &#123;   return (     &lt;&gt;       &lt;input type=&quot;text&quot; vModel_trim=&#123;this.test&#125; /&gt;       &#123;this.test&#125;     &lt;/&gt;   ) &#125;,&#125;</code></pre><p><strong>自定义指令</strong></p><pre><code class="js">const App = &#123;  directives: &#123; antRef &#125;,  setup() &#123;    return () =&gt; (      &lt;a        vAntRef=&#123;(ref) =&gt; &#123; this.ref = ref; &#125;&#125;      /&gt;    );  &#125;,&#125;</code></pre><ul><li>插槽</li></ul><p>关于指令、插槽最终的 API 还在讨论中，有想法的可以去留言。<a href="https://github.com/vuejs/jsx/issues/141">Vue 3 JSX Design</a></p><h3 id="Vue-2-的-JSX-写法如何快速迁移到-Vue-3"><a href="#Vue-2-的-JSX-写法如何快速迁移到-Vue-3" class="headerlink" title="Vue 2 的 JSX 写法如何快速迁移到 Vue 3"></a>Vue 2 的 JSX 写法如何快速迁移到 Vue 3</h3><p>由于 antdv 的底层基本上都是基于 JSX 来写的，想要快速迁移到 Vue 3，就必须有一个比较好的插件来支持，这也是为什么会有这个插件的原因。当然在实现过程中也踩了很多坑。</p><p>目前用法和 Vue 2 的语法大多数是一致的，为了帮助更快迁移，在插件中做了针对旧 VNode 格式的兼容层，这里只能兼容一部分写法，以及部分语法的兼容会增加运行时的性能开销，所以我们希望能够将我们的经验分享给大家，让大家少走弯路！</p><pre><code class="js">&#123;  &quot;plugins&quot;: [&quot;@ant-design-vue/babel-plugin-jsx&quot;, &#123; &quot;transformOn&quot;: true, &quot;compatibleProps&quot;: true &#125;]&#125;</code></pre><ul><li>transformOn</li></ul><p>针对 Vue 2 中 <code>on: &#123; click: xx &#125;</code> 写法的兼容，在运行时中会转为 <code>onClick: xxx</code>。</p><ul><li>compatibleProps</li></ul><p>上文提到 Vue 3 对属性的传递做了变更，<code>props、attrs</code> 这些都不存在了，因此如果设置了这个属性为 true，在运行时也会被解构到第一层的属性中。</p><p>需要注意的一点，目前一旦开启这两个属性，在 <code>createVNode</code> 的第二个参数，都会包一个 <code>compatibleProps</code> 和 <code>transformOn</code> 方法，所以酌情开启这两个参数。对于使用 Vue 2 的 JSX 同学，如果没有使用到比较”不为人知“ 的 API的情况下，都可以快速得迁移。</p><p>那么 antdv 又是如何做迁移的呢？考虑到 antdv 是个组件库，都包一层 <code>compatibleProps</code> 势必不太优雅，因此没有选择开启这个两个开关。这里插一句，目前 antdv 的迁移还在进行中，相关的进度都在这个 issue 里面（<a href="https://github.com/vueComponent/ant-design-vue/issues/1913">Vue 3 支持</a>），有兴趣的同学可以关注下，提一些 PR 过去。</p><p>对于 props 的迁移工作比较简单，只需要把原有分散在 <code>props、on、attrs</code> 中的值直接铺开即可。</p><pre><code class="js"> const vcUploadProps = &#123;-  props: &#123;-    ...this.$props,-   prefixCls,-    beforeUpload: this.reBeforeUpload,-  &#125;,-  on: &#123;-    start: this.onStart,-    error: this.onError,-    progress: this.onProgress,-    success: this.onSuccess,-    reject: this.onReject,- &#125;,+  ...this.$props,+  prefixCls,+  beforeUpload: this.reBeforeUpload,+  onStart: this.onStart,+  onError: this.onError,+  onProgress: this.onProgress,+  onSuccess: this.onSuccess,+  onReject: this.onReject,+  ref: &#39;uploadRef&#39;,+  attrs: this.$attrs,+  ...this.$attrs,&#125;;</code></pre><p>但是关于 <code>inheritAttrs</code> 有个较为底层的变动，需要开发者根据实际情况去修改。<a href="https://cn.vuejs.org/v2/api/index.html#inheritAttrs">什么是inheritAttrs?</a> 在 Vue 2 中，这个选项不影响 class 和 style 绑定，但是在 Vue 3 中会影响到。因此可能在属性的传递上，需要额外对这两个参数做处理。</p><p>在事件的处理上，我们建议在 props 中声明，这样对后续的开发更加易维护，可以很直观地从 props 看出我这个组件到底会传递哪些事件。值得一提的是，在 props 中声明的事件，也可以通过 emit 来触发。例如声明了 onClick 事件，仍然可以使用 emit(‘click’)。</p><p>Vue 3 对 context 的 API 也做了改动，一般如果不是复杂的组件，不会涉及到这个 API。这部分的改动可以看原先 <code>Vue Compositon API</code> 的相关文档，<a href="https://composition-api.vuejs.org/api.html#dependency-injection">Dependency Injection</a>，注意一点，在 setup 中取不到 this。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5f01d7886fb9a07e6835601a?utm_source=gold_browser_extension#heading-6&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在过去的一年中，Vue 团队一直都在开</summary>
      
    
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>svg科普篇-向强大的svg迈进</title>
    <link href="https://shinichikudo-fe.github.io/2020/07/01/Tools/svg%E7%A7%91%E6%99%AE%E7%AF%87-%E5%90%91%E5%BC%BA%E5%A4%A7%E7%9A%84svg%E8%BF%88%E8%BF%9B/"/>
    <id>https://shinichikudo-fe.github.io/2020/07/01/Tools/svg%E7%A7%91%E6%99%AE%E7%AF%87-%E5%90%91%E5%BC%BA%E5%A4%A7%E7%9A%84svg%E8%BF%88%E8%BF%9B/</id>
    <published>2020-07-01T01:29:27.000Z</published>
    <updated>2020-09-04T02:18:38.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在掘金上突然看到京东凹凸实验室发布的一篇<a href="https://juejin.im/post/5ef1a698f265da02ce2181d0?utm_source=gold_browser_extension">《向强大的svg迈进》</a>，想到前几个月项目老大非得让我从svg图标换成iconfont字体图标，最后在我耐心给老大讲了svg的未来，对比了iconfont与普通png的区别后，老大妥协了，让我说服其他成员，代码保持一致就行，:( ，没办法，又得给其他同事讲下。所以今天为了科普svg，写来这篇</p><blockquote><p>SVG 即 <code>Scalable Vector Graphics</code> 可缩放矢量图形，使用XML格式定义图形。<br><a href="https://juejin.im/post/5ef1a698f265da02ce2181d0?utm_source=gold_browser_extension">原文地址</a></p></blockquote><h2 id="SVG印象"><a href="#SVG印象" class="headerlink" title="SVG印象"></a>SVG印象</h2><p>SVG 的应用十分广泛，得益于 SVG 强大的各种特性。</p><h3 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h3><p>可利用 SVG 矢量的特点，描出深圳地铁的轮廓：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff28ae2bb2f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="metro"></p><h3 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h3><p>SVG 可依据一定的规则，转成 iconfont 使用：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff28e7152486?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="iconfont"></p><h3 id="foreignObject"><a href="#foreignObject" class="headerlink" title="foreignObject"></a>foreignObject</h3><p>利用 SVG 的 <code>foreignObject</code> 标签实现截图功能，原理：<code>foreignObject</code> 内部嵌入 HTML 元素：</p><pre><code class="js">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;    &lt;foreignObject width=&quot;120&quot; height=&quot;60&quot;&gt;        &lt;p style=&quot;font-size:20px;margin:0;&quot;&gt;凹凸实验室 欢迎您&lt;/p&gt;    &lt;/foreignObject&gt;&lt;/svg&gt;</code></pre><p>截图实现流程：</p><p>1.首先声明一个基础的 svg 模版，这个模版需要一些基础的描述信息，最重要的，它要有 <code>&lt;foreignObject&gt;&lt;/foreignObject&gt;</code> 这对标签；<br>2.将要渲染的 DOM 模版模版嵌入 <code>foreignObject</code> 即可；<br>3.利用 Blob 构建 svg 对象；<br>4.利用 <code>URL.createObjectURL(svg)</code> 取出 URL。</p><h3 id="SVG-SMIL"><a href="#SVG-SMIL" class="headerlink" title="SVG SMIL"></a>SVG SMIL</h3><p>由于微信编辑器不允许嵌入 <code>&lt;style&gt;&lt;script&gt;&lt;a&gt;</code> 标签，利用SVG SMIL 可进行微信公众号极具创意的图文排版设计，包括动画与交互。<br>但是也要注意，标签里不允许有id，否则会被过滤或替换掉。</p><p>点击 “凹凸实验室” 后，围绕 “凹凸实验室” 中心旋转 360度，点击0.5秒后 出现 <a href="https://aotu.io/">aotu.io/</a> ，动画只运行一次。</p><p>下图为 GIF循环演示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2914fb651d?imageslim" alt="demo"></p><p>代码如下：</p><pre><code class="js">&lt;svg width=&quot;360&quot; height=&quot;300&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;    &lt;g&gt;        &lt;!-- 点击后 运行transform旋转动画，restart=&quot;never&quot;表示只运行一次 --&gt;        &lt;animateTransform attributeName=&quot;transform&quot; type=&quot;rotate&quot; begin=&quot;click&quot; dur=&quot;0.5s&quot; from=&quot;0 100 80&quot; to=&quot;360 100 80&quot;  fill=&quot;freeze&quot; restart=&quot;never&quot; /&gt;        &lt;g&gt;            &lt;text font-family=&quot;microsoft yahei&quot; font-size=&quot;20&quot; x=&quot;50&quot; y=&quot;80&quot;&gt;                凹凸实验室            &lt;/text&gt;        &lt;/g&gt;        &lt;g style=&quot;opacity: 0;&quot;&gt;            &lt;!-- 同一个初始位置以及大致的宽高，触发点击事件 --&gt;            &lt;text font-family=&quot;microsoft yahei&quot; font-size=&quot;20&quot; x=&quot;50&quot; y=&quot;80&quot;&gt;https://aotu.io/&lt;/text&gt;            &lt;!-- 点击后 运行transform移动动画，改变文本的位置 --&gt;            &lt;animateTransform attributeName=&quot;transform&quot; type=&quot;translate&quot; begin=&quot;click&quot; dur=&quot;0.1s&quot; to=&quot;0 40&quot;  fill=&quot;freeze&quot; restart=&quot;never&quot; /&gt;            &lt;!-- 点击0.5秒后 运行opacity显示动画 --&gt;            &lt;animate attributeName=&quot;opacity&quot; begin=&quot;click+0.5s&quot; from=&quot;0&quot; to=&quot;1&quot; dur=&quot;0.5s&quot; fill=&quot;freeze&quot; restart=&quot;never&quot; /&gt;        &lt;/g&gt;    &lt;/g&gt;&lt;/svg&gt;</code></pre><h2 id="SVG-实现非比例缩放"><a href="#SVG-实现非比例缩放" class="headerlink" title="SVG 实现非比例缩放"></a>SVG 实现非比例缩放</h2><p>我们熟知的 <code>iconfont</code>，可通过改变字体大小缩放，但是这是 <strong>比例缩放</strong>，那如何实现 SVG 的<strong>非比例缩放</strong>呢？ 如下图所示，<code>如何将 一只兔子 非比例缩放？</code></p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2972d16d14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>划重点：<strong>实现非比例缩放主要涉及三个知识点：<code>viewport、viewBox和preserveAspectRatio</code>，<code>viewport 与viewBox</code> 结合可实现缩放的功能，<code>viewBox 与 preserveAspectRatio</code> 结合可实现非比例的功能</strong>。</p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p><code>viewport</code> 表示SVG可见区域的大小。 <code>viewport</code> 就像是我们的显示器屏幕大小，超出区域则隐藏，原点位于左上角，x 轴水平向右，y 轴垂直向下。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff29abb23727?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>通过类似CSS的属性 <code>width、height</code> 指定视图大小：</p><pre><code class="js">&lt;svg width=&quot;400&quot; height=&quot;200&quot;&gt;&lt;/svg&gt;</code></pre><h3 id="viewBox"><a href="#viewBox" class="headerlink" title="viewBox"></a>viewBox</h3><p>viewBox值有4个数字：<code>x, y, width, height</code> 。 其中 x：左上角横坐标，y：左上角纵坐标，width：宽度，height：高度。<br>原点默认位于左上角，x 轴水平向右，y 轴垂直向下。</p><pre><code class="js">&lt;svg width=&quot;400&quot; height=&quot;200&quot; viewBox=&quot;0 0 200 100&quot;&gt;&lt;/svg&gt;</code></pre><p>显示器屏幕的画面，可以特写，可以全景，这就是 <code>viewBox</code>。 <code>viewBox</code> 可以想象成截屏工具选中的那个框框，和 <code>viewport</code> 作用的结果就是 把框框中的截屏内容再次在 显示器 中全屏显示。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff29e1dee892?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h3 id="preserveAspectRatio"><a href="#preserveAspectRatio" class="headerlink" title="preserveAspectRatio"></a>preserveAspectRatio</h3><p>上图的红色框框和蓝色框框，恰好和显示器的比例相同，如果是下图的绿色框框，怎样在显示器屏幕中显示呢?</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2a1f0c94f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>preserveAspectRatio</code> 作用的对象是 <code>viewBox</code>，使用方法如下：</p><pre><code class="js">preserveAspectRatio=&quot;[defer] &lt;align&gt; [&lt;meetOrSlice&gt;]&quot;// 例如 preserveAspectRatio=&quot;xMidYMid meet&quot;</code></pre><p>其中 <code>defer</code> 此时不是重点，暂且忽略，主要了解 <code>align</code> 和 <code>meetOrSlice</code> 的 用法：</p><p><code>align</code>：由两个名词组成，分别代表 <code>viewbox 与 viewport 的 x 方向、y方向</code>的对齐方式。</p><blockquote><p><code>meetOrSlice</code>：表示如何维持高宽的比例，有三个值 <code>meet</code>、<code>slice</code>、<code>none</code>。<br><code>meet</code> - 默认值，保持纵横比缩放 viewBox 适应 viewport，可能会有余留的空白。<br><code>slice</code> - 保持纵横比同时比例小的方向放大填满 viewport，超出的部分被剪裁掉。<br><code>none</code> - 扭曲纵横比以充分适应 viewport。</p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例子1：<code>preserveAspectRatio=&quot;xMidYMid meet&quot;</code> 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐；</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2a71a181c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>例子2：<code>preserveAspectRatio=&quot;xMidYMin slice&quot;</code> 表示 绿色框框 与 显示器的 x 方向 中心点 对齐，Y 方向 上边缘对齐，保持比例放大填满 显示屏 后超出部分隐藏；</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2aa4bade91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>例子3：preserveAspectRatio=”xMidYMid slice” 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐，保持比例放大填满显示屏 后超出部分隐藏；</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2adcb56f90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>例子4：preserveAspectRatio=”none” 不管三七二十一，随意缩放绿色框框，填满 显示屏即可；这就是非比例缩放的答案了。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2b10f609f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h2 id="SVG-vs-Image-SVG-vs-Iconfont"><a href="#SVG-vs-Image-SVG-vs-Iconfont" class="headerlink" title="SVG vs Image, SVG vs Iconfont"></a>SVG vs Image, SVG vs Iconfont</h2><p>SVG vs Image, SVG vs Iconfont 对比文章地址 <a href="https://blog.csdn.net/cpongo3/article/details/90258990?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.nonecase">原文地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天在掘金上突然看到京东凹凸实验室发布的一篇&lt;a href=&quot;https://juejin.im/post/5ef1a698f265da02</summary>
      
    
    
    
    <category term="Tools" scheme="https://shinichikudo-fe.github.io/categories/Tools/"/>
    
    
    <category term="Svg" scheme="https://shinichikudo-fe.github.io/tags/Svg/"/>
    
  </entry>
  
  <entry>
    <title>实战技巧，Vue原来还可以这样写</title>
    <link href="https://shinichikudo-fe.github.io/2020/06/24/Vue/%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7%EF%BC%8CVue%E5%8E%9F%E6%9D%A5%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%86%99/"/>
    <id>https://shinichikudo-fe.github.io/2020/06/24/Vue/%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7%EF%BC%8CVue%E5%8E%9F%E6%9D%A5%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%86%99/</id>
    <published>2020-06-24T05:09:18.000Z</published>
    <updated>2020-09-04T02:18:38.446Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5eef7799f265da02cd3b82fe?utm_source=gold_browser_extension">原文地址</a></p><h2 id="hookEvent-原来可以这样监听组件生命周期"><a href="#hookEvent-原来可以这样监听组件生命周期" class="headerlink" title="hookEvent,原来可以这样监听组件生命周期"></a>hookEvent,原来可以这样监听组件生命周期</h2><h3 id="1-内部监听生命周期函数"><a href="#1-内部监听生命周期函数" class="headerlink" title="1. 内部监听生命周期函数"></a>1. 内部监听生命周期函数</h3><p>今天产品经理又给我甩过来一个需求，需要开发一个图表，拿到需求，瞄了一眼，然后我就去echarts官网复制示例代码了，复制完改了改差不多了，改完代码长这样</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;echarts&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  mounted() &#123;    this.chart = echarts.init(this.$el)    // 请求数据，赋值数据 等等一系列操作...    // 监听窗口发生变化，resize组件    window.addEventListener(&#39;resize&#39;, this.$_handleResizeChart)  &#125;,  updated() &#123;    // 干了一堆活  &#125;,  created() &#123;    // 干了一堆活  &#125;,  beforeDestroy() &#123;    // 组件销毁时，销毁监听事件    window.removeEventListener(&#39;resize&#39;, this.$_handleResizeChart)  &#125;,  methods: &#123;    $_handleResizeChart() &#123;      this.chart.resize()    &#125;,    // 其他一堆方法  &#125;&#125;&lt;/script&gt;</code></pre><p>功能写完开开心心的提测了，测试没啥问题，产品经理表示做的很棒。然而<code>code review</code>时候，技术大佬说了，这样有问题。</p><ul><li>大佬：这样写不是很好，应该将监听<code>resize</code>事件与销毁<code>resize</code>事件放到一起，现在两段代码分开而且相隔几百行代码，可读性比较差</li><li>我：那我把两个生命周期钩子函数位置换一下，放到一起?</li><li>大佬： <code>hook</code>听过没？</li><li>我：<code>Vue3.0</code>才有啊，咋，咱要升级<code>Vue</code>?</li></ul><p>然后技术大佬就不理我了,并向我扔过来一段代码</p><pre><code class="js">export default &#123;  mounted() &#123;    this.chart = echarts.init(this.$el)    // 请求数据，赋值数据 等等一系列操作...    // 监听窗口发生变化，resize组件    window.addEventListener(&#39;resize&#39;, this.$_handleResizeChart)    // 通过hook监听组件销毁钩子函数，并取消监听事件    this.$once(&#39;hook:beforeDestroy&#39;, () =&gt; &#123;      window.removeEventListener(&#39;resize&#39;, this.$_handleResizeChart)    &#125;)  &#125;,  updated() &#123;&#125;,  created() &#123;&#125;,  methods: &#123;    $_handleResizeChart() &#123;      // this.chart.resize()    &#125;  &#125;&#125;</code></pre><p>看完代码，恍然大悟，大佬不愧是大佬，原来<code>Vue</code>还可以这样监听生命周期函数。</p><blockquote><p>在Vue组件中，可以用过<code>$on,$once</code>去监听所有的生命周期钩子函数，如监听组件的<code>updated</code>钩子函数可以写成 <code>this.$on(&#39;hook:updated&#39;, () =&gt; &#123;&#125;)</code></p></blockquote><h3 id="2-外部监听生命周期函数"><a href="#2-外部监听生命周期函数" class="headerlink" title="2. 外部监听生命周期函数"></a>2. 外部监听生命周期函数</h3><p>今天同事在公司群里问，想在外部监听组件的生命周期函数，有没有办法啊？</p><p>为什么会有这样的需求呢，原来同事用了一个第三方组件，需要监听第三方组件数据的变化，但是组件又没有提供<code>change</code>事件，同事也没办法了，才想出来要去在外部监听组件的<code>updated</code>钩子函数。查看了一番资料，发现<code>Vue支持在外部监听组件的生命周期钩子函数</code>。</p><pre><code class="html">&lt;template&gt;  &lt;!--通过@hook:updated监听组件的updated生命钩子函数--&gt;  &lt;!--组件的所有生命周期钩子都可以通过@hook:钩子函数名 来监听触发--&gt;  &lt;custom-select @hook:updated=&quot;$_handleSelectUpdated&quot; /&gt;&lt;/template&gt;&lt;script&gt;import CustomSelect from &#39;../components/custom-select&#39;export default &#123;  components: &#123;    CustomSelect  &#125;,  methods: &#123;    $_handleSelectUpdated() &#123;      console.log(&#39;custom-select组件的updated钩子函数被触发&#39;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="小项目还用Vuex-用Vue-observable手写一个状态管理吧"><a href="#小项目还用Vuex-用Vue-observable手写一个状态管理吧" class="headerlink" title="小项目还用Vuex?用Vue.observable手写一个状态管理吧"></a>小项目还用Vuex?用Vue.observable手写一个状态管理吧</h2><p>在前端项目中，有许多数据需要在各个组件之间进行传递共享，这时候就需要有一个状态管理工具，一般情况下，我们都会使用<code>Vuex</code>，但对于小型项目来说，就像<code>Vuex</code>官网所说：“如果您不打算开发大型单页应用，使用 <code>Vuex</code> 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 <code>Vuex</code>”。这时候我们就可以使用Vue2.6提供的新API <code>Vue.observable</code>手动打造一个<code>Vuex</code></p><h3 id="创建-store"><a href="#创建-store" class="headerlink" title="创建 store"></a>创建 store</h3><pre><code class="js">import Vue from &#39;vue&#39;// 通过Vue.observable创建一个可响应的对象export const store = Vue.observable(&#123;  userInfo: &#123;&#125;,  roleIds: []&#125;)// 定义 mutations, 修改属性export const mutations = &#123;  setUserInfo(userInfo) &#123;    store.userInfo = userInfo  &#125;,  setRoleIds(roleIds) &#123;    store.roleIds = roleIds  &#125;&#125;</code></pre><h3 id="在组件中引用"><a href="#在组件中引用" class="headerlink" title="在组件中引用"></a>在组件中引用</h3><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; userInfo.name &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; store, mutations &#125; from &#39;../store&#39;export default &#123;  computed: &#123;    userInfo() &#123;      return store.userInfo    &#125;  &#125;,  created() &#123;    mutations.setUserInfo(&#123;      name: &#39;白告&#39;    &#125;)  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="开发全局组件，你可能需要了解一下Vue-extend"><a href="#开发全局组件，你可能需要了解一下Vue-extend" class="headerlink" title="开发全局组件，你可能需要了解一下Vue.extend"></a>开发全局组件，你可能需要了解一下Vue.extend</h2><p><code>Vue.extend</code>是一个全局Api,平时我们在开发业务的时候很少会用到它，但有时候我们希望可以开发一些全局组件比如Loading,Notify,Message等组件时，这时候就可以使用<code>Vue.extend</code>。</p><p>同学们在使用<code>element-ui</code>的<code>loading</code>时，在代码中可能会这样写</p><pre><code class="js">// 显示loadingconst loading = this.$loading()// 关闭loadingloading.close()</code></pre><p>这样写可能没什么特别的，但是如果你这样写</p><pre><code class="js">const loading = this.$loading()const loading1 = this.$loading()setTimeout(() =&gt; &#123;  loading.close()&#125;, 1000 * 3)</code></pre><p>这时候你会发现，我调用了两次loading,但是只出现了一个，而且我只关闭了loading，但是loading1也被关闭了。这是怎么实现的呢？我们现在就是用Vue.extend + 单例模式去实现一个loading</p><h3 id="开发loading组件"><a href="#开发loading组件" class="headerlink" title="开发loading组件"></a>开发loading组件</h3><pre><code class="html">&lt;template&gt;  &lt;transition name=&quot;custom-loading-fade&quot;&gt;    &lt;!--loading蒙版--&gt;    &lt;div v-show=&quot;visible&quot; class=&quot;custom-loading-mask&quot;&gt;      &lt;!--loading中间的图标--&gt;      &lt;div class=&quot;custom-loading-spinner&quot;&gt;        &lt;i class=&quot;custom-spinner-icon&quot;&gt;&lt;/i&gt;        &lt;!--loading上面显示的文字--&gt;        &lt;p class=&quot;custom-loading-text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;  // 是否显示loading    visible: &#123;      type: Boolean,      default: false    &#125;,    // loading上面的显示文字    text: &#123;      type: String,      default: &#39;&#39;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="通过Vue-extend将组件转换为全局组件"><a href="#通过Vue-extend将组件转换为全局组件" class="headerlink" title="通过Vue.extend将组件转换为全局组件"></a>通过Vue.extend将组件转换为全局组件</h3><h4 id="改造loading组件，将组件的props改为data"><a href="#改造loading组件，将组件的props改为data" class="headerlink" title="改造loading组件，将组件的props改为data"></a>改造loading组件，将组件的props改为data</h4><pre><code class="js">export default &#123;  data() &#123;    return &#123;      text: &#39;&#39;,      visible: false    &#125;  &#125;&#125;</code></pre><h4 id="通过Vue-extend改造组件"><a href="#通过Vue-extend改造组件" class="headerlink" title="通过Vue.extend改造组件"></a>通过Vue.extend改造组件</h4><pre><code class="js">// loading/index.jsimport Vue from &#39;vue&#39;import LoadingComponent from &#39;./loading.vue&#39;// 通过Vue.extend将组件包装成一个子类const LoadingConstructor = Vue.extend(LoadingComponent)let loading = undefinedLoadingConstructor.prototype.close = function() &#123;  // 如果loading 有引用，则去掉引用  if (loading) &#123;    loading = undefined  &#125;  // 先将组件隐藏  this.visible = false  // 延迟300毫秒，等待loading关闭动画执行完之后销毁组件  setTimeout(() =&gt; &#123;    // 移除挂载的dom元素    if (this.$el &amp;&amp; this.$el.parentNode) &#123;      this.$el.parentNode.removeChild(this.$el)    &#125;    // 调用组件的$destroy方法进行组件销毁    this.$destroy()  &#125;, 300)&#125;const Loading = (options = &#123;&#125;) =&gt; &#123;  // 如果组件已渲染，则返回即可  if (loading) &#123;    return loading  &#125;  // 要挂载的元素  const parent = document.body  // 组件属性  const opts = &#123;    text: &#39;&#39;,    ...options  &#125;  // 通过构造函数初始化组件 相当于 new Vue()  const instance = new LoadingConstructor(&#123;    el: document.createElement(&#39;div&#39;),    data: opts  &#125;)  // 将loading元素挂在到parent上面  parent.appendChild(instance.$el)  // 显示loading  Vue.nextTick(() =&gt; &#123;    instance.visible = true  &#125;)  // 将组件实例赋值给loading  loading = instance  return instance&#125;export default Loading</code></pre><h4 id="在页面使用loading"><a href="#在页面使用loading" class="headerlink" title="在页面使用loading"></a>在页面使用loading</h4><pre><code class="js">import Loading from &#39;./loading/index.js&#39;export default &#123;  created() &#123;    const loading = Loading(&#123; text: &#39;正在加载。。。&#39; &#125;)    // 三秒钟后关闭    setTimeout(() =&gt; &#123;      loading.close()    &#125;, 3000)  &#125;&#125;</code></pre><p>通过上面的改造，<code>loading</code>已经可以在全局使用了，如果需要像<code>element-ui</code>一样挂载到<code>Vue.prototype</code>上面，通过<code>this.$loading</code>调用，还需要改造一下</p><h3 id="将组件挂载到Vue-prototype上面"><a href="#将组件挂载到Vue-prototype上面" class="headerlink" title="将组件挂载到Vue.prototype上面"></a>将组件挂载到Vue.prototype上面</h3><pre><code class="js">Vue.prototype.$loading = Loading// 在export之前将Loading方法进行绑定export default Loading// 在组件内使用this.$loading()</code></pre><h2 id="自定义指令，从底层解决问题"><a href="#自定义指令，从底层解决问题" class="headerlink" title="自定义指令，从底层解决问题"></a>自定义指令，从底层解决问题</h2><p>通过上一节我们开发了一个<code>loading</code>组件，开发完之后，其他开发在使用的时候又提出来了两个需求</p><p>1.可以将<code>loading</code>挂载到某一个元素上面，现在只能是全屏使用<br>2.可以使用指令在指定的元素上面挂载<code>loading</code></p><h3 id="开发v-loading指令"><a href="#开发v-loading指令" class="headerlink" title="开发v-loading指令"></a>开发v-loading指令</h3><pre><code class="js">import Vue from &#39;vue&#39;import LoadingComponent from &#39;./loading&#39;// 使用 Vue.extend构造组件子类const LoadingContructor = Vue.extend(LoadingComponent)// 定义一个名为loading的指令Vue.directive(&#39;loading&#39;, &#123;  /**   * 只调用一次，在指令第一次绑定到元素时调用，可以在这里做一些初始化的设置   * @param &#123;*&#125; el 指令要绑定的元素   * @param &#123;*&#125; binding 指令传入的信息，包括 &#123;name:&#39;指令名称&#39;, value: &#39;指令绑定的值&#39;,arg: &#39;指令参数 v-bind:text 对应 text&#39;&#125;   */  bind(el, binding) &#123;    const instance = new LoadingContructor(&#123;      el: document.createElement(&#39;div&#39;),      data: &#123;&#125;    &#125;)    el.appendChild(instance.$el)    el.instance = instance    Vue.nextTick(() =&gt; &#123;      el.instance.visible = binding.value    &#125;)  &#125;,  /**   * 所在组件的 VNode 更新时调用   * @param &#123;*&#125; el   * @param &#123;*&#125; binding   */  update(el, binding) &#123;    // 通过对比值的变化判断loading是否显示    if (binding.oldValue !== binding.value) &#123;      el.instance.visible = binding.value    &#125;  &#125;,  /**   * 只调用一次，在 指令与元素解绑时调用   * @param &#123;*&#125; el   */  unbind(el) &#123;    const mask = el.instance.$el    if (mask.parentNode) &#123;      mask.parentNode.removeChild(mask)    &#125;    el.instance.$destroy()    el.instance = undefined  &#125;&#125;)</code></pre><h3 id="在元素上面使用指令"><a href="#在元素上面使用指令" class="headerlink" title="在元素上面使用指令"></a>在元素上面使用指令</h3><pre><code class="html">&lt;template&gt;  &lt;div v-loading=&quot;visible&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      visible: false    &#125;  &#125;,  created() &#123;    this.visible = true    fetch().then(() =&gt; &#123;      this.visible = false    &#125;)  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="项目中哪些场景可以自定义指令"><a href="#项目中哪些场景可以自定义指令" class="headerlink" title="项目中哪些场景可以自定义指令"></a>项目中哪些场景可以自定义指令</h3><p>1.为组件添加<code>loading</code>效果<br>2.按钮级别权限控制 <code>v-permission</code><br>3.代码埋点,根据操作类型定义指令<br>4.input输入框自动获取焦点<br>5.其他等等。。。</p><h2 id="深度watch与watch立即触发回调-我可以监听到你的一举一动"><a href="#深度watch与watch立即触发回调-我可以监听到你的一举一动" class="headerlink" title="深度watch与watch立即触发回调,我可以监听到你的一举一动"></a>深度watch与watch立即触发回调,我可以监听到你的一举一动</h2><p>在开发Vue项目时，我们会经常性的使用到watch去监听数据的变化，然后在变化之后做一系列操作。</p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>比如一个列表页，我们希望用户在搜索框输入搜索关键字的时候，可以自动触发搜索,此时除了监听搜索框的<code>change</code>事件之外，我们也可以通过<code>watch</code>监听搜索关键字的变化</p><pre><code class="html">&lt;template&gt;  &lt;!--此处示例使用了element-ui--&gt;  &lt;div&gt;    &lt;div&gt;      &lt;span&gt;搜索&lt;/span&gt;      &lt;input v-model=&quot;searchValue&quot; /&gt;    &lt;/div&gt;    &lt;!--列表，代码省略--&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      searchValue: &#39;&#39;    &#125;  &#125;,  watch: &#123;    // 在值发生变化之后，重新加载数据    searchValue(newValue, oldValue) &#123;      // 判断搜索      if (newValue !== oldValue) &#123;        this.$_loadData()      &#125;    &#125;  &#125;,  methods: &#123;    $_loadData() &#123;      // 重新加载数据，此处需要通过函数防抖    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="立即触发"><a href="#立即触发" class="headerlink" title="立即触发"></a>立即触发</h3><p>通过上面的代码，现在已经可以在值发生变化的时候触发加载数据了，但是如果要在页面初始化时候加载数据，我们还需要在<code>created</code>或者<code>mounted</code>生命周期钩子里面再次调用<code>$_loadData</code>方法。不过，现在可以不用这样写了，通过配置<code>watch</code>的立即触发属性，就可以满足需求了</p><pre><code class="js">// 改造watchexport default &#123;  watch: &#123;    // 在值发生变化之后，重新加载数据    searchValue: &#123;    // 通过handler来监听属性变化, 初次调用 newValue为&quot;&quot;空字符串， oldValue为 undefined      handler(newValue, oldValue) &#123;        if (newValue !== oldValue) &#123;          this.$_loadData()        &#125;      &#125;,      // 配置立即执行属性      immediate: true    &#125;  &#125;&#125;</code></pre><h3 id="深度监听（我可以看到你内心的一举一动）"><a href="#深度监听（我可以看到你内心的一举一动）" class="headerlink" title="深度监听（我可以看到你内心的一举一动）"></a>深度监听（我可以看到你内心的一举一动）</h3><p>一个表单页面，需求希望用户在修改表单的任意一项之后，表单页面就需要变更为被修改状态。如果按照上例中watch的写法，那么我们就需要去监听表单每一个属性，太麻烦了，这时候就需要用到<code>watch</code>的深度监听<code>deep</code></p><pre><code class="js">export default &#123;  data() &#123;    return &#123;      formData: &#123;        name: &#39;&#39;,        sex: &#39;&#39;,        age: 0,        deptId: &#39;&#39;      &#125;    &#125;  &#125;,  watch: &#123;    // 在值发生变化之后，重新加载数据    formData: &#123;      // 需要注意，因为对象引用的原因， newValue和oldValue的值一直相等      handler(newValue, oldValue) &#123;        // 在这里标记页面编辑状态      &#125;,      // 通过指定deep属性为true, watch会监听对象里面每一个值的变化      deep: true    &#125;  &#125;&#125;</code></pre><h2 id="函数式组件，函数是组件？"><a href="#函数式组件，函数是组件？" class="headerlink" title="函数式组件，函数是组件？"></a>函数式组件，函数是组件？</h2><p>什么是函数式组件？函数式组件就是函数是组件，感觉在玩文字游戏。使用过React的同学，应该不会对函数式组件感到陌生。函数式组件，我们可以理解为没有内部状态，没有生命周期钩子函数，没有this(不需要实例化的组件)。</p><p>在日常写bug的过程中，经常会开发一些纯展示性的业务组件，比如一些详情页面，列表界面等，它们有一个共同的特点是只需要将外部传入的数据进行展现，不需要有内部状态，不需要在生命周期钩子函数里面做处理，这时候你就可以考虑使用函数式组件。</p><h3 id="先来一个函数式组件的代码"><a href="#先来一个函数式组件的代码" class="headerlink" title="先来一个函数式组件的代码"></a>先来一个函数式组件的代码</h3><pre><code class="js">export default &#123;  // 通过配置functional属性指定组件为函数式组件  functional: true,  // 组件接收的外部属性  props: &#123;    avatar: &#123;      type: String    &#125;  &#125;,  /**   * 渲染函数   * @param &#123;*&#125; h   * @param &#123;*&#125; context 函数式组件没有this, props, slots等都在context上面挂着   */  render(h, context) &#123;    const &#123; props &#125; = context    if (props.avatar) &#123;      return &lt;img src=&#123;props.avatar&#125;&gt;&lt;/img&gt;    &#125;    return &lt;img src=&quot;default-avatar.png&quot;&gt;&lt;/img&gt;  &#125;&#125;</code></pre><p>在上例中，我们定义了一个头像组件，如果外部传入头像，则显示传入的头像，否则显示默认头像。上面的代码中大家看到有一个<code>render</code>函数，这个是Vue使用<code>JSX</code>的写法，关于<code>JSX</code>,小编将在后续文章中会出详细的使用教程。</p><h3 id="为什么使用函数式组件"><a href="#为什么使用函数式组件" class="headerlink" title="为什么使用函数式组件"></a>为什么使用函数式组件</h3><p>1.最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件<br>2.函数式组件结构比较简单，代码结构更清晰</p><h3 id="函数式组件与普通组件的区别"><a href="#函数式组件与普通组件的区别" class="headerlink" title="函数式组件与普通组件的区别"></a>函数式组件与普通组件的区别</h3><p>1.函数式组件需要在声明组件是指定functional<br>2.函数式组件不需要实例化，所以没有this,this通过render函数的第二个参数来代替<br>3.函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等<br>4.函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件<br>5.因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement<br>6.函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)</p><h3 id="我不想用JSX，能用函数式组件吗？"><a href="#我不想用JSX，能用函数式组件吗？" class="headerlink" title="我不想用JSX，能用函数式组件吗？"></a>我不想用JSX，能用函数式组件吗？</h3><p>在<code>Vue2.5</code>之前，使用函数式组件只能通过<code>JSX</code>的方式，在之后，可以通过模板语法来生命函数式组件</p><pre><code class="html">&lt;!--在template 上面添加 functional属性--&gt;&lt;template functional&gt;  &lt;img :src=&quot;props.avatar ? props.avatar : &#39;default-avatar.png&#39;&quot; /&gt;&lt;/template&gt;&lt;!--根据上一节第六条，可以省略声明props--&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5eef7799f265da02cd3b82fe?utm_source=gold_browser_extension&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;hookEvent-原来可以这样监听组件生命周期</summary>
      
    
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/tags/Vue/"/>
    
  </entry>
  
</feed>
