<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>默默默默燃</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="https://shinichikudo-fe.github.io/atom.xml" rel="self"/>
  
  <link href="https://shinichikudo-fe.github.io/"/>
  <updated>2020-09-27T08:37:14.110Z</updated>
  <id>https://shinichikudo-fe.github.io/</id>
  
  <author>
    <name>张白告丶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习Javascript应懂得33个概念之消息队列与事件循环</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-09-25T08:11:23.000Z</published>
    <updated>2020-09-27T08:37:14.110Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html">原文地址</a></p><h2 id="区分进程与线程"><a href="#区分进程与线程" class="headerlink" title="区分进程与线程"></a>区分进程与线程</h2><p>线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：</p><pre><code class="html">- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）- 工厂之间的相互独立 -&gt; 进程之间相互独立- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</code></pre><p>然后再巩固下：</p><p>如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。</p><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/process_list.png" alt="cpu"></p><p>所以，应该更容易理解了：<strong>进程是cpu资源分配的最小单位（系统会给它分配内存）</strong></p><blockquote><p>最后，再用较为官方的术语描述一遍：</p></blockquote><ul><li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li><li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li></ul><p><strong>tips</strong></p><ul><li>不同进程之间也可以通信，不过代价较大</li><li>现在，一般通用的叫法：<strong>单线程与多线程，都是指在一个进程内的单和多</strong>。（所以核心还是得属于一个进程才行）</li></ul><h2 id="浏览器是属于多进程的"><a href="#浏览器是属于多进程的" class="headerlink" title="浏览器是属于多进程的"></a>浏览器是属于多进程的</h2><blockquote><p>理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</p></blockquote><ul><li>浏览器是多进程的</li><li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li><li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。</li></ul><p><strong>注意</strong>：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了<br>（所以每一个Tab标签对应一个进程并不一定是绝对的）</p><h3 id="浏览器包含哪些进程"><a href="#浏览器包含哪些进程" class="headerlink" title="浏览器包含哪些进程"></a>浏览器包含哪些进程</h3><blockquote><p>知道了浏览器是多进程后，再来看看它<em>到底包含哪些进程</em>：（为了简化理解，仅列举主要进程）</p></blockquote><ul><li><strong>Browser进程</strong>：浏览器的主进程（负责协调、主控），<blockquote><p>只有一个。作用有</p></blockquote></li></ul><p>1.负责浏览器界面显示，与用户交互。如前进，后退等<br>2.负责各个页面的管理，创建和销毁其他进程<br>3.将Renderer进程得到的内存中的Bitmap，绘制到用户界面上<br>4.网络资源的管理，下载等</p><ul><li><strong>第三方插件进程</strong>：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li><strong>GPU进程</strong>：最多一个，用于3D绘制等</li><li><strong>浏览器渲染进程（浏览器内核）</strong>（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为</li><li><strong>页面渲染</strong>，脚本执行，事件处理等</li></ul><p>强化记忆：<strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</strong></p><p>当然，浏览器有时<strong>会将多个进程合并</strong>（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程</p><p>另外，可以通过Chrome的<code>更多工具 -&gt; 任务管理器</code>自行验证</p><h3 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h3><blockquote><p>相比于单进程浏览器，多进程有如下优点：</p></blockquote><ul><li>避免单个page crash影响整个浏览器</li><li>避免第三方插件crash影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性<br>简单点理解：<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势</strong></li></ul><p>当然，内存等资源消耗也会更大，有点空间换时间的意思。</p><h3 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）</h3><p>重点来了，我们可以看到，上面提到了这么多的进程，那么，<strong>对于普通的前端操作来说，最终要的是什么呢？答案是渲染进程</strong></p><p>可以这样理解，<code>页面的渲染，JS的执行，事件的循环</code>，都在这个进程内进行。接下来重点分析这个进程</p><p>请牢记，<strong>浏览器的渲染进程是多线程的</strong>（这点如果不理解，请回头看进程和线程的区分）</p><p>看看它都包含了哪些线程（列举一些主要常驻线程）：</p><h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h4><p>负责渲染浏览器界面，解析<code>HTML</code>，<code>CSS</code>，构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。<br>当界面需要<code>重绘（Repaint）</code>或由于某种操作引发<code>回流(reflow)</code>时，该线程就会执行<br>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p><h4 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h4><p>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）<br>JS引擎线程负责解析Javascript脚本，运行代码。<br>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序<br>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p><em>归属于浏览器而不是JS引擎，用来控制事件循环</em>（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）<br>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中<br>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p><p><strong>注意</strong>，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p><h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><p>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程<br>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）<br>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p><p><strong>注意</strong>，W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms。</p><h4 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h4><p>在<code>XMLHttpRequest</code>在连接后是通过浏览器新开一个线程请求<br>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/browser_inner_thread.png" alt="浏览器内核"></p><p><strong>为什么JS引擎是单线程的？</strong> 这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。</p><h3 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程</h3><p>看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，<br>这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。</p><p>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），<br>然后在这前提下，看下整个的过程：(简化了很多)</p><ul><li><p>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过<code>RendererHost接口</code>传递给<code>Render进程</code></p></li><li><p>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</p></li></ul><ol><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要<code>GPU进程</code>来帮助渲染</li><li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li><li>最后Render进程将结果传递给<code>Browser进程</code></li></ol><ul><li>Browser进程接收到结果并将结果绘制出来</li></ul><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/browser_rending_interact.png" alt="流程"></p><h2 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系</h2><h3 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h3><p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，<br>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p><h3 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h3><p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p><p>譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。<br>然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p><p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h3 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h3><p>前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？</p><p>所以，后来HTML5中支持了<code>Web Worker</code>。</p><p><strong>MDN的官方解释是</strong>：</p><pre><code class="html">Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误</code></pre><p>这样理解下：</p><ul><li>创建<code>Worker</code>时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS引擎线程与<code>worker</code>线程间通过特定的方式通信（<code>postMessage API</code>，需要通过序列化对象来与线程交互特定的数据）</li></ul><p>所以，如果有非常耗时的工作，请单独开一个<code>Worker</code>线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!</p><p>而且注意下，<strong>JS引擎是单线程的</strong>，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><h3 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h3><p>既然都到了这里，就再提一下<code>SharedWorker</code>（避免后续将这两个概念搞混）</p><p><code>WebWorker</code>只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</p><p>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</p><p><code>SharedWorker</code>是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</p><p>所以Chrome浏览器为<code>SharedWorker</code>单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个<code>SharedWorker</code>进程，不管它被创建多少次。<br>看到这里，应该就很容易明白了，<strong>本质上就是进程和线程的区别</strong>。<code>SharedWorker</code>由独立的进程管理，<code>WebWorker</code>只是属于render进程下的一个线程</p><h2 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h2><p>为了简化理解，前期工作直接省略成：</p><pre><code class="html">- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程- 浏览器渲染流程开始浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：1.解析html建立dom树2.解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）3.布局render树（Layout/reflow），负责各元素尺寸、位置的计算4.绘制render树（paint），绘制页面像素信息5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</code></pre><p>所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p><p>既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。</p><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/browser_rending.png" alt="渲染过程"></p><h3 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h3><p>上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？</p><p>很简单，知道它们的定义就可以了：</p><blockquote><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。(譬如如果有async加载的脚本就不一定完成)</p></blockquote><blockquote><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。(渲染完毕了)</p></blockquote><p>所以，顺序是：<code>DOMContentLoaded -&gt; load</code></p><h3 id="css加载是否会阻塞dom树渲染？"><a href="#css加载是否会阻塞dom树渲染？" class="headerlink" title="css加载是否会阻塞dom树渲染？"></a>css加载是否会阻塞dom树渲染？</h3><p>这里说的是头部引入css的情况</p><p>首先，我们都知道：<strong>css是由单独的下载线程异步下载的</strong>。</p><p>然后再说下几个现象：</p><blockquote><p>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）<br>但会阻塞render树渲染(渲染时需等css加载完毕，因为render树需要css信息)<br>这可能也是浏览器的一种优化机制。</p></blockquote><p>因为你加载css的时候，可能会修改下面DOM节点的样式，<br>如果css加载不阻塞render树渲染的话，那么当css加载完之后，<br>render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。<br>所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，</p><p>在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p><h2 id="从Event-Loop谈JS的运行机制"><a href="#从Event-Loop谈JS的运行机制" class="headerlink" title="从Event Loop谈JS的运行机制"></a>从Event Loop谈JS的运行机制</h2><p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。</p><p>注意，这里不谈可执行上下文，<code>VO，scop chain</code>等概念（这些完全可以整理成另一篇文章了），这里主要是结合<code>Event Loop</code>来谈JS代码是如何执行的。</p><p>读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）</p><blockquote><p>JS引擎线程</p></blockquote><ul><li>事件触发线程</li><li>定时触发器线程</li></ul><blockquote><p>然后再理解一个概念：</p></blockquote><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/js_event_loop.png" alt="图"></p><p>看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在<strong>它推入到事件列表时，主线程还不空闲，正在执行其它代码</strong>，<br>所以自然有误差。</p><h3 id="事件循环机制进一步补充"><a href="#事件循环机制进一步补充" class="headerlink" title="事件循环机制进一步补充"></a>事件循环机制进一步补充</h3><p>这里就直接引用一张图片来协助理解：（参考自<a href="http://vimeo.com/96425312">Philip Roberts的演讲《Help, I’m stuck in an event-loop》</a>）</p><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/js_event_loop2.png" alt="事件循环"></p><blockquote><p>上图大致描述就是：</p></blockquote><ul><li>主线程运行时会产生执行栈，</li><li>栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）</li><li>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</li></ul><p>如此循环<br><strong>注意</strong>，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件(栈执行完,才会执行队列中的事件)</p><h3 id="单独说说定时器"><a href="#单独说说定时器" class="headerlink" title="单独说说定时器"></a>单独说说定时器</h3><p>上述事件循环机制的核心是：JS引擎线程和事件触发线程</p><p>但事件上，里面还有一些隐藏细节，譬如<em>调用setTimeout后，是如何等待特定时间后才添加到事件队列中的</em>？</p><p>是JS引擎检测的么？当然不是了。它是由<code>定时器线程控制</code>（因为JS引擎自己都忙不过来，根本无暇分身）</p><p><strong>为什么要单独的定时器线程</strong>？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</p><p><strong>什么时候会用到定时器线程</strong>？当使用<code>setTimeout</code>或<code>setInterval</code>时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p><p>譬如:</p><pre><code class="js">setTimeout(function()&#123;    console.log(&#39;hello!&#39;);&#125;, 1000);</code></pre><p>这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</p><pre><code class="js">setTimeout(function()&#123;    console.log(&#39;hello!&#39;);&#125;, 0);console.log(&#39;begin&#39;);</code></pre><p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行</p><p>注意：</p><p>执行结果是：<code>先begin后hello!</code></p><p>虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定<strong>要求setTimeout中低于4ms的时间间隔算为4ms</strong>。<br>(不过也有一说是不同浏览器有不同的最小时间设定)</p><p>就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列）</p><h3 id="setTimeout而不是setInterval"><a href="#setTimeout而不是setInterval" class="headerlink" title="setTimeout而不是setInterval"></a>setTimeout而不是setInterval</h3><p>用<code>setTimeout</code>模拟定期计时和直接用<code>setInterval</code>是有区别的。</p><p>因为每次<code>setTimeout</code>计时到后就会去执行，然后执行一段时间后才会继续<code>setTimeout</code>，中间就多了误差<br>（误差多少与代码执行时间有关）</p><p>而<code>setInterval</code>则是每次都精确的隔一段时间推入一个事件<br>（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</p><p>而且<code>setInterval</code>有<strong>一些比较致命的问题</strong>就是：</p><ul><li>某些间隔会被跳过（丢帧现象）</li><li>定时器之间的间隔会比预期小</li></ul><p>把浏览器最小化显示等操作时，<code>setInterval</code>并不是不执行程序，<br>它会把<code>setInterval</code>的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时</p><p>所以，鉴于这么多但问题，目前一般认为的最佳方案是：用<code>setTimeout</code>模拟<code>setInterval</code>，或者特殊场合直接用<code>requestAnimationFrame</code></p><pre><code class="js">// setTimeout模拟setTimeIntervallet count = 0;let timerId = null;timerId = setTimeout(function run() &#123;  console.log(&quot;run -&gt; &quot;, count);  if (count &gt;= 3) &#123;    clearTimeout(timerId);    return;  &#125;  count += 1;  timerId = setTimeout(run, 1000);&#125;, 1000);</code></pre><p>补充：JS高程中有提到，JS引擎会对<code>setInterval</code>进行优化，如果当前事件队列中有<code>setInterval</code>的回调，不会重复添加。不过，仍然是有很多问题。。。</p><h2 id="事件循环进阶：macrotask与microtask"><a href="#事件循环进阶：macrotask与microtask" class="headerlink" title="事件循环进阶：macrotask与microtask"></a>事件循环进阶：macrotask与microtask</h2><p>这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下），<br>强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：</p><p>(<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)[https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/]">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)[https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/]</a></p><p>上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：</p><pre><code class="js">console.log(&#39;script start&#39;);setTimeout(function() &#123;    console.log(&#39;setTimeout&#39;);&#125;, 0);Promise.resolve().then(function() &#123;    console.log(&#39;promise1&#39;);&#125;).then(function() &#123;    console.log(&#39;promise2&#39;);&#125;);console.log(&#39;script end&#39;);// 执行顺序/* script startscript endpromise1promise2setTimeout */</code></pre><p>为什么呢？因为<code>Promise</code>里有了一个一个新的概念：<code>microtask</code></p><p>或者，进一步，JS中分为两种任务类型：<code>macrotask和microtask</code>，在ECMAScript中，<code>microtask称为jobs，macrotask可称为task</code></p><blockquote><p>它们的定义？区别？简单点可以按如下理解：</p></blockquote><ul><li><code>macrotask</code>（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li></ul><p>每一个task会从头到尾将这个任务执行完毕，不会执行其它<br>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染<br>（<code>task-&gt;渲染-&gt;task-&gt;...</code>）</p><ul><li><code>microtask</code>（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</li></ul><p>也就是说，在当前task任务后，下一个task之前，在渲染之前<br>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染</p><p>也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）</p><p>分别什么样的场景会形成<code>macrotask</code>和<code>microtask</code>呢？</p><ul><li><strong>macrotask：主代码块，setTimeout，setInterval等</strong>（可以看到，事件队列中的每一个事件都是一个macrotask）</li><li><strong>microtask：Promise，process.nextTick等</strong></li></ul><p>补充：在node环境下，<code>process.nextTick</code>的优先级高于<code>Promise</code>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的<code>nextTickQueue</code>部分，然后才会执行微任务中的<code>Promise</code>部分。</p><p>参考：(<a href="https://segmentfault.com/q/1010000011914016)[https://segmentfault.com/q/1010000011914016]">https://segmentfault.com/q/1010000011914016)[https://segmentfault.com/q/1010000011914016]</a></p><p>再根据线程来理解下：</p><ul><li><code>macrotask</code>中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护;</li><li><code>microtask</code>中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前<code>macrotask</code>执行完毕后执行，而这个队列由JS引擎线程维护<br>（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</li></ul><blockquote><p>所以，总结下运行机制：</p></blockquote><ol><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ol><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/js_macrotask_microtask.png" alt="如图"></p><p>另外，请注意下<code>Promise</code>的<code>polyfill</code>与官方版本的区别：</p><ul><li>官方版本中，是标准的microtask形式</li><li><code>polyfill</code>，一般都是通过setTimeout模拟的，所以是macrotask形式</li></ul><p>请特别注意这两点区别<br>注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），<br>但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p><p><strong>使用MutationObserver实现microtask</strong></p><p><code>MutationObserver</code>可以用来实现microtask<br>（它属于microtask，优先级小于Promise，一般是Promise不支持时才会这样做）</p><p><strong>它是HTML5中的新特性，作用是：监听一个DOM变动，</strong><br>当DOM对象树发生任何变动时，<code>Mutation Observer</code>会得到通知</p><p>像以前的Vue源码中就是<strong>利用它来模拟nextTick的</strong>，</p><p><strong>具体原理</strong>是，创建一个<code>TextNode</code>并监听内容变化，然后要<code>nextTick</code>的时候去改一下这个节点的文本内容，</p><p>如下：（Vue的源码，未修改）</p><pre><code class="js">var counter = 1var observer = new MutationObserver(nextTickHandler)var textNode = document.createTextNode(String(counter))observer.observe(textNode, &#123;    characterData: true&#125;)timerFunc = () =&gt; &#123;    counter = (counter + 1) % 2    textNode.data = String(counter)&#125;</code></pre><p><a href="https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95">vue对应源码链接</a></p><p>不过，现在的<code>Vue（2.5+）</code>的nextTick实现<strong>移除了MutationObserver的方式</strong>（据说是兼容性原因），<br>取而代之的是使用<strong>MessageChannel</strong><br>（当然，默认情况仍然是Promise，不支持才兼容的）。</p><p><strong>MessageChannel</strong>属于宏任务，优先级是：<code>MessageChannel-&gt;setTimeout</code>，<br>所以<code>Vue（2.5+）</code>内部的nextTick与2.4及之前的实现是不一样的，需要注意下。</p><p>这里不展开，可以看下(地址)[<a href="https://juejin.im/post/5a1af88f5188254a701ec230]">https://juejin.im/post/5a1af88f5188254a701ec230]</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之数据结构</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-09-25T08:10:59.000Z</published>
    <updated>2020-09-25T08:12:17.099Z</updated>
    
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之算法</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%AE%97%E6%B3%95/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-25T07:51:16.000Z</published>
    <updated>2020-09-27T08:37:00.920Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法应该算是高级前端工程是的必备技能了,接下来排列下,我知道的一些算法及应该掌握的算法</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><a href="https://juejin.im/post/6844903444365443080">排序</a></p><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><p><a href="https://singsing.io/blog/tags/FreeCodeCamp/page/5/">leetcode</a></p><h2 id="JavaScript-数据结构与算法之美"><a href="#JavaScript-数据结构与算法之美" class="headerlink" title="JavaScript 数据结构与算法之美"></a>JavaScript 数据结构与算法之美</h2><p><a href="https://github.com/biaochenxuying/blog/issues/43">数据结构与算法之美</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;p&gt;算法应该算是高级前端工程是的必备技能了,接下来</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之递归</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/24/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/24/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%80%92%E5%BD%92/</id>
    <published>2020-09-24T06:05:16.000Z</published>
    <updated>2020-09-24T07:56:03.634Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ruanyf/es6tutorial/blob/2e1c10776a9350debfec47de8ddeaf1c2c5a80cc/docs/function.md">原文地址</a></p><h1 id="递归简介"><a href="#递归简介" class="headerlink" title="递归简介"></a>递归简介</h1><blockquote><p>一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。</p></blockquote><p>在看递归之前，你首先要明白”<strong>栈</strong>“的知识，知道的太多不好，你只需记住  <code>栈---“后进先出”</code>，就能了。</p><h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>递归的意思就是函数自己调用自己本身，或者在自己函数调用的下级函数中调用自己。</p><blockquote><p>在程序中函数直接或间接调用自己</p></blockquote><ol><li>直接调用自己</li><li>间接调用自己<br>· 跳出结构,有了跳出才有结果</li></ol><h2 id="递归的思想"><a href="#递归的思想" class="headerlink" title="递归的思想"></a>递归的思想</h2><p>· 递归的调用,最终还是要转换为自己这个函数</p><ol><li>如果有个函数foo,如果他是递归函数,到最后问题还是转换为函数foo的形式</li><li>递归的思想就是将一个未知问题转换为一个已解决的问题来实现</li></ol><p>简单的理解：递归就是<em>程序运行到某个点的时候，调用自身，这个时候，之前没运行完的程序会暂时不运行，等到下一层调用完了之后再运行</em>。这个正是符合栈的先进后出。这个时候就会有个进栈，等到下一层调用完运行了，之后就可以出栈继续运行</p><pre><code class="js">function foo()&#123;  ...foo(...)...&#125;</code></pre><h2 id="递归的步骤-技巧"><a href="#递归的步骤-技巧" class="headerlink" title="递归的步骤(技巧)"></a>递归的步骤(技巧)</h2><ol><li>假设递归函数已经写好</li><li>寻找递推关系</li><li>将递推关系的结构转换为递归体</li><li>将临界条件加入到递归体中</li></ol><blockquote><p>递归的两个必要因素：<br><strong>递归方程，递归结束条件。</strong></p></blockquote><p>我们来举个例子，我们可以用4的阶乘乘以4来定义5的阶乘，3的阶乘乘以4来定义4的阶乘，以此类推。</p><pre><code class="js">factorial(5) = factorial(4) * 5factorial(5) = factorial(3) * 4 * 5factorial(5) = factorial(2) * 3 * 4 * 5factorial(5) = factorial(1) * 2 * 3 * 4 * 5factorial(5) = factorial(0) * 1 * 2 * 3 * 4 * 5factorial(5) = 1 * 1 * 2 * 3 * 4 * 5</code></pre><p>用<code>Haskell</code>的<code>Pattern matching</code> 可以很直观的定义<code>factorial</code>函数:</p><pre><code class="js">factorial n = factorial (n-1)  * nfactorial 0 = 1</code></pre><h2 id="什么是尾调用"><a href="#什么是尾调用" class="headerlink" title="什么是尾调用"></a>什么是尾调用</h2><p><code>尾调用（Tail Call）</code>是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是<strong>指某个函数的最后一步是调用另一个函数</strong>。</p><pre><code class="js">function f(x)&#123;  return g(x);&#125;</code></pre><p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</p><pre><code class="js">// 情况一function f(x)&#123;  let y = g(x);  return y;  //情况一是调用函数g之后，还有赋值操作，所以不属于尾调用&#125;// 情况二function f(x)&#123;  return g(x) + 1;  //属于调用后还有操作，即使写在一行内&#125;// 情况三function f(x)&#123;  g(x);&#125;// 等同于下面的代码。/* function f(x)&#123;  g(x);  return undefined;&#125; */</code></pre><p><strong>尾调用不一定出现在函数尾部</strong>，只要是最后一步操作即可。</p><pre><code class="js">function f(x) &#123;  if (x &gt; 0) &#123;    return m(x)  &#125;  return n(x);&#125;//函数m和n都属于尾调用，因为它们都是函数f的最后一步操作</code></pre><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用之所以与其他调用不同，就在于它的<strong>特殊的调用位置</strong>。</p><p><strong>调用栈概念</strong></p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）</p><p>尾调用由于是<strong>函数的最后一步操作，所以不需要保留外层函数的调用帧</strong>，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了</p><pre><code class="js">function f() &#123;  let m = 1;  let n = 2;  return g(m + n);&#125;f();// 等同于function f() &#123;  return g(3);&#125;f();// 等同于g(3);</code></pre><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p><p>这就叫做<code>“尾调用优化”（Tail call optimization）</code>，即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“<strong>尾调用优化</strong>”的意义。</p><pre><code class="js">function addOne(a)&#123;  var one = 1;  function inner(b)&#123;    return b + one;  &#125;  return inner(a);&#125;</code></pre><p>上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。</p><p><font color="red"><strong>注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</strong></font></p><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p><strong>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</strong></p><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生<code>“栈溢出”错误（stack overflow</code>）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p><pre><code class="js">function factorial(n) &#123;  if (n === 1) return 1;  return n * factorial(n - 1);&#125;factorial(5) // 120</code></pre><p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，**复杂度 O(n) **。</p><p>如果改写成尾递归，只保留一个调用记录，<strong>复杂度 O(1)</strong> 。</p><pre><code class="js">function factorial(n, total) &#123;  if (n === 1) return total;  return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120</code></pre><p>还有一个比较著名的例子，就是计算 <code>Fibonacci 数列</code>，也能充分说明尾递归优化的重要性。</p><p>非尾递归的 <code>Fibonacci 数列</code>实现如下。</p><pre><code class="js">function Fibonacci (n) &#123;  if ( n &lt;= 1 ) &#123;return 1&#125;;  return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 超时Fibonacci(500) // 超时</code></pre><p>尾递归优化过的 <code>Fibonacci 数列</code>实现如下。</p><pre><code class="js">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;  if( n &lt;= 1 ) &#123;return ac2&#125;;  return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity</code></pre><p>由此可见，<strong>“尾调用优化”对递归操作意义重大</strong>，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，<strong>ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存</strong>。</p><h2 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h2><p><strong>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身</strong>。做到这一点的方法，就是<strong>把所有用到的内部变量改写成函数的参数</strong>。比如上面的例子，阶乘函数 <code>factorial</code> 需要用到一个中间变量<code>total</code>，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，<code>为什么计算5的阶乘，需要传入两个参数5和1？</code></p><p>两个方法可以解决这个问题。方法一<strong>是在尾递归函数之外，再提供一个正常形式的函数</strong>。</p><pre><code class="js">function tailFactorial(n, total) &#123;  if (n === 1) return total;  return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123;  return tailFactorial(n, 1);&#125;factorial(5) // 120</code></pre><p>上面代码通过一个正常形式的<code>阶乘函数factorial</code>，调用<code>尾递归函数tailFactorial</code>，看起来就正常多了。</p><p>函数式编程有一个概念，叫做<strong>柯里化（currying）</strong>，意思是将<strong>多参数的函数转换成单参数的形式</strong>。这里也可以使用柯里化。</p><pre><code class="js">function currying(fn, n) &#123;  return function (m) &#123;    return fn.call(this, m, n);  &#125;;&#125;function tailFactorial(n, total) &#123;  if (n === 1) return total;  return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120</code></pre><p>上面代码<code>通过柯里化，将尾递归函数tailFactorial</code>变为只接受一个参数的<code>factorial</code>。</p><p><strong>第二种方法就简单多了，就是采用 ES6 的函数默认值。</strong></p><pre><code class="js">function factorial(n, total = 1) &#123;  if (n === 1) return total;  return factorial(n - 1, n * total);&#125;factorial(5) // 120</code></pre><p>上面代码中，参数total有默认值1，所以调用时不用提供这个值。</p><p>总结一下，递归本质上<strong>是一种循环操作</strong>。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道<strong>循环可以用递归代替，而一旦使用递归，就最好使用尾递归</strong>。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p><font color="red">ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</font></p><blockquote><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p></blockquote><p><code>func.arguments</code>：返回调用时函数的参数。<br><code>func.caller</code>：返回调用当前函数的那个函数。</p><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><pre><code class="js">function restricted() &#123;  &#39;use strict&#39;;  restricted.caller;    // 报错  restricted.arguments; // 报错&#125;restricted();</code></pre><h2 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h2><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是<strong>自己实现尾递归优化</strong>。</p><p>它的原理非常简单。尾递归之所以需要优化，原因<em>是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出</em>。怎么做可以减少调用栈呢？就是采用 <strong>“循环”换掉“递归”</strong>。</p><p>下面是一个正常的递归函数。</p><pre><code class="js">function sum(x, y) &#123;  if (y &gt; 0) &#123;    return sum(x + 1, y - 1);  &#125; else &#123;    return x;  &#125;&#125;sum(1, 100000)// Uncaught RangeError: Maximum call stack size exceeded(…)</code></pre><p>上面代码中，<code>sum</code>是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定<code>sum</code>递归 100000 次，就会报错，提示超出调用栈的最大次数。</p><p><code>蹦床函数（trampoline）</code>可以将递归执行转为循环执行。</p><pre><code class="js">function trampoline(f) &#123;  while (f &amp;&amp; f instanceof Function) &#123;    f = f();  &#125;  return f;&#125;</code></pre><p>上面就是蹦床函数的一个实现，<em>它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题</em>。</p><p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p><pre><code class="js">function sum(x, y) &#123;  if (y &gt; 0) &#123;    return sum.bind(null, x + 1, y - 1);  &#125; else &#123;    return x;  &#125;&#125;</code></pre><p>上面代码中，sum函数的每次执行，都会返回自身的另一个版本。</p><p>现在，使用蹦床函数执行sum，就不会发生调用栈溢出。</p><pre><code class="js">trampoline(sum(1, 100000))// 100001</code></pre><p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p><pre><code class="js">function tco(f) &#123;  var value;  var active = false;  var accumulated = [];  return function accumulator() &#123;    accumulated.push(arguments);    if (!active) &#123;      active = true;      while (accumulated.length) &#123;        value = f.apply(this, accumulated.shift());      &#125;      active = false;      return value;    &#125;  &#125;;&#125;var sum = tco(function(x, y) &#123;  if (y &gt; 0) &#123;    return sum(x + 1, y - 1)  &#125;  else &#123;    return x  &#125;&#125;);sum(1, 100000)// 100001</code></pre><p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮sum执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/ruanyf/es6tutorial/blob/2e1c10776a9350debfec47de8ddeaf1c2c5a80cc/docs/function.md&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;递归简介&quot;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之立即执行函数, 模块化, 命名空间</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/22/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/22/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</id>
    <published>2020-09-22T05:45:52.000Z</published>
    <updated>2020-09-27T08:32:50.536Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://segmentfault.com/a/1190000006966358">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>立即执行函数, 模块化, 命名空间 ，主要是解决两个问题——“<strong>命名空间冲突”，“文件依赖管理</strong>”。</p><p>坑：<br>1.命名空间冲突</p><ul><li>(1)我自己测试好的代码和大家合并后怎么起冲突了？</li><li>(2)页面脚本的变量或函数覆盖了公有脚本的。                                                 </li></ul><p>2.文件依赖管理</p><ul><li>(1)明明项目需要引入的包都引进来了怎么还报缺少包？</li><li>(2)手动管理依赖，有天要更换某个插件，要深入代码内部进行修改</li><li>(3)如下图，显示的代码加载，依赖关系复杂。在F.js中，分不清某个变量是来自C.js，还是E.js</li><li>(4)两次加载同一个模块。比如引入了两遍JQ</li></ul><p><img src="https://segmentfault.com/img/bVDlA5?w=398&h=183" alt="keng"></p><p>3.其他的</p><ul><li>(1)为了实现脚本复用，将一个很大的公用public文件引入各个页面中，其中的某些函数，只有个别页面用到。</li><li>(2)某个功能的函数群函数，与另一个功能的函数群摆在一起，使用注释来分隔。</li></ul><p><strong>目前解决的方法是:模块化</strong></p><p>1.<em>命名空间</em>：各个模块的命名空间独立。A模块的变量x不会覆盖B模块的变量x。<br>2.<em>模块的依赖关系</em>:通过模块管理工具如<code>webpack/requireJS/browserify</code>等进行管理。</p><h2 id="模块化的基本原理——解决命名空间冲突"><a href="#模块化的基本原理——解决命名空间冲突" class="headerlink" title="模块化的基本原理——解决命名空间冲突"></a>模块化的基本原理——解决命名空间冲突</h2><p>JavaScript的缺陷，首当其冲就是全局变量。这使得每想命名一个变量的时候都要三思又三思，生怕上方无穷远的地方有一个同事些的代码和自己冲突。以下是一些防范方法</p><h3 id="一、使用命名空间"><a href="#一、使用命名空间" class="headerlink" title="一、使用命名空间"></a>一、使用命名空间</h3><p>代码如下：</p><pre><code class="js">//定义var module = &#123;    name: &#39;rouwan&#39;,    sayName:function()&#123;        console.log(this.name)    &#125;&#125;//使用var a = module.name;console.log(a)</code></pre><p><strong>总结</strong>：直接修改name不会影响<code>module.name</code>，一定程度保护了命名空间。<br>有两个缺点，一，外部还是可以修改module的属性和方法。二，命名空间有时长起来超乎你的想象。适合一些小型的封装，如一些配置。</p><h3 id="二、立即执行函数-闭包（实现模块的基本方法）"><a href="#二、立即执行函数-闭包（实现模块的基本方法）" class="headerlink" title="二、立即执行函数 + 闭包（实现模块的基本方法）"></a>二、立即执行函数 + 闭包（实现模块的基本方法）</h3><p>立即函数可以创建作用域，闭包则可以形成私有变量和函数</p><pre><code class="js">//创建var module = (function()&#123;  var privateName = &#39;inner&#39;;            //私有变量  var privateFunc = function()&#123;        //私有函数      console.log(&#39;私有函数&#39;)  &#125;  return &#123;                                  name: &#39;rouwan&#39;,                    //公有属性      sayName:function()&#123;                //公有函数          console.log(this.name)      &#125;  &#125;&#125;)()//使用module.sayName();    //&#39;rouwan&#39;</code></pre><p>总结：这是目前比较常用的模块定义方式，<strong>可以区分私有成员和公有成员</strong>。<br>公有变量和方法，和之前一样可以直接通过<code>module.name</code>的方式修改。私有变量和方法，是无法访问的，除非给你个修改私有成员的公有方法。</p><h3 id="三、在上述基础上，引入其他模块"><a href="#三、在上述基础上，引入其他模块" class="headerlink" title="三、在上述基础上，引入其他模块"></a>三、在上述基础上，引入其他模块</h3><pre><code class="js">//定义var module1 = (function(mod)&#123;  var privateName = &#39;inner1&#39;;  var privateFunc = function()&#123;    console.log(&#39;私有函数1&#39;)  &#125;  return &#123;    name : &#39;rouwan1&#39;,    sayName: function()&#123;        console.log(this.name)    &#125;,    anotherName:mod.name,            //另一个模块上的公有参数    sayAnotherName:mod.sayName       //另一个模块上的公有方法  &#125;&#125;)(anotherModule) //引入了另一个模块//使用module1.sayOtherName()</code></pre><h3 id="四、其他的方式"><a href="#四、其他的方式" class="headerlink" title="四、其他的方式"></a>四、其他的方式</h3><p>放大模式等是以往用来管理大型模块，进行文件拆分的方法。现在<code>webpack</code>等模块化工具都很完善的情况下，已经显得有点落后了。就不介绍了。</p><h2 id="告别刀耕火种的时代——模块化构建工具（解决依赖管理）"><a href="#告别刀耕火种的时代——模块化构建工具（解决依赖管理）" class="headerlink" title="告别刀耕火种的时代——模块化构建工具（解决依赖管理）"></a>告别刀耕火种的时代——模块化构建工具（解决依赖管理）</h2><p>我了解js模块是从<strong>立即执行函数</strong>开始的。但是等到真正使用构建工具的时候，却发现业界采用的模块化方案，却并非是<strong>一个一个由立即函数+闭包</strong>形成的集群。</p><p>而是用了诸如<strong>AMD/CMD/CommonJS/ES6</strong>模块等等模块化实现。</p><p>这里面的原因可能有这几个，<br>一，闭包的性能问题。<br>二，当模块增多的时候，需要解决模块间的依赖管理问题。</p><p>关于依赖管理，目前项目里碰到了几个不舒服的地方：</p><p>1.引用多个不同的文件<br>2.HTML中引入了两遍的jq，导致脚本报错。<br>3.有一个公用脚本，包含了N多的公用模块。有些页面明明只用到了一个模块，也必须全部加载一遍。</p><p>因此，必须使用模块化管理工具!</p><p>webpack和requireJS比较：<br><img src="https://segmentfault.com/img/bVDm01?w=746&h=254" alt="webpack和requireJS"></p><p>几种模块化规范比较：<br><img src="https://segmentfault.com/img/bVDm2P?w=890&h=316" alt="模块化"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006966358&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之promise</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/21/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bpromise/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/21/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bpromise/</id>
    <published>2020-09-21T06:24:41.000Z</published>
    <updated>2020-09-27T08:44:35.052Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>promise</code>是一个对象，它代表了一个异步操作的最终完成或者失败。本质上<code>Promise</code>是个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。</p><pre><code class="js">const promise1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(&#39;foo&#39;);  &#125;, 3000);&#125;);promise1.then((value) =&gt; &#123;  console.log(value);  // expected output: &quot;foo&quot;&#125;);console.log(promise1);// expected output: [object Promise]</code></pre><h2 id="promise-约定"><a href="#promise-约定" class="headerlink" title="promise 约定"></a>promise 约定</h2><p>在使用<code>Promise</code>时会有以下约定：</p><ul><li>1.在本轮 事件循环 运行完成之前，回调函数是不会被调用的。</li><li>2.即使异步操作已经完成（成功或失败），在这之后通过 <code>then()</code> 添加的回调函数也会被调用。</li><li>3.通过多次调用 <code>then()</code> 可以添加多个回调函数，它们会按照插入顺序进行执行。</li></ul><p><code>Promise</code>的另一个好处就是<strong>链式调用(chaining)</strong></p><p>原有的回调地狱：</p><pre><code class="js">doSomething(function(result) &#123;  doSomethingElse(result, function(newResult) &#123;    doThirdThing(newResult, function(finalResult) &#123;      console.log(&#39;Got the final result: &#39; + finalResult);    &#125;, failureCallback);  &#125;, failureCallback);&#125;, failureCallback);</code></pre><p>Promise链：</p><pre><code class="js">doSomething().then(function(result) &#123;  return doSomethingElse(result);&#125;).then(function(newResult) &#123;  return doThirdThing(newResult);&#125;).then(function(finalResult) &#123;  console.log(&#39;Got the final result: &#39; + finalResult);&#125;).catch(failureCallback);</code></pre><p>通常，一遇到异常抛出，浏览器就会顺着 <code>Promise</code> 链寻找下一个 <code>onRejected</code> 失败回调函数或者由 <code>.catch()</code> 指定的回调函数。这和以下同步代码的工作原理（执行过程）非常相似。</p><pre><code class="js">try &#123;  let result = syncDoSomething();  let newResult = syncDoSomethingElse(result);  let finalResult = syncDoThirdThing(newResult);  console.log(`Got the final result: $&#123;finalResult&#125;`);&#125; catch(error) &#123;  failureCallback(error);&#125;</code></pre><p>在 ECMAScript 2017 标准的 <code>async/await</code> 语法糖中，这种异步代码的对称性得到了极致的体现：</p><pre><code class="js">async function foo() &#123;  try &#123;    const result = await doSomething();    const newResult = await doSomethingElse(result);    const finalResult = await doThirdThing(newResult);    console.log(`Got the final result: $&#123;finalResult&#125;`);  &#125; catch(error) &#123;    failureCallback(error);  &#125;&#125;</code></pre><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>Promise</code> 对象是<strong>一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的</strong>。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的<code>promise</code>对象&gt; </p><blockquote><p>一个 <code>Promise</code>有以下几种状态:<br><code>pending</code>: 初始状态，既不是成功，也不是失败状态。<br><code>fulfilled</code>: 意味着操作成功完成。<br><code>rejected</code>: 意味着操作失败。</p></blockquote><p><img src="https://mdn.mozillademos.org/files/8633/.png" alt="promise"></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h3><p>这个方法返回一个新的<code>promise</code>对象，该<code>promise</code>对象在<code>iterable</code>参数对象里所有的<code>promise</code>对象都成功的时候才会触发成功，一旦有任何一个iterable里面的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败</p><pre><code class="js">const arr = [1,2,3,4];const promiseArr = arr.map(arg =&gt; &#123;    return new Promise((resolve,reject) =&gt; &#123;        if(arg) &#123;            resolve(arg*2);        &#125;else&#123;            reject(&#39;no value&#39;);        &#125;    &#125;)&#125;);Promise.all(promiseArr).then(data =&gt; &#123;    console.log(data);  // [2,4,6,8]&#125;).catch(err =&gt; &#123;    console.log(err); &#125;)</code></pre><h3 id="Promise-allSettled-iterable"><a href="#Promise-allSettled-iterable" class="headerlink" title="Promise.allSettled(iterable)"></a>Promise.allSettled(iterable)</h3><p>等到所有<code>promise</code>都完成（每个<code>promise</code>返回成功或失败）。<br>返回一个<code>promise</code>，该<code>promise</code>在所有<code>promise</code>完成后完成。并带有一个对象数组，每个对象对应每个<code>promise</code>的结果。</p><pre><code class="js">const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, &#39;foo&#39;));const promises = [promise1, promise2];Promise.allSettled(promises).  then((results) =&gt; results.forEach((result) =&gt; console.log(result.status)));// expected output:// &quot;fulfilled&quot;// &quot;rejected&quot;</code></pre><h3 id="Promise-any-iterable"><a href="#Promise-any-iterable" class="headerlink" title="Promise.any(iterable)"></a>Promise.any(iterable)</h3><p>接收一个<code>Promise</code>对象的集合，当其中的一个<code>promise</code> 成功，就返回那个成功的<code>promise</code>的值。(谁成功返回谁,用于返回第一个成功的 promise)</p><pre><code class="js">// 显示第一张已加载的图片function fetchAndDecode(url) &#123;  return fetch(url).then(response =&gt; &#123;    if(!response.ok) &#123;      throw new Error(`HTTP error! status: $&#123;response.status&#125;`);    &#125; else &#123;      return response.blob();    &#125;  &#125;)&#125;let coffee = fetchAndDecode(&#39;coffee.jpg&#39;);let tea = fetchAndDecode(&#39;tea.jpg&#39;);Promise.any([coffee, tea]).then(value =&gt; &#123;  let objectURL = URL.createObjectURL(value);  let image = document.createElement(&#39;img&#39;);  image.src = objectURL;  document.body.appendChild(image);&#125;).catch(e =&gt; &#123;  console.log(e.message);&#125;);</code></pre><h3 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h3><p>执行顺序是按照谁快 谁先输出</p><p>当<code>iterable</code>参数里的任意一个子<code>promise</code>被成功或失败后，父<code>promise</code>马上也会用子<code>promise</code>的成功返回值或失败详情作为参数调用父<code>promise</code>绑定的相应句柄，并返回该<code>promise</code>对象。</p><pre><code class="js">const pro1 = new Promise((resolve,reject) =&gt; &#123;    setTimeout(resolve,100,&#39;1&#39;);&#125;);const pro2 = new Promise((resolve,reject) =&gt; &#123;    setTimeout(resolve,200,&#39;2&#39;);&#125;);const pro3 = new Promise((resolve,reject) =&gt; &#123;    setTimeout(resolve,300,&#39;3&#39;);&#125;);const pro4 = new Promise((resolve,reject) =&gt; &#123;    setTimeout(resolve,10,&#39;4&#39;);&#125;);Promise.race([pro4,pro1,pro2,pro3]).then(data =&gt; &#123;    console.log(data);  // 1   输出最快的那个&#125;).catch(err =&gt; &#123;    console.log(err);&#125;)</code></pre><h3 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h3><p>返回一个状态为失败的<code>Promise</code>对象，并将给定的失败信息传递给对应的处理方法</p><pre><code class="js">const p_2 = Promise.reject(&#39;err&#39;);p_2.then(data =&gt; &#123;    console.log(data);  &#125;).catch(err =&gt; &#123;    console.log(err);  // err&#125;)</code></pre><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h3><p>返回一个状态由给定<code>value</code>决定的<code>Promise</code>对象。<br>通常而言，如果你不知道一个值是否是<code>Promise</code>对象，使用<code>Promise.resolve(value)</code> 来返回一个<code>Promise</code>对象,这样就能将该value以<code>Promise</code>对象形式使用。</p><pre><code class="js">const p_1 = Promise.resolve(&#39;success&#39;);p_1.then(data =&gt; &#123;    console.log(data);   // success&#125;)2</code></pre><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><code>catch()</code> 方法返回一个<code>Promise</code>，并且处理拒绝的情况。</p><pre><code class="js">//创建一个新的 Promise ，且已决议var p1 = Promise.resolve(&quot;calling next&quot;);var p2 = p1.catch(function (reason) &#123;    //这个方法永远不会调用    console.log(&quot;catch p1!&quot;);    console.log(reason);&#125;);p2.then(function (value) &#123;    console.log(&quot;next promise&#39;s onFulfilled&quot;); /* next promise&#39;s onFulfilled */    console.log(value); /* calling next */&#125;, function (reason) &#123;    console.log(&quot;next promise&#39;s onRejected&quot;);    console.log(reason);&#125;);</code></pre><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code> 方法返回一个<code>Promise</code>。在<code>promise</code>结束时，无论结果是<code>fulfilled</code>或者是<code>rejected</code>，都会执行指定的回调函数。这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式。</p><pre><code class="js">let isLoading = true;fetch(myRequest).then(function(response) &#123;    var contentType = response.headers.get(&quot;content-type&quot;);    if(contentType &amp;&amp; contentType.includes(&quot;application/json&quot;)) &#123;      return response.json();    &#125;    throw new TypeError(&quot;Oops, we haven&#39;t got JSON!&quot;);  &#125;)  .then(function(json) &#123; /* process your JSON further */ &#125;)  .catch(function(error) &#123; console.log(error); &#125;)  .finally(function() &#123; isLoading = false; &#125;);</code></pre><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p><code>then()</code> 方法返回一个 <code>Promise</code>。它最多需要有两个参数：<code>Promise</code> 的成功和失败情况的回调函数。</p><pre><code class="js">var p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#39;成功！&#39;);  // or  // reject(new Error(&quot;出错了！&quot;));&#125;);p1.then(value =&gt; &#123;  console.log(value); // 成功！&#125;, reason =&gt; &#123;  console.error(reason); // 出错了！&#125;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;promise&lt;/code&gt;是一个</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之变量提升</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/18/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/18/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</id>
    <published>2020-09-18T09:00:43.000Z</published>
    <updated>2020-09-27T08:42:44.486Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.im/post/6844903490989342728">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在不同作用域下变量与函数的提升表现也是不一致的。在 <code>JavaScript</code> 中，所有绑定的声明会在控制流到达它们出现的作用域时被初始化；这里的作用域其实就是所谓的<code>执行上下文（Execution Context）</code>，每个执行上下文分为<code>内存分配（Memory Creation Phase）</code>与<code>执行（Execution）</code>这两个阶段。在执行上下文的内存分配阶段会进行变量创建，即开始进入了变量的生命周期；变量的生命周期包含了<code>声明（Declaration phase）</code>、<code>初始化（Initialization phase）</code>与<code>赋值（Assignment phase）</code>过程这三个过程。</p><p>传统的 <code>var</code> 关键字声明的变量允许在声明之前使用，此时该变量被赋值为 <code>undefined</code>；而函数作用域中声明的函数同样可以在声明前使用，其函数体也被<strong>提升到了头部</strong>。这种特性表现也就是所谓的<code>提升（Hoisting）</code>；</p><p>虽然在 <code>ES6</code> 中以 <code>let 与 const</code> 关键字声明的变量同样会在作用域头部被初始化，不过这些变量仅允许在实际声明之后使用。在作用域头部与变量实际声明处之间的区域就称为所谓的<code>暂时死域（Temporal Dead Zone）</code>，，TDZ 能够避免传统的提升引发的潜在问题。</p><p>由于 ES6 <strong>引入了块级作用域，在块级作用域中声明的函数会被提升到该作用域头部，即允许在实际声明前使用</strong>；而在部分实现中该函数同时被提升到了所处函数作用域的头部，不过此时被赋值为 <code>undefined</code>。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><code>作用域（Scope）</code>即代码执行过程中的变量、函数或者对象的可访问区域，<strong>作用域决定了变量或者其他资源的可见性</strong>；计算机安全中一条基本原则即是<strong>用户只应该访问他们需要的资源，而作用域就是在编程中遵循该原则来保证代码的安全性</strong>。除此之外，<strong>作用域还能够帮助我们提升代码性能、追踪错误并且修复它们</strong>。<code>JavaScript</code> 中的作用域主要分为<code>全局作用域（Global Scope）</code>与<code>局部作用域（Local Scope）</code>两大类，在 ES5 中定义在函数内的变量即是属于某个局部作用域，而定义在函数外的变量即是属于<code>全局作用域</code>。</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>当我们在浏览器控制台或者 Node.js 交互终端中开始编写 JavaScript 时，即进入了所谓的全局作用域：</p><pre><code class="js">// the scope is by default globalvar name = &#39;Hammad&#39;;// 定义在全局作用域中的变量能够被任意的其他作用域中访问：var name = &#39;Hammad&#39;;console.log(name); // logs &#39;Hammad&#39;function logName() &#123;    console.log(name); // &#39;name&#39; is accessible here and everywhere else&#125;logName(); // logs &#39;Hammad&#39;</code></pre><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p><strong>定义在某个函数内的变量即从属于当前函数作用域</strong>，在每次函数调用中都会创建出新的上下文；换言之，我们可以在不同的函数中定义同名变量，这些变量会被绑定到各自的函数作用域中：</p><pre><code class="js">// Global Scopefunction someFunction() &#123;    // Local Scope #1    function someOtherFunction() &#123;        // Local Scope #2    &#125;&#125;// Global Scopefunction anotherFunction() &#123;    // Local Scope #3&#125;// Global Scope</code></pre><p><strong>函数作用域的缺陷在于粒度过大，在使用闭包或者其他特性时导致异常的变量传递</strong>：</p><pre><code class="js">var callbacks = [];// 这里的 i 被提升到了当前函数作用域头部for (var i = 0; i &lt;= 2; i++) &#123;    callbacks[i] = function () &#123;            return i * 2;        &#125;;&#125;console.log(callbacks[0]()); //6console.log(callbacks[1]()); //6console.log(callbacks[2]()); //6</code></pre><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>类似于 <code>if、switch</code> 条件选择或者 <code>for、while</code> 这样的循环体即是所谓的块级作用域；在 ES5 中，要实现块级作用域，即需要<strong>在原来的函数作用域上包裹一层</strong>，即<strong>在需要限制变量提升的地方手动设置一个变量来替代原来的全局变量</strong>，譬如：</p><pre><code class="js">var callbacks = [];for (var i = 0; i &lt;= 2; i++) &#123;    (function (i) &#123;        // 这里的 i 仅归属于该函数作用域        callbacks[i] = function () &#123;            return i * 2;        &#125;;    &#125;)(i);&#125;callbacks[0]() === 0;callbacks[1]() === 2;callbacks[2]() === 4;</code></pre><p>而在 ES6 中，可以直接利用 let 关键字达成这一点：</p><pre><code class="js">let callbacks = []for (let i = 0; i &lt;= 2; i++) &#123;    // 这里的 i 属于当前块作用域    callbacks[i] = function () &#123;        return i * 2    &#125;&#125;callbacks[0]() === 0callbacks[1]() === 2callbacks[2]() === 4</code></pre><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>。一般来说，在编程语言里我们常见的变量作用域就是词法作用域与动态作用域（Dynamic Scope），绝大部分的编程语言都是使用的词法作用域。词法作用域注重的是所谓的 Write-Time，即编程时的上下文，而动态作用域以及常见的 this 的用法，都是 Run-Time，即运行时上下文。<strong>词法作用域关注的是函数在何处被定义，而动态作用域关注的是函数在何处被调用</strong>JavaScript 是典型的词法作用域的语言，即一个符号参照到语境中符号名字出现的地方，局部变量缺省有着词法作用域</p><pre><code class="js">function foo() &#123;    console.log( a ); // 2 in Lexical Scope ，But 3 in Dynamic Scope&#125;function bar() &#123;    var a = 3;    foo();&#125;var a = 2;bar();</code></pre><h2 id="执行上下文与提升"><a href="#执行上下文与提升" class="headerlink" title="执行上下文与提升"></a>执行上下文与提升</h2><p><code>作用域（Scope）</code>与<code>上下文（Context）</code>常常被用来描述相同的概念，不过上下文更多的关注于代码中 <code>this</code> 的使用，而作用域则与变量的可见性相关；而 JavaScript 规范中的<code>执行上下文（Execution Context</code>）其实描述的是变量的作用域。众所周知，JavaScript 是单线程语言，同时刻仅有单任务在执行，而其他任务则会被压入执行上下文队列中；<strong>每次函数调用时都会创建出新的上下文，并将其添加到执行上下文队列中</strong>。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>每个执行上下文又会分为<code>内存创建（Creation Phase）</code>与<code>代码执行（Code Execution Phase）</code>两个步骤，在创建步骤中会进行变量对象的创建（<code>Variable Object</code>）、作用域链的创建以及设置当前上下文中的 this 对象。所谓的 <code>Variable Object</code> ，又称为 <code>Activation Object</code>，包含了当前执行上下文中的所有变量、函数以及具体分支中的定义。当某个函数被执行时，解释器会先扫描所有的函数参数、变量以及其他声明：</p><pre><code class="js">&#39;variableObject&#39;: &#123;    // contains function arguments, inner variable and function declarations&#125;</code></pre><p>在 <code>Variable Object</code> 创建之后，解释器会继续创建<code>作用域链（Scope Chain）</code>；作用域链往往指向其副作用域，往往被用于解析变量。当需要解析某个具体的变量时，JavaScript 解释器会在作用域链上递归查找，直到找到合适的变量或者任何其他需要的资源。作用域链可以被认为是包含了其自身 <code>Variable Object</code> 引用以及所有的父 <code>Variable Object</code> 引用的对象：</p><pre><code class="js">&#39;scopeChain&#39;: &#123;    // contains its own variable object and other variable objects of the parent execution contexts&#125;</code></pre><p>而执行上下文则可以表述为如下抽象对象：</p><pre><code class="js">executionContextObject = &#123;    &#39;scopeChain&#39;: &#123;&#125;, // contains its own variableObject and other variableObject of the parent execution contexts    &#39;variableObject&#39;: &#123;&#125;, // contains function arguments, inner variable and function declarations    &#39;this&#39;: valueOfThis&#125;</code></pre><h3 id="变量的生命周期与提升"><a href="#变量的生命周期与提升" class="headerlink" title="变量的生命周期与提升"></a>变量的生命周期与提升</h3><ul><li>变量的生命周期包含着<strong>变量声明（Declaration Phase）、变量初始化（Initialization Phase）以及变量赋值（Assignment Phase）</strong>三个步骤；</li></ul><p>其中声明步骤会在作用域中注册变量，初始化步骤负责为变量分配内存并且创建作用域绑定，此时变量会被初始化为 <code>undefined</code>，最后的分配步骤则会将开发者指定的值分配给该变量。</p><p>传统的使用 var 关键字声明的变量的生命周期如下：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/13/b9b8aa1b2352bd9c153d8dd502c8eae9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="varlife"></p><p>而 let 关键字声明的变量生命周期如下：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/13/b1963cb58e148aad82a6c26215f8754d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="letlife"></p><p>如上文所说，我们可以在某个变量或者函数定义之前访问这些变量，这即是所谓的<code>变量提升（Hoisting）</code>。传统的 var 关键字声明的变量会被提升到作用域头部，并被赋值为 <code>undefined</code>：</p><pre><code class="js">// var hoistingnum;     // =&gt; undefined  var num;  num = 10;  num;     // =&gt; 10  // function hoistinggetPi;   // =&gt; function getPi() &#123;...&#125;  getPi(); // =&gt; 3.14  function getPi() &#123;    return 3.14;&#125;</code></pre><p>变量提升只对 var 命令声明的变量有效，如果一个变量不是用 var 命令声明的，就不会发生变量提升。</p><pre><code class="js">console.log(b);b = 1;</code></pre><p>上面的语句将会报错，提示 <code>ReferenceError: b is not defined</code>，即变量 b 未声明，这是因为 b 不是用 var 命令声明的，JavaScript 引擎不会将其提升，而只是视为对顶层对象的 b 属性的赋值。ES6 引入了块级作用域，<strong>块级作用域中使用 let 声明的变量同样会被提升，只不过不允许在实际声明语句前使用</strong>：</p><pre><code class="js">&gt; let x = x;ReferenceError: x is not defined    at repl:1:9    at ContextifyScript.Script.runInThisContext (vm.js:44:33)    at REPLServer.defaultEval (repl.js:239:29)    at bound (domain.js:301:14)    at REPLServer.runBound [as eval] (domain.js:314:12)    at REPLServer.onLine (repl.js:433:10)    at emitOne (events.js:120:20)    at REPLServer.emit (events.js:210:7)    at REPLServer.Interface._onLine (readline.js:278:10)    at REPLServer.Interface._line (readline.js:625:8)&gt; let x = 1;SyntaxError: Identifier &#39;x&#39; has already been declared</code></pre><h3 id="函数的生命周期与提升"><a href="#函数的生命周期与提升" class="headerlink" title="函数的生命周期与提升"></a>函数的生命周期与提升</h3><p>基础的函数提升同样会将声明提升至作用域头部，不过不同于变量提升，函数同样会将其函数体定义提升至头部；譬如：</p><pre><code class="js">function b() &#123;     a = 10;     return;     function a() &#123;&#125; &#125;</code></pre><p>会被编译器修改为如下模式：</p><pre><code class="js">function b() &#123;  function a() &#123;&#125;  a = 10;  return;&#125;</code></pre><p>在内存创建步骤中，JavaScript 解释器会通过<code> function 关键字</code>识别出函数声明并且将其提升至头部；函数的生命周期则比较简单，声明、初始化与赋值三个步骤都被提升到了作用域头部：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/13/1715ccbd677cc0eccecdffb48764756d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="functionlife"></p><p>如果我们在作用域中<strong>重复地声明同名函数，则会由后者覆盖前者</strong>：</p><pre><code class="js">sayHello();function sayHello () &#123;    function hello () &#123;        console.log(&#39;Hello!&#39;);    &#125;    hello();    function hello () &#123;        console.log(&#39;Hey!&#39;);    &#125;&#125;// Hey!</code></pre><p>而 JavaScript 中提供了两种函数的创建方式，<code>函数声明（Function Declaration）</code>与<code>函数表达式（Function Expression）</code>；函数声明即是以 <strong>function 关键字开始，跟随者函数名与函数体</strong>。而函数表达式则是<strong>先声明函数名，然后赋值匿名函数给它</strong>；典型的函数表达式如下所示：</p><pre><code class="js">var sayHello = function() &#123;  console.log(&#39;Hello!&#39;);&#125;;sayHello();// Hello!</code></pre><p><strong>函数表达式遵循变量提升的规则，函数体并不会被提升至作用域头部</strong>：</p><pre><code class="js">sayHello();function sayHello () &#123;    function hello () &#123;        console.log(&#39;Hello!&#39;);    &#125;    hello();    var hello = function () &#123;        console.log(&#39;Hey!&#39;);    &#125;&#125;// Hello!</code></pre><p><strong>在 ES5 中，是不允许在块级作用域中创建函数的；而 ES6 中允许在块级作用域中创建函数</strong>,块级作用域中创建的函数同样会被提升至当前块级作用域头部与函数作用域头部。不同的是函数体并不会再被提升至函数作用域头部，而仅会被提升到块级作用域头部：</p><pre><code class="js">f; // Uncaught ReferenceError: f is not defined(function () &#123;  f; // undefined  x; // Uncaught ReferenceError: x is not defined  if (true) &#123;    f();    let x;    function f() &#123; console.log(&#39;I am function!&#39;); &#125;  &#125;&#125;());</code></pre><h2 id="避免全局变量"><a href="#避免全局变量" class="headerlink" title="避免全局变量"></a>避免全局变量</h2><p><strong>全局变量的不好</strong>：在计算机编程中，全局变量指的是在所有作用域中都能访问的变量。全局变量是一种不好的实践，因为它会导致一些问题，比如一个已经存在的方法和全局变量的覆盖，当我们不知道变量在哪里被定义的时候，代码就变得很难理解和维护了。</p><p>在 ES6 中可以利用 <code>let</code> 关键字来声明本地变量，好的 JavaScript 代码就是没有定义全局变量的。在 JavaScript 中，我们有时候会无意间创建出全局变量，即如果我们在使用某个变量之前忘了进行声明操作，那么该变量会被自动认为是全局变量，譬如:</p><pre><code class="js">function sayHello()&#123;  hello = &quot;Hello World&quot;;  return hello;&#125;sayHello();console.log(hello);</code></pre><p>在上述代码中因为我们在使用 <code>sayHello</code> 函数的时候并没有声明 <code>hello</code> 变量，因此其会创建作为某个全局变量。如果我们想要避免这种偶然创建全局变量的错误，可以通过强制使用 <code>strict mode</code> 来禁止创建全局变量。</p><h3 id="函数包裹"><a href="#函数包裹" class="headerlink" title="函数包裹"></a>函数包裹</h3><p>为了避免全局变量，第一件事情就是要确保所有的代码都被包在函数中。最简单的办法就是把所有的代码都直接放到一个函数中去:</p><pre><code class="js">(function(win) &#123;    &quot;use strict&quot;; // 进一步避免创建全局变量    var doc = window.document;    // 在这里声明你的变量    // 一些其他的代码&#125;(window));</code></pre><h3 id="声明命名空间"><a href="#声明命名空间" class="headerlink" title="声明命名空间"></a>声明命名空间</h3><pre><code class="js">var MyApp = &#123;    namespace: function(ns) &#123;        var parts = ns.split(&quot;.&quot;),            object = this, i, len;        for(i = 0, len = parts.lenght; i &lt; len; i ++) &#123;            if(!object[parts[i]]) &#123;                object[parts[i]] = &#123;&#125;;            &#125;            object = object[parts[i]];        &#125;    return object;    &#125;&#125;;// 定义命名空间MyApp.namespace(&quot;Helpers.Parsing&quot;);// 你现在可以使用该命名空间了MyApp.Helpers.Parsing.DateParser = function() &#123;    //做一些事情&#125;;</code></pre><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>另一项开发者用来避<strong>免全局变量的技术就是封装到模块 Module 中</strong>。一个模块就是不需要创建新的全局变量或者命名空间的通用的功能。不要将所有的代码都放一个负责执行任务或者发布接口的函数中。这里以异步模块定义 <code>Asynchronous Module Definition (AMD)</code> 为例</p><pre><code class="js">//定义define( &quot;parsing&quot;, //模块名字        [ &quot;dependency1&quot;, &quot;dependency2&quot; ], // 模块依赖        function( dependency1, dependency2) &#123; //工厂方法            // Instead of creating a namespace AMD modules            // are expected to return their public interface            var Parsing = &#123;&#125;;            Parsing.DateParser = function() &#123;              //do something            &#125;;            return Parsing;        &#125;);// 通过 Require.js 加载模块require([&quot;parsing&quot;], function(Parsing) &#123;    Parsing.DateParser(); // 使用模块&#125;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903490989342728&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之表达式和语句</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/17/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/17/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/</id>
    <published>2020-09-17T09:39:52.000Z</published>
    <updated>2020-09-17T10:19:18.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表达式与语句的区分"><a href="#表达式与语句的区分" class="headerlink" title="表达式与语句的区分"></a>表达式与语句的区分</h1><p>引子：表达式和语句很基础，但是有时会犯错，比如：</p><pre><code class="js">function()&#123;&#125;//报错(function()&#123;&#125;)//不报错function f(x)&#123; return x + 1 &#125;()//报错function f(x)&#123; return x + 1 &#125;(1)//不报错，为什么返回 1</code></pre><p>能明白为什么？</p><ul><li><p>第一行代码：因为<code>JavaScript</code> 将 <code>function</code> 关键字当作一个 <strong>函数声明语句</strong> 的开始，而函数声明语句 <code>function</code> 关键字后面应该是 函数名，这里后面跟圆括号，当然会报错。</p></li><li><p>第二行代码：给它加上一对圆括号，解析器会把()里的当做表达式去解析，在这里就会当做匿名函数表达式解析，所以不会报错。</p></li><li><p>第三行代码：在一条语句后面加上()会被当做分组操作符，分组操作符里必须要有表达式，所以这里报错；</p></li><li><p>第四行代码：在一条函数声明语句后面加上(1)，仅仅是相当于在声明语句之后又跟了一条毫无关系的表达式，等价于下面代码：</p></li></ul><pre><code class="js">function f(x)&#123; return x + 1 &#125;(1)//1</code></pre><p>所以返回了无关紧要的答案；</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="表达式（expression）"><a href="#表达式（expression）" class="headerlink" title="表达式（expression）"></a>表达式（expression）</h3><p>js 中的一个短语，js 解释器会将其计算出一个结果。程序中的常量是最简单的一类表达式。</p><p><strong>变量名也是一种简单的表达式</strong>，它的值就是赋值给变量的值。<br>复杂表达式是由简单表达式组成的。</p><p>比如，数据访问表达式是由一个表示数组的表达式、左方括号、一个整数表达式和右方括号构成。它们所组成的新的表达式的运算结果是该数组的特定位置的元素值。</p><p>同样的，函数调用表达式由一个表示函数对象的表达式和0个或多个参数表达式构成。</p><p>将简单表达式组合成复杂表达式最常用的方法就是使用运算符（opetator）。</p><p>运算符按照特定的运算规则对操作数（通常是两个）进行运算，并计算出新值。</p><p>乘法运算符<code>*</code>是比较简单的例子。表达式<code>x*y</code>是对两个变量表达式x和y进行运算并得出结果。有时我们更愿意说运算符返回了一个值而不是“计算”出了一个值。</p><h3 id="语句（statement）"><a href="#语句（statement）" class="headerlink" title="语句（statement）"></a>语句（statement）</h3><p><strong>js 整句或命令。js 语句是以分号结束；表达式计算出一个值，但语句用来自行以使某件事发生。</strong><br><strong>“使某件事发生”的一个方法是计算带有副作用的表达式。</strong></p><p>诸如赋值和函数调用这些有副作用的表达式，是可以作为单独的语句的，这种把表达式当做语句的用法也称作表达式语句（expression statement）。类似的语句还有声明语句（declaration statement），声明语句用来声明新变量或定义新函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;表达式与语句的区分&quot;&gt;&lt;a href=&quot;#表达式与语句的区分&quot; class=&quot;headerlink&quot; title=&quot;表达式与语句的区分&quot;&gt;&lt;/a&gt;表达式与语句的区分&lt;/h1&gt;&lt;p&gt;引子：表达式和语句很基础，但是有时会犯错，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code cl</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之map,reduce,filter等高阶函数</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/16/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bmap-reduce-filter%E7%AD%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/16/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bmap-reduce-filter%E7%AD%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</id>
    <published>2020-09-16T07:27:16.000Z</published>
    <updated>2020-09-16T08:36:28.605Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">原文地址来自MDN</a><br>跟着写一遍，加强下记录</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>map()</code> 方法<strong>创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值</strong>。</p><pre><code class="js">const array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32]</code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><pre><code class="js">var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array &#125;[, thisArg])</code></pre><p><strong>callback</strong><br>生成新数组元素的函数，使用三个参数：<br><strong>currentValue</strong><br>callback 数组中正在处理的当前元素。<br><strong>index可选</strong><br>callback 数组中正在处理的当前元素的索引。</p><p><strong>array可选</strong><br>map 方法调用的数组。<br>thisArg可选<br>执行 callback 函数时值被用作this。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><blockquote><p>一个由原数组每个元素执行回调函数的结果成的新数组</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通常情况下，<code>map</code> 方法中的 <code>callback</code> 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 <code>map</code> 只给 <code>callback</code> 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。</p><pre><code class="js">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt); // [1,NaN,NaN]</code></pre><p>我们期望输出 <code>[1, 2, 3]</code>, 而实际结果是 <code>[1, NaN, NaN]</code>.</p><p><code>parseInt</code> 经常被带着一个参数使用, 但是这里接受两个。第一个参数是一个表达式而第二个是<code>callback function</code>的基, <code>Array.prototype.map</code> 传递3个参数:</p><ul><li>the element</li><li>the index</li><li>the array</li></ul><pre><code class="js">// parseInt(string, radix) -&gt; map(parseInt(value, index))/*  first iteration (index is 0): */ parseInt(&quot;1&quot;, 0); // 1/* second iteration (index is 1): */ parseInt(&quot;2&quot;, 1); // NaN/*  third iteration (index is 2): */ parseInt(&quot;3&quot;, 2); // NaN</code></pre><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><p><code>filter</code> 为数组中的每个元素<strong>调用一次 callback 函数，并利用所有使得 callback 返回 true 或等价于 true 的值</strong>的元素创建一个新数组。</p><p><strong>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</strong></p><pre><code class="js">const words = [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</code></pre><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><pre><code class="js">var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</code></pre><p><strong>callback</strong><br>用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。它接受以下三个参数：<br>element<br>数组中当前正在处理的元素。<br><strong>index可选</strong><br>正在处理的元素在数组中的索引。<br><strong>array可选</strong><br>调用了 filter 的数组本身。<br><strong>thisArg可选</strong><br>执行 callback 时，用于 this 的值。</p><h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p><p>filter 不会改变原数组，它返回过滤后的新数组。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><pre><code class="js">var fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;grapes&#39;, &#39;mango&#39;, &#39;orange&#39;];/** * Array filters items based on search criteria (query) */function filterItems(query) &#123;  return fruits.filter(function(el) &#123;      return el.toLowerCase().indexOf(query.toLowerCase()) &gt; -1;  &#125;)&#125;console.log(filterItems(&#39;ap&#39;)); // [&#39;apple&#39;, &#39;grapes&#39;]console.log(filterItems(&#39;an&#39;)); // [&#39;banana&#39;, &#39;mango&#39;, &#39;orange&#39;]</code></pre><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><p><code>reduce()</code> 方法对**数组中的每个元素执行一个由您提供的reducer函数(升序执行)**，将其结果汇总为单个返回值。</p><pre><code class="js">const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15</code></pre><blockquote><p>reducer 函数接收4个参数:</p></blockquote><ul><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ul><h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>函数累计处理的结果</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>数组里所有值的和</p><pre><code class="js">var sum = [0, 1, 2, 3].reduce(function (accumulator, currentValue) &#123;  return accumulator + currentValue;&#125;, 0);// 和为 6</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;原文地址来自MDN&lt;/a&gt;&lt;br&gt;跟着写一遍，加强下记录&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之闭包</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/15/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/15/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%AD%E5%8C%85/</id>
    <published>2020-09-15T05:22:11.000Z</published>
    <updated>2020-09-15T05:52:47.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MDN上对闭包的解释是：函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起构成<strong>闭包（closure）</strong>。也就是说，闭包可以<strong>让你从内部函数访问外部函数作用域</strong>。在 JavaScript 中，每当函数被创建，就会<strong>在函数生成时生成闭包</strong>。</p><p>JavaScript中的函数会形成了闭包。 闭包是由<strong>函数以及声明该函数的词法环境组合而成的</strong>。该环境包含了这个闭包创建时作用域内的任何局部变量</p><h2 id="产生闭包"><a href="#产生闭包" class="headerlink" title="产生闭包"></a>产生闭包</h2><p>创建闭包最常见方式，就是在<strong>一个函数内部创建另一个函数</strong>。下面例子中的 <code>closure</code> 就是一个闭包：</p><pre><code class="js">function func()&#123;  var a = 1,b = 2;  function closure()&#123;    return a+b;  &#125;  return closure;&#125;</code></pre><p><strong>闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域</strong>。</p><h2 id="闭包的注意事项"><a href="#闭包的注意事项" class="headerlink" title="闭包的注意事项"></a>闭包的注意事项</h2><blockquote><p>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会<strong>一直保存到闭包不存在为止</strong>。</p></blockquote><pre><code class="js">function makeAdder(x) &#123;  return function(y) &#123;    return x + y;  &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2));  // 7console.log(add10(2)); // 12// 释放对闭包的引用add5 = null;add10 = null;</code></pre><p><code>add5</code> 和 <code>add10</code> 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 <code>add5</code> 的环境中，x 为 5。而在 <code>add10</code> 中，x 则为 10。最后通过 null 释放了 <code>add5</code> 和 <code>add10</code> 对闭包的引用。</p><blockquote><p>在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；<br>如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。</p></blockquote><ul><li>闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。</li></ul><pre><code class="js">function test()&#123;  var arr = [];  for(var i = 0;i &lt; 10;i++)&#123;    arr[i] = function()&#123;      return i;    &#125;;  &#125;  for(var a = 0;a &lt; 10;a++)&#123;    console.log(arr[a]());  &#125;&#125;test(); // 连续打印 10 个 10</code></pre><p>对于上面的情况，如果我们改变代码如下：</p><pre><code class="js">function test()&#123;  var arr = [];  for(let i = 0;i &lt; 10;i++)&#123;  // 仅在这里作出了改动    arr[i] = function()&#123;      return i;    &#125;;  &#125;  for(var a = 0;a &lt; 10;a++)&#123;    console.log(arr[a]());  &#125;&#125;test(); // 打印 0 到 9</code></pre><ul><li>闭包中的 this 对象</li></ul><pre><code class="js">var name = &quot;The Window&quot;;var obj = &#123;  name: &quot;My Object&quot;,  getName: function()&#123;    return function()&#123;      return this.name;    &#125;;  &#125;&#125;;console.log(obj.getName()());  // The Window</code></pre><p><code>obj.getName()()</code>实际上是<strong>在全局作用域中调用了匿名函数，this指向了window</strong>。这里要理解函数名与函数功能（或者称函数值）是分割开的，不要认为函数在哪里，其内部的this就指向哪里。<strong>匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window</strong>。</p><pre><code class="js">var name = &quot;The Window&quot;;var obj = &#123;  name: &quot;My Object&quot;,  getName: function()&#123;    var that = this;    return function()&#123;      return that.name;    &#125;;  &#125;&#125;;console.log(obj.getName()());  // My Object</code></pre><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="应用闭包的主要场合是：设计私有的方法和变量。"><a href="#应用闭包的主要场合是：设计私有的方法和变量。" class="headerlink" title="应用闭包的主要场合是：设计私有的方法和变量。"></a>应用闭包的主要场合是：设计私有的方法和变量。</h3><p>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。私有变量包括函数的参数、局部变量和函数内定义的其他函数。</p><p>把有权访问私有变量的公有方法称为<code>特权方法（privileged method）</code>。</p><pre><code class="js">function Animal()&#123;  // 私有变量  var series = &quot;哺乳动物&quot;;  function run()&#123;    console.log(&quot;Run!!!&quot;);  &#125;  // 特权方法  this.getSeries = function()&#123;    return series;  &#125;;&#125;</code></pre><blockquote><p><code>模块模式（The Module Pattern）</code>：为单例创建私有变量和方法。</p></blockquote><blockquote><p><code>单例（singleton）</code>：指的是只有一个实例的对象。JavaScript 一般以对象字面量的方式来创建一个单例对象。</p></blockquote><pre><code class="js">var singleton = &#123;  name: &quot;percy&quot;,  speak:function()&#123;    console.log(&quot;speaking!!!&quot;);  &#125;,  getName: function()&#123;    return this.name;  &#125;&#125;;</code></pre><p>上面是普通模式创建的单例，下面使用模块模式创建单例：</p><pre><code class="js">var singleton = (function()&#123;  // 私有变量  var age = 22;  var speak = function()&#123;    console.log(&quot;speaking!!!&quot;);  &#125;;  // 特权（或公有）属性和方法  return &#123;    name: &quot;percy&quot;,    getAge: function()&#123;      return age;    &#125;  &#125;;&#125;)();</code></pre><h2 id="匿名函数最大的用途是创建闭包"><a href="#匿名函数最大的用途是创建闭包" class="headerlink" title="匿名函数最大的用途是创建闭包"></a>匿名函数最大的用途是创建闭包</h2><p>并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。</p><pre><code class="js">var objEvent = objEvent || &#123;&#125;;(function()&#123;     var addEvent = function()&#123;       // some code    &#125;;    function removeEvent()&#123;      // some code    &#125;    objEvent.addEvent = addEvent;    objEvent.removeEvent = removeEvent;&#125;)();</code></pre><p>在这段代码中函数 <code>addEvent</code> 和 <code>removeEvent</code> 都是局部变量，但我们可以通过全局变量 <code>objEvent</code> 使用它，这就大大减少了全局变量的使用，增强了网页的安全性</p><h3 id="一个闭包计数器"><a href="#一个闭包计数器" class="headerlink" title="一个闭包计数器"></a>一个闭包计数器</h3><pre><code class="js">var countNumber = (function()&#123;  var num = 0;  return function()&#123;    return ++num;  &#125;;&#125;)();</code></pre><h2 id="闭包的缺陷"><a href="#闭包的缺陷" class="headerlink" title="闭包的缺陷"></a>闭包的缺陷</h2><ul><li>闭包的缺点就是<strong>常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露</strong>。</li><li>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MDN上对闭包的解释是：函数和对其周围状态（&lt;strong&gt;lexical environment，词法环境&lt;/strong&gt;）的引用捆绑在</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习JavaScript应懂得33个概念之函数作用域,块级作用域和词法作用域</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-09-14T07:25:47.000Z</published>
    <updated>2020-09-25T08:11:58.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><blockquote><p>作用域：作用域是程序源代码中定义变量的区域。</p></blockquote><blockquote><p>作用域目的：作用域规定了如何查找、在哪查找变量的规则，也就是确定了当前执行代码对变量的访问权限。</p></blockquote><blockquote><p>作用域（Scope）即代码执行过程中的变量、函数或者对象的可访问区域，作用域决定了变量或者其他资源的可见性</p></blockquote><p><code>ECMAScript6 之前只有全局作用域和函数作用域，let const 之后才有块级作用域</code></p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><blockquote><p>一个变量的作用域 (scope) 是程序源代码中定义这个变量的区域。</p></blockquote><p><strong>注意点</strong> : <strong>在函数体内，局部变量相对于同名全局变量拥有高优先级。</strong></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>函数声明和变量声明总是被 <code>JavaScript</code> 解释器<strong>隐式地提升 (hoist) 到包含他们的作用域的最顶端</strong>。很明显的，语言自身定义和函数形参已经处于作用域顶端, 并被赋值为 <code>undefined</code></p><p>变量赋值不会被提升。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><blockquote><p>函数作用域：变量在声明他们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p></blockquote><p>我的理解就是<strong>函数体的子嵌套函数可以访问父函数体的变量</strong>。这种关系是可以继承的，子嵌套函数可以访问父、爷函数体的变量。</p><pre><code class="js">function ()&#123;  function foo()&#123;    var tom = &#39;Tom&#39;    console.log(tom) // Tom  &#125;  foo()  console.log(tom) // ReferenceError Tom is not defined&#125;test()// 全局var name = &#39;zyc&#39;; // 全局变量function foo() &#123; // 全局变量    console.log(name);&#125;foo(); // zycfunction bar() &#123;    var name = 2;    foo(); // zyc 这里调用全局变量&#125;bar()</code></pre><blockquote><p>JavaScript 函数的执行用到了作用域链，这个作用域链是<strong>在函数定义的时候创建的</strong>。嵌套的函数 <code>f()</code> 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 <code>f()</code> ，这种绑定在执行 <code>f()</code> 时依然有效。</p></blockquote><h2 id="词法作用域-静态作用域"><a href="#词法作用域-静态作用域" class="headerlink" title="词法作用域(静态作用域)"></a>词法作用域(静态作用域)</h2><p>全局变量在程序中始终都是有定义的。局部变量在声明它的函数体内以及所嵌套的函数内始终是有定义的。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当 <code>JavaScript</code> 需要查找变量的值的时候，会从链中的第一个对象开始查找，如果有就会直接使用这个值，如果没有就会继续查找下一个对象，如果链上不存在就会抛出一个引用错误 (ReferenceError)。</p><p>在 <code>JavaScript</code> 的最顶层代码中 (不包含在任何函数定义内的代码)，作用域链是由一个全局对象组成。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块级作用域：在一些类似 c 语言的编程语言中，{ 内的每一段代码都具有各自的作用域，而且变量在声明他们的代码段之外是不可见的。</p><p>块级作用非常严格，就是作用域之外无法访问作用域内的变量。</p><p>ECMAScript5 中规定了 let 和 const 来支持块级作用域(只是效果一样)。</p><p>同时 ECMAScript5 之前 for if switch 是不会产生作用域的</p><p>下面题目的答案是 <code>5</code> </p><pre><code class="js">var a = 5; // 全局变量function todo()&#123;  var a = 9  return function()&#123;      a = 7  &#125;&#125;todo()()console.log(a) // 指向的是window</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作用域：作用域是程序源代码中定义变量的区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之this,call,apply和bind</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bthis-call-apply%E5%92%8Cbind/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bthis-call-apply%E5%92%8Cbind/</id>
    <published>2020-09-14T07:24:55.000Z</published>
    <updated>2020-09-14T09:11:51.320Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/6844903496253177863">原文地址</a></p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>在 ES5 中，其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象</strong></p><blockquote><p>改变 this 的指向我总结有以下几种方法：</p></blockquote><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply、call、bind</code></li><li><code>new关键字</code> 实例化一个对象</li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>箭头函数的 this 始终指向函数定义时的 this</strong>，而非执行时。，箭头函数需要记着这句话：“<strong>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值</strong>，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p><pre><code class="js">var name = &quot;windowsName&quot;;var a = &#123;  name : &quot;Cherry&quot;,  func1: function () &#123;    console.log(this.name)       &#125;,  func2: function () &#123;    setTimeout( () =&gt; &#123;        this.func1()    &#125;,100);  &#125;&#125;;a.func2()     // Cherry</code></pre><h3 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 _this = this</h3><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。</p><h3 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h3><p><code>apply、call、bind</code> 都是可以改变 this 的指向的，但是这三个函数稍有不同。</p><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p></blockquote><blockquote><p> apply 和 call 基本类似，区别是 call 方法接受的是<strong>若干个参数列表</strong>，而 apply 接收的是一个包含<strong>多个参数的数组</strong>。</p></blockquote><blockquote><p>bind()方法<strong>创建一个新的函数</strong>, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><p>bind 是创建一个新的函数，我们必须<strong>要手动去调用</strong>：</p><pre><code class="js">var a =&#123;    name : &quot;Cherry&quot;,    fn : function (a,b) &#123;        console.log( a + b)    &#125;&#125;var b = a.fn;b.bind(a,1,2)()           // 3</code></pre><h2 id="JS-中的函数调用"><a href="#JS-中的函数调用" class="headerlink" title="JS 中的函数调用"></a>JS 中的函数调用</h2><blockquote><p>函数调用的方法一共有 4 种</p></blockquote><ul><li>作为一个函数调用</li><li>函数作为方法调用</li><li>使用构造函数调用函数</li><li>作为函数方法调用函数（call、apply）</li></ul><h3 id="作为一个函数调用"><a href="#作为一个函数调用" class="headerlink" title="作为一个函数调用"></a>作为一个函数调用</h3><pre><code class="js">var name = &quot;windowsName&quot;;function a() &#123;  var name = &quot;Cherry&quot;;  console.log(this.name);          // windowsName  console.log(&quot;inner:&quot; + this);    // inner: Window&#125;a();console.log(&quot;outer:&quot; + this)         // outer: Window</code></pre><h3 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h3><pre><code class="js">var name = &quot;windowsName&quot;;var a = &#123;    name: &quot;Cherry&quot;,    fn : function () &#123;        console.log(this.name);      // Cherry    &#125;&#125;a.fn();</code></pre><h3 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h3><blockquote><p>如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p></blockquote><pre><code class="js">// 构造函数:function myFunction(arg1, arg2) &#123;    this.firstName = arg1;    this.lastName  = arg2;&#125;// This    creates a new objectvar a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);a.lastName;                             // 返回 &quot;Cherry&quot;</code></pre><h3 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h3><blockquote><p>在 JavaScript 中, 函数是对象。<br>JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身<br>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p></blockquote><pre><code class="js">var name = &quot;windowsName&quot;;function fn() &#123;    var name = &#39;Cherry&#39;;    innerFunction();    function innerFunction() &#123;        console.log(this.name);      // windowsName    &#125;&#125;fn()</code></pre><p>这里的 <code>innerFunction()</code> 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的）</p><p><strong>匿名函数的 this 永远指向 window</strong> 匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903496253177863&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;this的指向&quot;&gt;&lt;a href=&quot;#this的指向&quot; class=&quot;headerlink&quot; title=&quot;this的指向&quot;&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之==与===，typeof与intanceof</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B-%E4%B8%8E-%EF%BC%8Ctypeof%E4%B8%8Eintanceof/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B-%E4%B8%8E-%EF%BC%8Ctypeof%E4%B8%8Eintanceof/</id>
    <published>2020-09-14T07:24:08.000Z</published>
    <updated>2020-09-27T08:42:34.480Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过js中判断类型是否相等及检测数据类型的方法，来更深入的了解js的奥秘</p><h2 id="与"><a href="#与" class="headerlink" title="==与==="></a>==与===</h2><ul><li>严格相等比较 (也被称作”strict equality”, “identity”, “triple equals”)，使用 <code>===</code> ,</li><li>抽象相等比较 (“loose equality”，”double equals”) ，使用 <code>==</code></li><li><code>Object.is</code> （ECMAScript 2015/ ES6 新特性）</li></ul><p>简而言之，在比较两件事情时，双等号将执行<strong>类型转换</strong>; 三等号将进行相同的比较，而<strong>不进行类型转换</strong> (如果类型不同, 只是总会返回 false );  而Object.is的行为方式与三等号相同，但是对于<code>NaN和-0和+0</code>进行特殊处理，所以最后两个不相同，而Object.is（NaN，NaN）将为 true。</p><h3 id=""><a href="#" class="headerlink" title="==="></a>===</h3><p>全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等。最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。</p><pre><code class="js">var num = 0;var obj = new String(&quot;0&quot;);var str = &quot;0&quot;;var b = false;console.log(num === num); // trueconsole.log(obj === obj); // trueconsole.log(str === str); // trueconsole.log(num === obj); // falseconsole.log(num === str); // falseconsole.log(obj === str); // falseconsole.log(null === undefined); // falseconsole.log(obj === null); // falseconsole.log(obj === undefined); // false</code></pre><h2 id="-1"><a href="#-1" class="headerlink" title="=="></a>==</h2><p><code>相等操作符</code>比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。在转换后（<strong>等式的一边或两边都可能被转换</strong>），最终的比较方式等同于全等操作符 === 的比较方式。 相等操作符满足交换律。</p><p>相等操作符对于不同类型的值，进行的比较如下图所示：</p><p><img src="https://github.com/ShinichiKudo-FE/PictureBed/blob/master/blogImg/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200914155706.png" alt="非严格相等"></p><pre><code class="js">var num = 0;var obj = new String(&quot;0&quot;);var str = &quot;0&quot;;var b = false;console.log(num == num); // trueconsole.log(obj == obj); // trueconsole.log(str == str); // trueconsole.log(num == obj); // trueconsole.log(num == str); // trueconsole.log(obj == str); // trueconsole.log(null == undefined); // true// both false, except in rare casesconsole.log(obj == null);console.log(obj == undefined)</code></pre><p><img src="https://github.com/ShinichiKudo-FE/PictureBed/blob/master/blogImg/%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89.png" alt="判等"></p><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p><strong>typeof 实现原理</strong></p><p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断<code>number,  string,  object,  boolean,  function, undefined,  symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 <code>object</code> 类型的数据的时候，<code>typeof</code>能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof 在判断一个 <code>object</code>的数据的时候只能告诉我们这个数据是 <code>object</code>, 而不能细致的具体到是哪一种 <code>object</code>, 比如</p><pre><code class="js">let s = new String(&#39;abc&#39;);typeof s === &#39;object&#39;// trues instanceof String // true</code></pre><p>要想判断一个数据具体是哪一种 <code>object</code> 的时候，我们需要利用 <strong><code>instanceof</code></strong> 这个操作符来判断，这个我们后面会说到。</p><p>其实，js 在底层存储变量的时候，会在变量的机器码的低位<code>1-3</code>位存储其类型信息</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li></ul><p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。<br><code>null</code>：所有机器码均为<strong>0</strong><br><code>undefined</code>：用 −2^30 整数来表示</p><p>所以，typeof 在判断 <code>null</code> 的时候就出现问题了，由于 <code>null</code> 的所有机器码均为<strong>0</strong>，因此直接被当做了对象来看待。;</p><p>然而用 <code>instanceof</code> 来判断的话</p><pre><code class="js">null instanceof null // TypeError: Right-hand side of &#39;instanceof&#39; is not an object</code></pre><p><strong>null 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug</strong></p><p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括symbol），避免对 null 的判断。</p><p>还有一个不错的判断类型的方法，就是 **<code>Object.prototype.toString.call</code>**，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p><pre><code class="js">Object.prototype.toString.call(1) // &quot;[object Number]&quot;Object.prototype.toString.call(&#39;hi&#39;) // &quot;[object String]&quot;Object.prototype.toString.call(&#123;a:&#39;hi&#39;&#125;) // &quot;[object Object]&quot;Object.prototype.toString.call([1,&#39;a&#39;]) // &quot;[object Array]&quot;Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;Object.prototype.toString.call(() =&gt; &#123;&#125;) // &quot;[object Function]&quot;Object.prototype.toString.call(null) // &quot;[object Null]&quot;Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;Object.prototype.toString.call(Symbol(1)) // &quot;[object Symbol]&quot;Object.prototype.toString.call(BigInt(9)) // &quot;[object BigInt]&quot;</code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><strong>instanceof</strong> 主要的作用就是判断一个实例是否属于某种类型,也可以判断一个实例是否是其父类型或者祖先类型的实例</p><pre><code class="js">let person = function () &#123;&#125;let nicole = new person()nicole instanceof person // truelet person = function () &#123;&#125;let programmer = function () &#123;&#125;programmer.prototype = new person()let nicole = new programmer()nicole instanceof person // truenicole instanceof programmer // true</code></pre><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><pre><code class="js">function new_instance_of(leftVaule, rightVaule) &#123;     let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值    while (true) &#123;        if (leftVaule === null) &#123;            return false;            &#125;        if (leftVaule === rightProto) &#123;            return true;            &#125;         leftVaule = leftVaule.__proto__     &#125;&#125;</code></pre><p>其实 instanceof 主要的实现原理就是<strong>只要右边变量的 prototype 在左边变量的原型链上</strong>即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过js中判断类型是否相等及检测数据类型的方法</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习javascript应懂得33个概念之隐式，显式，名义和鸭子类型</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/11/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%9A%90%E5%BC%8F%EF%BC%8C%E6%98%BE%E5%BC%8F%EF%BC%8C%E5%90%8D%E4%B9%89%E5%92%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/11/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%9A%90%E5%BC%8F%EF%BC%8C%E6%98%BE%E5%BC%8F%EF%BC%8C%E5%90%8D%E4%B9%89%E5%92%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-09-11T06:12:55.000Z</published>
    <updated>2020-09-27T08:44:19.030Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>javasciprt是属于弱类型的语言。灵活的同时也带来一些问题，有时我们修改一些代码时，看上去是对的，结果出现了我们意想不到的结果。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>在 JavaScript 中，当我们进行比较操作或者加减乘除四则运算操作时，常常会触发 JavaScript 的隐式类型转换机制；而这部分也往往是令人迷惑的地方。譬如浏览器中的 <code>console.log</code> 操作常常会将<strong>任何值都转化为字符串</strong>然后展示，而数学运算则会首先将值<strong>转化为数值类型</strong>（除了 <code>Date</code> 类型对象）然后进行操作。</p><h3 id="关系操作符（-lt-gt-lt-gt-）"><a href="#关系操作符（-lt-gt-lt-gt-）" class="headerlink" title="关系操作符（&lt;, &gt;, &lt;=, &gt;=）"></a>关系操作符（&lt;, &gt;, &lt;=, &gt;=）</h3><p>与上述操作符一样，<code>关系操作符</code>的操作值也可以是任意类型的，所以使用<code>非数值类型</code>参与比较时也需要系统进行<code>隐式类型转换</code>：<br>（1）如果两个操作值都是数值，则进行数值比较<br>（2）如果两个操作值都是字符串，则比较字符串对应的字符编码值<br>（3）如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较<br>（4）如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较<br>（5）如果一个操作值是布尔值，则将其转换为数值，再进行比较<br>注：NaN是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回false。</p><h3 id="相等操作符（-）"><a href="#相等操作符（-）" class="headerlink" title="相等操作符（==）"></a>相等操作符（==）</h3><p><code>相等操作符</code>会对操作值进行隐式转换后进行比较：<br>（1）如果一个操作值为布尔值，则在比较之前先将其转换为数值<br>（2）如果一个操作值为字符串，另一个操作值为数值，则通过Number()函数将字符串转换为数值<br>（3）如果一个操作值是对象，另一个不是，则调用对象的valueOf()方法，得到的结果按照前面的规则进行比较<br>（4）null与undefined是相等的<br>（5）如果一个操作值为NaN，则相等比较返回false<br>（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><pre><code class="js">function Person()&#123;&#125;Person.prototype = &#123;  toString() &#123; return &quot;ooo&quot;;&#125;,  valueOf() &#123; return 123;&#125;&#125;var p = new Person() ;// ️ result in chrome</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/2591556-6e772a8971dd0cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="demo"></p><h3 id="date类型转换出现的问题"><a href="#date类型转换出现的问题" class="headerlink" title="date类型转换出现的问题"></a>date类型转换出现的问题</h3><pre><code class="js">var date = new Date(&quot;1970/1/2 8:00:00&quot;);date.valueOf() ; //console of Chrome : 86400000date.toString(); //console of Chrome : &quot;Fri Jan 02 1970 08:00:00 GMT+0800 (CST)&quot; // &#39;&lt;=&#39; &#39;&lt;&#39; &#39;==&#39; don&#39;t have self-consistentdate &lt;= 86400000 //console of Chrome : truedate &lt;  86400000 //console of Chrome : falsedate == 86400000 //console of Chrome : false // Oh! It&#39;s awesome!//This make sensedate == date.toString() //console of Chrome : truedate &lt;= date.toString() //console of Chrome : false// Oh! It really make sense because 864000 &lt;= &quot;string&quot; is equal to 864000 &lt;= 0</code></pre><p>date 在遇到<code>&#39;&lt;&#39; &#39;&lt;=&#39;</code>的时候会默认转换至<code>.valueOf()</code> ,<br>而它遇到<code> &#39;==&#39;</code> 的时候明明有<code>.valueOf()</code>却还是选择转换为<code> .toString()</code></p><p><a href="https://juejin.im/post/5a7172d9f265da3e3245cbca#heading-6">解决该疑惑可以看</a></p><h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><p>显示的转换数据类型主要通过JS定义的数据转换方法。</p><h3 id="转换为布尔值："><a href="#转换为布尔值：" class="headerlink" title="转换为布尔值："></a>转换为布尔值：</h3><p>Boolean() :将一个值转换为其对应的Boolean值</p><pre><code class="js">var message = “Hello world!”;var messageAsBoolean = Boolean(message)console.log(messageAsBoolean);   //true</code></pre><p>各种数据类型及其对应的转换规则。</p><table><thead><tr><th align="left">数据类型</th><th align="center">转换为true的值</th><th align="right">转换为false的值</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="center">true</td><td align="right">false</td></tr><tr><td align="left">String</td><td align="center">任何非空字符串</td><td align="right">“” (空字符串)</td></tr><tr><td align="left">Number</td><td align="center">任何非零数字值(包括无穷大)</td><td align="right">0和NaN</td></tr></tbody></table><p>Object                     任何对象                                    null</p><p>Underfined                   n/a                                    undefined</p><h3 id="转换为数字："><a href="#转换为数字：" class="headerlink" title="转换为数字："></a>转换为数字：</h3><p>有3个函数可以把非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>。第一个函数，即转型函数<code>Number()</code>可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这三个函数对于同样的输入会返回不同的结果。</p><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的<code>toString()</code>方法，这个方法唯一要做的就是返回相应值的字符串表现。数值、布尔值、对象、和字符串值(没错，每个字符串也都有一个<code>toString()</code>方法，该方法返回字符串的一个副本)都有<code>toString()</code>方法。但<code>null</code>和<code>undefined</code>值没有这个方法。</p><h2 id="动态类型及鸭子类型"><a href="#动态类型及鸭子类型" class="headerlink" title="动态类型及鸭子类型"></a>动态类型及鸭子类型</h2><p>动态类型语言的优点是<strong>编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面</strong>。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。</p><p>动态类型语言的缺点是<strong>无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误</strong>。这好像在商店买了一包牛肉辣条，但是要真正吃到嘴里才知道是不是牛肉味。</p><p>在JavaScript中，当我们对一个变量赋值时，显然不需要考虑它的类型，因此，JavaScript是一门典型的<strong>动态类型</strong>语言</p><p>这一切都建立在<code>鸭子类型（duck typing）</code>的概念上，鸭子类型的通俗说法是：<strong>“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”</strong></p><p><code>鸭子类型</code>指导我们<strong>只关注对象的行为，而不关注对象本身</strong>，也就是关注HAS-A, 而不是IS-A。</p><pre><code class="js">var duck = &#123;      duckSinging: function()&#123;          console.log( &#39;嘎嘎嘎&#39; );      &#125;  &#125;;  var chicken = &#123;      duckSinging: function()&#123;          console.log( &#39;嘎嘎嘎&#39; );      &#125;  &#125;;  var choir = [];    // 合唱团  var joinChoir = function( animal )&#123;      if ( animal &amp;&amp; typeof animal.duckSinging === &#39;function&#39; )&#123;          choir.push( animal );          console.log( &#39;恭喜加入合唱团&#39; );          console.log( &#39;合唱团已有成员数量:&#39; + choir.length );      &#125;  &#125;;  joinChoir( duck );    // 恭喜加入合唱团  joinChoir( chicken );    // 恭喜加入合唱团 </code></pre><p>在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用<code>鸭子类型</code>的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：<strong>“面向接口编程，而不是面向实现编程”</strong>。例如，一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;javasciprt是属于弱类型的语言。灵活的</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之值类型与引用类型</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/10/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/10/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-09-10T02:03:16.000Z</published>
    <updated>2020-09-27T08:44:25.244Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.cnblogs.com/leiting/p/8081413.html#1959818612">原文地址</a></p><p><strong>值类型（基本数据类型）</strong>：字符串（string）、数值（number）、布尔值（boolean）、undefined、null  （这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值）(ECMAScript 2016新增了一种基本数据类型：symbol)、BigInt(ECMAScript 2020新增)</p><p><strong>引用类型</strong>：对象（Object）、数组（Array）、函数（Function）</p><h2 id="值类型与引用类型的区别"><a href="#值类型与引用类型的区别" class="headerlink" title="值类型与引用类型的区别"></a>值类型与引用类型的区别</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>1、<strong>占用空间固定，保存在栈中</strong>（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，<code>基础变量的值是存储在栈中</code>，而引用变量存储在栈中的是指向<code>堆中的数组或者对象的地址</code>，这就是<strong>为何修改引用类型总会影响到其他指向这个地址的引用变量</strong>。）</p><p>2、保存与复制的是值本身</p><p>3、使用<code>typeof</code>检测数据的类型</p><p>4、基本类型数据是值类型</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>1、<strong>占用空间不固定，保存在堆中</strong>（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象<code>依然不会被销毁</code>，只有当一个对象<strong>没有任何引用变量引用它时</strong>，系统的垃圾回收机制才会在核实的时候回收它。）</p><p>2、保存与复制的是<strong>指向对象的一个指针</strong></p><p>3、使用<code>instanceof</code>检测数据类型</p><p>4、使用<code>new()</code>方法构造出的对象是引用型</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><pre><code class="js">// 值类型：Number、string、bollean、undefinedvar a = 100var b = aa = 200console.log(b) // 100 保存与复制的是值本身// 引用类型：对象、数组、函数、null(空指针)// 可以扩展属性var a = &#123;age:20&#125;var b = ab.age = 21 console.log(a.age) // 21 // 利用typeof来区分typeof undefined // undefinedtypeof &#39;abc&#39; // stringtypeof 123 // numbertypeof true // boolean// typeof 区分不出来引用类型（除了函数）typeof &#123;&#125; // objecttypeof [] // objecttypeof null // objecttypeof console.log //function// 用instanceof来区分引用类型// 如果变量是给定引用类型（根据它的原型链来识别）的实例，那么instanceof 操作符就会返回 true。console.log(person instanceof Object); // 变量 person 是 Object 吗？console.log(colors instanceof Array); // 变量 colors 是 Array 吗？console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？</code></pre><h2 id="几方面的区别举例："><a href="#几方面的区别举例：" class="headerlink" title="几方面的区别举例："></a>几方面的区别举例：</h2><p>（1）<strong>动态的属性</strong>： 定义基本类型值和引用类型值的方式是类似的。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法，但是，我们不能给基本类型的值添加属性，只能给引用类型值动态地添加属性，以便将来使用。例如</p><pre><code class="js">var person = new Object(); person.name = &quot;Nicholas&quot;; alert(person.name); //&quot;Nicholas&quot;</code></pre><p>（2）<strong>复制变量值</strong>： 如果从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</p><pre><code class="js">var num1 = 5;var num2 = num1</code></pre><p>上述例子中，num1保存的值是5，当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。此后，<strong>这两个变量可以参与任何操作而不会相互影响</strong>。</p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储<em>在变量对象中的值复制一份放到为新变量分配的空间中</em>。不同的是，这个值的副本<strong>实际上是一个指针，而这个指针指向存储在堆中的一个对象</strong>。复制操作结束后，两个变量实际上引用同一个对象。因此，改变其中一个变量，就会影响另外一个变量：例</p><pre><code class="js">var obj1 = new Object(); var obj2 = obj1; obj1.name = &quot;Nicholas&quot;; alert(obj2.name); //&quot;Nicholas&quot; </code></pre><p>首先，变量 obj1 保存了一个对象的新实例。然后，这个值被复制到了 obj2 中；换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，因为这两个变量引用的都是同一个对象。<br>复制值类型的过程如下图：</p><p><img src="https://img2018.cnblogs.com/blog/1207871/201901/1207871-20190102110222496-978852296.png" alt="复制值类型"></p><p>（3）<strong>传递参数</strong>：在<em>向参数传递基本类型的值时，被传递的值会被复制给一个局部变量</em>（即命名参数，或者用ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p><pre><code class="js">function addTen(num) &#123;  num += 10;  return num; &#125; var count = 20; var result = addTen(count); alert(count); //20，没有变化alert(result); //30 </code></pre><p>在函数内部，参数 num 的值被加上了 10，但这一变化不会影响函数外部的 count 变量。参数num 与变量 count 互不相识，它们仅仅是具有相同的值。</p><pre><code class="js">function setName(obj) &#123;  obj.name = &quot;Nicholas&quot;; &#125; var person = new Object(); setName(person); alert(person.name); //&quot;Nicholas&quot; </code></pre><p>为了证明<strong>对象是按值传递的</strong>，我们再看一看下面这个经过修改的例子：</p><pre><code class="js">function setName(obj) &#123;  obj.name = &quot;Nicholas&quot;;  obj = new Object();  obj.name = &quot;Greg&quot;; &#125; var person = new Object(); setName(person); alert(person.name); //&quot;Nicholas&quot; </code></pre><p>如果 <code>person</code> 是按引用传递的，那么 <code>person</code> 就会自动被修改为指向其 <code>name</code> 属性值为”<code>Greg</code>“的新对象。但是，当接下来再访问 <code>person.name</code> 时，显示的值仍然是”<code>Nicholas</code>“。</p><p>这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p><h2 id="变量计算–强制类型转换"><a href="#变量计算–强制类型转换" class="headerlink" title="变量计算–强制类型转换"></a>变量计算–强制类型转换</h2><pre><code class="js">// 字符串拼接var a = 100 + 10 //100var b = 100 + &#39;10&#39; // &#39;10010&#39;// == 运算符100 == &#39;100&#39; //true0 == &#39;&#39; //truenull == undefined //true//  语句var a = trueif(a)&#123;&#125;var b = 100if(b)&#123;&#125; // 把数字转换为truevar c = &#39;&#39;if(c)&#123;&#125; // 把空字符串转换为false// 逻辑运算console.log(10&amp;&amp;0); // 0 把10转换成trueconsole.log(&#39;&#39; || &#39;abc&#39;); // &#39;abc&#39; 把空字符串转换为falseconsole.log(!window.abc); // window.abc是undefined 把非undefined转换成true//判断一个变量会被当做true还是falsevar a = 100console.log(!!a); // true</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cn</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之原始类型</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/09/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/09/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-09-09T08:16:55.000Z</published>
    <updated>2020-09-10T01:57:14.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">来自MDN</a></p><p>根据最新的ECMAScript的标准定义，<strong>基本类型</strong>（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有7种基本类型：<code>string</code>，<code>number</code>，<code>bigint(ECMCScript 2020新增)</code>，<code>boolean</code>，<code>null</code>，<code>undefined</code>，<code>symbol (ECMAScript 2016新增)</code>。</p><p>多数情况下，<strong>基本类型直接代表了最底层的语言实现</strong>。</p><p><strong>所有基本类型的值都是不可改变的</strong>。但需要注意的是，<em>基本类型本身和一个赋值为基本类型的变量</em>的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p><p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。</p><h2 id="JavaScript-中的基本类型包装对象"><a href="#JavaScript-中的基本类型包装对象" class="headerlink" title="JavaScript 中的基本类型包装对象"></a>JavaScript 中的基本类型包装对象</h2><p>除了<code>null</code>与<code>undefined</code>之外，所有的基本类型都应对应的包装对象</p><blockquote><p><code>Null</code> 类型只有一个值： <code>null</code><br>一个没有被赋值的变量会有个默认值 <code>undefined</code></p></blockquote><ul><li><code>String</code> 为字符串基本类型。<blockquote><p>JavaScript的字符串类型用于表示文本数据</p></blockquote></li></ul><p>不同于类 C 语言，<code>JavaScript</code> 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对<strong>原始字符串的操作来创建新的字符串</strong>。例如：</p><ul><li><p>获取一个字符串的子串可通过选择个别字母或者使用 <code>String.substr()</code>.</p></li><li><p>c两个字符串的连接使用连接操作符 (+) 或者 <code>String.concat()</code>.</p></li><li><p><code>Number</code> 为数值基本类型。</p><blockquote><p>基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。<strong>它并没有为整数给出一种特定的类型</strong>。除了能够表示浮点数外，还有一些带符号的值：<code>+Infinity</code>，<code>-Infinity</code> 和 <code>NaN</code>(非数值，Not-a-Number)</p></blockquote></li><li><p><code>BigInt</code> 为大整数基本类型。</p><blockquote><p><code>BigInt</code>类型是 <code>JavaScript</code> 中的一个基础的数值类型，可以用任意精度表示整数。使用 <code>BigInt</code>，您可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。<code>BigInt</code>是通过在整数末尾附加 n 或调用构造函数来创建的。通过使用常量<code>Number.MAX_SAFE_INTEGER</code>，您可以获得可以用数字递增的最安全的值。通过引入 BigInt，您可以操作超过<code>Number.MAX_SAFE_INTEGER</code>的数字。</p></blockquote></li></ul><p>可以对<code>BigInt</code>使用运算符<code>+、*、-、**和%</code>，就像对数字一样。<code>BigInt</code> 严格来说并不等于一个数字，但它是松散的。</p><p>在将<code>BigInt</code>转换为<code>Boolean</code>时，它的行为类似于一个数字：<code>if、||、&amp;&amp;、Boolean 和!</code>。</p><p><code>BigInt</code>不能与数字互换操作。否则，将抛出<code>TypeError</code>。</p><pre><code class="js">&gt; const x = 2n ** 53n;9007199254740992n&gt; const y = x + 1n; 9007199254740993n</code></pre><ul><li><p><code>Boolean</code> 为布尔基本类型。</p><blockquote><p>布尔表示一个逻辑实体，可以有两个值：true 和 false。</p></blockquote></li><li><p><code>Symbol</code> 为字面量基本类型。</p><blockquote><p>符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值(如下).</p></blockquote></li></ul><p>这个包裹对象的<code>valueOf()</code>方法返回基本类型值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive&quot;&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之调用堆栈</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/08/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/08/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/</id>
    <published>2020-09-08T05:53:13.000Z</published>
    <updated>2020-09-27T08:43:51.205Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://www.oschina.net/translate/how-does-javascript-actually-work-part-1">原文学习地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆栈的概念对于我来说是熟悉又陌生的感觉，之前看过很多相关的文章及写过一些demo可后面用不到后，就慢慢淡忘了，今天要好好理解并记录下</p><h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><p>Google V8引擎是一个比较流行的javascript引擎示例，该引擎包括两个主要组件：</p><ul><li><ol><li>Memory Heap内存堆 — 这是内存分配的地方</li></ol></li><li><ol start="2"><li>call stack调用堆栈 — 这是你代码执行时栈帧存放的位置</li></ol></li></ul><h2 id="RunTime-运行时"><a href="#RunTime-运行时" class="headerlink" title="RunTime 运行时"></a>RunTime 运行时</h2><p><img src="https://static.oschina.net/uploads/space/2017/1213/104047_yNc9_2896879.png" alt="runtime"></p><h2 id="Call-Stack-调用堆栈"><a href="#Call-Stack-调用堆栈" class="headerlink" title="Call Stack 调用堆栈"></a>Call Stack 调用堆栈</h2><p>JavaScript 是一种<strong>单线程编程语言</strong>，这意味着它只有一个 <code>Call Stack</code> 。因此，它一次仅能做一件事。</p><p><code>Call Stack</code> 是一个数据结构，它基本上记录了我们在程序中的所处的位置。如果我们进入一个函数，我们把它放在堆栈的顶部。如果我们从一个函数中返回，我们弹出堆栈的顶部。这是所有的堆栈可以做的东西。</p><p>我们看一个示例：</p><pre><code class="js">function multiply(x,y)&#123;  return x * y&#125;function printSqure(x)&#123;  var s = multiply(x,x)  console.log(s)&#125;printSqure(5)</code></pre><p>当引擎开始执行这个代码时，Call Stack 将会变成空的。之后，执行的步骤如下：</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104147_KJwy_2896879.png" alt="call stack"></p><p>Call Stack 的每个入口被称为 <strong>Stack Frame（栈帧）</strong>。</p><p>这正是在抛出异常时如何构建 <code>stack trace</code> 的方法 - 这基本上是在异常发生时的 <code>Call Stack</code> 的状态。看看下面的代码：</p><pre><code class="js">function foo()&#123;  throw new Error(&#39;SessionStack will help you resolve crashes :)&#39;);&#125;function bar()&#123;  foo()&#125;function start() &#123;  bar();&#125;start();</code></pre><p>如果这是在 Chrome 中执行的（假设这个代码在一个名为 foo.js 的文件中），那么会产生下面的 <code>stack trace</code>:</p><p><code>Blowing the stack</code>—当达到最大调用堆栈大小时，会发生这种情况。这可能会很容易发生，特别是如果你使用递归，而不是非常广泛地测试你的代码。看看这个示例代码：</p><pre><code class="js">function foo() &#123;    foo();&#125;foo();</code></pre><p>当引擎开始执行这个代码时，它首先调用函数“foo”。然而，这个函数是递归的，并且开始调用自己而没有任何终止条件。所以在执行的每个步骤中，同一个函数会一次又一次地添加到调用堆栈中。它看起来像这样：</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104326_4B9u_2896879.png" alt="call stack 递归"></p><p>然而，在某些情况下，调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器通过抛出一个错误（如下所示）来决定采取行动：</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104350_JCtB_2896879.png" alt="max stack"></p><p>在单线程上运行代码可能非常容易，因为你不必处理多线程环境中出现的复杂场景，例如<strong>死锁</strong>。</p><p>但是在单线程上运行也是非常有限的。由于<code>JavaScript</code>只有一个调用堆栈，所以当事情很慢时会发生什么？</p><h2 id="并发与事件循环"><a href="#并发与事件循环" class="headerlink" title="并发与事件循环"></a>并发与事件循环</h2><p>如果在调用堆栈中执行的函数调用需要花费大量时间才能进行处理，会发生什么？ 例如，假设你想在浏览器中使用 <code>JavaScript</code> 进行一些复杂的图像转换。</p><p>你可能会问 - 为什么这会是一个问题？问题是，虽然调用堆栈有要执行的函数，浏览器实际上不能做任何事情 - 它被阻塞了。这意味着浏览器无法渲染，它不能运行任何其他代码，它就是被卡住了。如果你想在你的应用程序中使用流畅的 UI ，这就会产生问题。</p><p>而且这并不是唯一的问题。一旦你的浏览器开始在 Call Stack 中处理过多的任务，它可能会停止响应相当长的时间。大多数浏览器会通过触发错误来采取行动，询问你是否要终止网页。</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104412_G1jc_2896879.png" alt="阻塞"></p><p>所以，这并不是最好的用户体验，对吗？</p><p>那么，我们如何执行大量代码而不阻塞 UI 使得浏览器无法响应？ <strong>解决方案就是异步回调</strong>。</p><p>这将在“ JavaScript 工作原理”教程的第2部分中更详细地解释：<a href="https://www.oschina.net/translate/how-does-javascript-actually-work-part-2">“V8 引擎内部+关于如何编写优化代码的5个技巧”</a>。</p><p>同时，如果你在 JavaScript 应用程序中难以复现和理解问题，请查看 <code>SessionStack</code> 。 <code>SessionStack</code> 会记录你的 Web 应用中的所有东西：所有的 DOM 更改、用户交互、JavaScript 异常、堆栈跟踪、网络请求失败、调试消息等。</p><p>通过 SessionStack ，你可以以视频的方式重现问题，并查看发生在用户身上的所有事情。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然JavaScript是单线程，但Event Loop是javascript的执行机制，可以很好的处理事件，它也分为同步与异步，当为同步时JavaScript的顺序必须一个完成之后才会完成下一个，如果前面出现无限循环后就会出现爆栈，导致后面的无法执行；而异步时又分为宏观任务（script，setTimeout，setInterval）及微观任务（Promise，process.nextTick）进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/translate/how-does-javascript-actually-work-part-1&quot;&gt;原文学习地</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>深入 TypeScript 中的子类型、逆变、协变</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/03/Ts/%E6%B7%B1%E5%85%A5-TypeScript-%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E5%8D%8F%E5%8F%98/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/03/Ts/%E6%B7%B1%E5%85%A5-TypeScript-%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E5%8D%8F%E5%8F%98/</id>
    <published>2020-09-03T07:58:12.000Z</published>
    <updated>2020-09-03T08:49:55.505Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/6855517117778198542">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TypeScript 中有很多地方涉及到子类型 <code>subtype</code>、父类型 <code>supertype</code>、逆变和协变<code>covariance and contravariance</code>的概念，如果搞不清这些概念，那么很可能被报错搞的无从下手，或者在写一些复杂类型的时候看到别人可以这么写，但是不知道为什么他可以生效。</p><h2 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a>子类型</h2><p>比如考虑如下的接口：</p><pre><code class="js">interface Animal &#123;  age: number&#125;interface Dog extends Animal &#123;  bark(): void&#125;</code></pre><p>在这个例子中，<code>Animal</code> 是 <code>Dog</code> 的父类，<code>Dog</code>是<code>Animal</code>的子类型，子类型的属性比父类型更多，更具体。</p><p>在类型系统中，属性更多的类型是子类型。<br>在集合论中，属性更少的集合是子集。</p><p>也就是说，子类型是父类型的超集，而父类型是子类型的子集，这是直觉上容易搞混的一点。<br>记住一个特征，<em>子类型比父类型更加具体</em>，这点很关键。</p><h2 id="可赋值性的assignable"><a href="#可赋值性的assignable" class="headerlink" title="可赋值性的assignable"></a>可赋值性的<font color="red">assignable</font></h2><p><code>assignable</code> 是类型系统中很重要的一个概念，当你把一个变量赋值给另一个变量时，就要检查这两个变量的类型之间是否可以相互赋值。</p><pre><code class="js">let animal: Animallet dog: Doganimal = dog // ✅okdog = animal // ❌error! animal 实例上缺少属性 &#39;bark&#39;</code></pre><p>从这个例子里可以看出，animal 是一个「更宽泛」的类型，它的属性比较少，所以更「具体」的子类型是可以赋值给它的，因为你是知道 animal 上只有 age 这个属性的，你只会去使用这个属性，dog 上拥有 animal 所拥有的一切类型，赋值给 animal 是不会出现类型安全问题的。</p><p>反之，如果 dog = animal，那么后续使用者会期望 dog 上拥有 bark 属性，当他调用了 dog.bark() 就会引发运行时的崩溃。</p><p>从可赋值性角度来说，子类型是可以赋值给父类型的，也就是<code> 父类型变量 = 子类型变量</code> 是安全的，因为子类型上涵盖了父类型所拥有的的一切属性。</p><p>当我初学的时候，我会觉得<code>T extends &#123;&#125;</code> 这样的语句很奇怪，为什么可以 <code>extends</code>一个空类型并且在传递任意类型时都成立呢？当搞明白上面的知识点，这个问题也自然迎刃而解了。</p><h2 id="在函数中的运用"><a href="#在函数中的运用" class="headerlink" title="在函数中的运用"></a>在函数中的运用</h2><p>假设我们有这样的一个函数：</p><pre><code class="js">function c(val:&#123;a:number,b:number&#125;)</code></pre><p>有这样两个变量：</p><pre><code class="js">let val1 = &#123; a: 1 &#125;let val2 = &#123; a: 1, b: 2, c: 3 &#125;</code></pre><p>调用 <code>f(val1)</code> 是会报错的，比较显而易见的来看是因为缺少属性 b，而函数 f 中很可能去访问 b 属性并且做一些操作，比如 <code>b.substr()</code>，这就会导致崩溃。</p><p>换成上面的知识点来看，val1 对应的类型是{ a: number }，它是 { a: number, b: number } 的父类型，调用 <code>f(val1)</code> 其实就相当于把函数定义中的形参 val 赋值成了 val1，把父类型的变量赋值给子类型的变量，这是危险的。</p><p>反之，调用 f(val2) 没有任何问题，因为 val2 的类型是 val类型的子类型，它拥有更多的属性，函数有可能使用的一切属性它都有。</p><p>假设我现在要开发一个 <code>redux</code>，在声明 <code>dispatch</code> 类型的时候，我就可以这样去做：</p><pre><code class="ts">interface Action &#123;  type: string&#125;declare function dispatch&lt;T extends Action&gt;(action: T)</code></pre><p>这样，就约束了传入的参数一定是 Action 的子类型。也就是说，必须有 type，其他的属性有没有，您随意。</p><h2 id="在联合类型中的运用"><a href="#在联合类型中的运用" class="headerlink" title="在联合类型中的运用"></a>在联合类型中的运用</h2><p>学习了以上知识点，再看联合类型的可赋值性，乍一看会比较反直觉， <code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 是 <code>&#39;a&#39; | &#39;b&#39;</code> 的子类型吗？它看起来属性更多诶？其实正相反，<code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 是 <code>&#39;a&#39; | &#39;b&#39;</code> 的父类型。因为<strong>前者比后者更「宽泛」，后者比前者更「具体」</strong>。</p><pre><code class="ts">type Parent = &#39;a&#39; | &#39;b&#39; | &#39;c&#39;type Son = &#39;a&#39; | &#39;b&#39;let parent: Parentlet son: Sonparent = son // ✅okson = parent // ❌error! parent 有可能是 &#39;c&#39;</code></pre><p>这里 son 是可以安全的赋值给 parent 的，因为 son 的所有可能性都被 parent 涵盖了。<br>而反之则不行，parent 太宽泛了，它有可能是 ‘c’，这是 Son 类型 hold 不住的。<br>这个例子看完以后，你应该可以理解为什么 <code>&#39;a&#39; | &#39;b&#39;</code> extends <code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 为 true 了，在书写 <code>conditional types</code>的时候更加灵活的运用吧。</p><h2 id="逆变和协变"><a href="#逆变和协变" class="headerlink" title="逆变和协变"></a>逆变和协变</h2><p>先来段<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">维基百科的定义</a>：</p><blockquote><p>协变与逆变(covariance and contravariance)是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p></blockquote><p>描述的比较晦涩难懂，但是用我们上面的动物类型的例子来解释一波，现在我们还是有 <code>Animal</code> 和 <code>Dog</code> 两个父子类型。</p><h3 id="协变（Covariance）"><a href="#协变（Covariance）" class="headerlink" title="协变（Covariance）"></a>协变（Covariance）</h3><p>那么想象一下，现在我们分别有这两个子类型的数组，他们之间的父子关系应该是怎么样的呢？没错，Animal[] 依然是 Dog[] 的父类型，对于这样的一段代码，把子类型赋值给父类型依然是安全的：</p><pre><code class="js">let animals: Animal[]let dogs: Dog[]animals = dogsanimals[0].age // ✅ok</code></pre><p>转变成数组之后，对于父类型的变量，我们依然只会去 <code>Dog</code> 类型中一定有的那些属性。</p><p>那么，对于 <code>type MakeArray&lt;T&gt; = T[]</code> 这个类型构造器来说，它就是 协变（Covariance） 的。</p><h3 id="逆变（Contravariance）"><a href="#逆变（Contravariance）" class="headerlink" title="逆变（Contravariance）"></a>逆变（Contravariance）</h3><p>有这样两个函数：</p><pre><code class="js">let visitAnimal = (animal: Animal) =&gt; void;let visitDog = (dog: Dog) =&gt; void;</code></pre><p><code>animal = dog</code> 是类型安全的，那么 <code>visitAnimal = visitDog</code> 好像也是可行的？其实不然，想象一下这两个函数的实现：</p><pre><code class="ts">let visitAnimal = (animal: Animal) =&gt; &#123;  animal.age&#125;let visitDog = (dog: Dog) =&gt; &#123;  dog.age  dog.bark()&#125;</code></pre><p>由于 visitDog 的参数期望的是一个更具体的带有 bark 属性的子类型，所以如果 visitAnimal = visitDog 后，我们可能会用一个不带 bark 属性的普通的 animal 类型来传给 visitDog。</p><pre><code class="ts">visitAnimal = visitDoglet animal = &#123; age: 5 &#125;visitAnimal(animal) // ❌</code></pre><p>这会造成运行时错误，<code>animal.bark</code> 根本不存在，去调用这个方法会引发崩溃。<br>但是反过来，<code>visitDog = visitAnimal</code> 却是完全可行的。因为后续调用方会传入一个比 animal 属性更具体的 dog，函数体内部的一切访问都是安全的。</p><p>在对 Animal 和 Dog 类型分别调用如下的类型构造器之后：</p><pre><code class="ts">  type MakeFunction&lt;T&gt; = (arg: T) =&gt; void</code></pre><p>父子类型关系逆转了，这就是 逆变（Contravariance）。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>当然，在 <code>TypeScript</code> 中，由于灵活性等权衡，对于函数参数默认的处理是<code>双向协变</code> 的。也就是既可以 visitAnimal = visitDog，也可以 visitDog = visitAnimal。在开启了 tsconfig 中的 <strong><code>strictFunctionType</code></strong> 后才会严格按照 <code>逆变</code> 来约束赋值关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6855517117778198542&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;T</summary>
      
    
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/categories/Ts/"/>
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>重学React(三)</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%B8%89)/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%B8%89)/</id>
    <published>2020-08-11T09:50:07.000Z</published>
    <updated>2020-09-04T02:18:38.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终于到了期盼已久的HOOK环节了，我最初学react的时候是版本为15.4.2(特地去看了react仓库看了<a href="https://github.com/facebook/react/blob/master/CHANGELOG.md#1562-september-25-2017">更新日志</a>)算是很早的学习，可惜自己学的东西在工作中实践不了，当时也刚参加工作，又推动不了新技术的落地。无奈过段时间就忘了。计算机技术只有不断敲，看了用不到7天内就会忘得差不多了。当时看到class组件的时候觉得帅呆了，因为那时es6正当时，看到很多人都是使用jsx语法，class声明组件等等，觉得自己赶上了好时机。后来情况就是用不到放弃了，虽然用不到但是平时关注一些新的技术，react HOOK 发布时，也看了一些文章，一些大佬也推荐使用hook的语法写react,到了现在版本16.13.1，我才开始真正接触HOOK</p><p>根据官网的介绍：</p><p><Big><strong>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</strong><Big>。</p><blockquote><p>Hook的三个特性</p></blockquote><ul><li>完全可选的</li><li>100%向后兼容的</li><li>现在就用 </li></ul><h2 id="使用Hook的动机"><a href="#使用Hook的动机" class="headerlink" title="使用Hook的动机"></a>使用Hook的动机</h2><p><a href="https://react.docschina.org/docs/hooks-intro.html#motivation">具体介绍</a><br>1.在组件之间复用状态逻辑很难</p><p>2.复杂组件变得难以理解</p><p>3.难以理解的 class</p><h2 id="使用State-Hook"><a href="#使用State-Hook" class="headerlink" title="使用State Hook"></a>使用State Hook</h2><pre><code class="js">// demoimport React, &#123; useState &#125; from &#39;react&#39;;function Example() &#123;  // 声明一个叫 &quot;count&quot; 的 state 变量  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;;// 等价class组件class Example extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      count: 0    &#125;;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;          Click me        &lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><p>在函数组件中，我们没有 this，所以我们不能分配或读取 this.state。</p><h2 id="使用Effect-Hook"><a href="#使用Effect-Hook" class="headerlink" title="使用Effect Hook"></a>使用Effect Hook</h2><p><code>Effect Hook</code> 可以让你在函数组件中执行副作用操作</p><pre><code class="js">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function Example() &#123;  const [count, setCount] = useState(0);  // Similar to componentDidMount and componentDidUpdate:  useEffect(() =&gt; &#123;    // Update the document title using the browser API    document.title = `You clicked $&#123;count&#125; times`;  &#125;);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><p><em>有些副作用可能需要清除，所以需要返回一个函数：</em></p><pre><code class="js">useEffect(() =&gt; &#123;  function handleStatusChange(status) &#123;    setIsOnline(status.isOnline);  &#125;  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);  return () =&gt; &#123;    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);  &#125;;&#125;);</code></pre><p><em>其他的 effect 可能不必清除，所以不需要返回。</em></p><pre><code class="js">useEffect(() =&gt; &#123;  document.title = `You clicked $&#123;count&#125; times`;&#125;);</code></pre><h2 id="Hook的规则"><a href="#Hook的规则" class="headerlink" title="Hook的规则"></a>Hook的规则</h2><p>1.只在最顶层使用 Hook</p><p><strong>不要在循环，条件或嵌套函数中调用 Hook</strong>， 确保总是在你的 React 函数的最顶层调用他们。</p><p>2.只在 React 函数中调用 Hook</p><p><strong>不要在普通的 JavaScript 函数中调用 Hook</strong></p><p>可以在：</p><ul><li>在 React 的函数组件中调用 Hook</li><li>在自定义 Hook 中调用其他 Hook</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><a href="https://react.docschina.org/docs/hooks-faq.html#which-versions-of-react-include-hooks">更多</a></p><p>为什么要在 effect 中返回一个函数？<br><strong>这是 effect 可选的清除机制</strong>。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p>React 何时清除 effect？<br><strong>React 会在组件卸载的时候执行清除操作</strong>。正如之前学到的，effect 在每次渲染的时候都会执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;终于到了期盼已久的HOOK环节了，我最初学react的时候是版本为15.4.2(特地去看了react仓库看了&lt;a href=&quot;https:/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重学React(二)</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%BA%8C)/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%BA%8C)/</id>
    <published>2020-08-11T09:45:34.000Z</published>
    <updated>2020-09-04T02:18:38.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇看了react的核心概念后，大概心里对react的五脏六腑有个形状了，接着看文档中的高级指引部分</p><h2 id="react文档中高级指引部分的重点"><a href="#react文档中高级指引部分的重点" class="headerlink" title="react文档中高级指引部分的重点"></a>react文档中高级指引部分的重点</h2><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>在通过动态 import() 语法。</p><pre><code class="js">import(&quot;./math&quot;).then(math =&gt; &#123;  console.log(math.add(16, 26));&#125;);</code></pre><p><strong>使用React.Lazy</strong></p><p><code>React.lazy</code> 函数能让你像渲染常规组件一样处理动态引入（的组件）</p><pre><code class="js">const OtherComponent = React.lazy(() =&gt; import(&#39;./OtherComponent&#39;));</code></pre><h3 id="context（常用）"><a href="#context（常用）" class="headerlink" title="context（常用）"></a>context（常用）</h3><p>内部的一个组件状态通信的一个方法</p><p>定义：<strong>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法</strong>。</p><p><code>theme-context.js</code></p><pre><code class="js">// 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！export const ThemeContext = React.createContext(&#123;  theme: themes.dark,  toggleTheme: () =&gt; &#123;&#125;,&#125;);</code></pre><p><code>theme-toggler-button.js</code></p><pre><code class="js">// 有两种显示方式&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt;&lt;MyContext.Consumer&gt;  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;&lt;/MyContext.Consumer&gt;</code></pre><pre><code class="js">import &#123;ThemeContext&#125; from &#39;./theme-context&#39;;function ThemeTogglerButton() &#123;  // Theme Toggler 按钮不仅仅只获取 theme 值，它也从 context 中获取到一个 toggleTheme 函数  return (    &lt;ThemeContext.Consumer&gt;      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (        &lt;button          onClick=&#123;toggleTheme&#125;          style=&#123;&#123;backgroundColor: theme.background&#125;&#125;&gt;          Toggle Theme        &lt;/button&gt;      )&#125;    &lt;/ThemeContext.Consumer&gt;  );&#125;export default ThemeTogglerButton;</code></pre><p><code>app.js</code></p><pre><code class="js">import &#123;ThemeContext, themes&#125; from &#39;./theme-context&#39;;import ThemeTogglerButton from &#39;./theme-toggler-button&#39;;class App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.toggleTheme = () =&gt; &#123;      this.setState(state =&gt; (&#123;        theme:          state.theme === themes.dark            ? themes.light            : themes.dark,      &#125;));    &#125;;    // State 也包含了更新函数，因此它会被传递进 context provider。    this.state = &#123;      theme: themes.light,      toggleTheme: this.toggleTheme,    &#125;;  &#125;  render() &#123;    // 整个 state 都被传递进 provider    return (      &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt;        &lt;Content /&gt;      &lt;/ThemeContext.Provider&gt;    );  &#125;&#125;function Content() &#123;  return (    &lt;div&gt;      &lt;ThemeTogglerButton /&gt;    &lt;/div&gt;  );&#125;ReactDOM.render(&lt;App /&gt;, document.root);</code></pre><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><strong>Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧,<code>render prop</code> 是一个用于告知组件需要渲染什么内容的函数 prop。</strong><br>类似vue中的 <code>refs</code>,获取真实dom的属性</p><h3 id="何时使用refs"><a href="#何时使用refs" class="headerlink" title="何时使用refs"></a>何时使用refs</h3><ul><li><ol><li>管理焦点，文本选择或媒体播放。</li></ol></li><li><ol start="2"><li>触发强制动画。</li></ol></li><li><ol start="3"><li>集成第三方 DOM 库。</li></ol></li></ul><h2 id="如何使用refs"><a href="#如何使用refs" class="headerlink" title="如何使用refs"></a>如何使用refs</h2><ol><li>创建Refs</li></ol><pre><code class="js">this.myRef = React.createRef()</code></pre><ol start="2"><li>访问Refs</li></ol><pre><code class="js">const node = this.myRef.current;</code></pre><p><strong>默认情况下，你不能在函数组件上使用 <code>ref</code> 属性，因为它们没有实例,在hook函数中useRef,指向一个DOM元素或class组件</strong></p><h2 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h2><p>指一种在 React 组件之间使用一个值为<strong>函数的 prop</strong>共享代码的简单技术</p><pre><code class="js">&lt;DataProvider render=&#123;data =&gt; (  &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;)&#125;/&gt;</code></pre><h2 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h2><p>有两种方式一种是<code>Flow</code>语法，这个我没有用过。所以重点学习另一种<code>TypeScript</code></p><ol><li>在 <code>Create React App</code> 中使用 TypeScript</li></ol><pre><code class="js">npx create-react-app my-app --template typescript</code></pre><ol start="2"><li>添加相关依赖包</li></ol><pre><code class="js">npm install --save typescript @types/node @types/react @types/react-dom @types/jest//oryarn add typescript @types/node @types/react @types/react-dom @types/jest</code></pre><h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>如果你还是不清楚在某个特殊场景中应该使用哪种组件，那么 这篇关于<a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">受控和非受控输入组件的文章</a> 会很有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇看了react的核心概念后，大概心里对react的五脏六腑有个形状了，接着看文档中的高级指引部分&lt;/p&gt;
&lt;h2 id=&quot;react文</summary>
      
    
    
    
    
  </entry>
  
</feed>
