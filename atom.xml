<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>默默默默燃</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="https://shinichikudo-fe.github.io/atom.xml" rel="self"/>
  
  <link href="https://shinichikudo-fe.github.io/"/>
  <updated>2020-12-23T07:54:28.370Z</updated>
  <id>https://shinichikudo-fe.github.io/</id>
  
  <author>
    <name>张白告丶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈前端CodeReview,埋点和监控</title>
    <link href="https://shinichikudo-fe.github.io/2020/12/23/%E6%9D%82%E6%96%87/CodeReview-%E5%9F%8B%E7%82%B9-%E7%9B%91%E6%8E%A7/"/>
    <id>https://shinichikudo-fe.github.io/2020/12/23/%E6%9D%82%E6%96%87/CodeReview-%E5%9F%8B%E7%82%B9-%E7%9B%91%E6%8E%A7/</id>
    <published>2020-12-23T07:09:49.000Z</published>
    <updated>2020-12-23T07:54:28.370Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.cn/post/6860365929927639047">原文地址(codereview)</a><br><a href="https://juejin.cn/post/6872583452160425997">原文地址(埋点和监控)</a></p><h1 id="代码review"><a href="#代码review" class="headerlink" title="代码review"></a>代码review</h1><h2 id="现状分析和意义"><a href="#现状分析和意义" class="headerlink" title="现状分析和意义"></a>现状分析和意义</h2><p>大多数开发人员，所认知的代码review，就是把代码拿出来给别人看，大家讨论讨论，脑子里面没有特别深刻的概念。</p><p>其实代码review所涉及的东西包括：<code>review的工具、review的规范、review的流程、review的方式、甚至人员参与度、时间把控</code>等等。</p><p>代码review的意义，<strong>当然就是通过流程管理，尽可能的减少线上问题</strong>。对于TL，通过这样的过程管理，能够对项目质量把控。</p><p>当然它也有一定的<strong>缺点</strong>，增加了软件开发的流程，一定程度上降低了效率。（不过这是假设我们的项目都是高质量的，如果项目的质量本身存在问题，等到线上修复的时候，代价会大的多）</p><h2 id="一些软性的见解"><a href="#一些软性的见解" class="headerlink" title="一些软性的见解"></a>一些软性的见解</h2><ul><li>1、代码review的环境塑造</li></ul><p>代码review是一个交流的过程，如果代码写的好，那就是展示自我的平台，向大家分享优秀的实践。<br>如果代码有问题，也没有关系，发现问题，并且解决问题。<br>一般而言，TL在这个过程的态度很重要，如果TL以一个批评的口气来说谁谁谁有问题，那天然的大家会对这件事起反感。<br>如果TL能在这个过程，一直输出一些优秀的思维方式，代码架构方式，其实是给底下人传授经验的过程，大家感觉有收获，自然会喜欢review。<br>特别的要注意态度的问题，人的情绪是非常敏感的，如果团队有人说出类似“这行代码真垃圾”这样的话，TL关注的点一定不能说这个代码的问题，而是团队中的某些人的语气问题了。<br>探讨别人的代码的时候，可以说，这行代码可以怎么怎么实现，表达自己的认知就行了，不要表达特殊（不好）情绪。<br>个人反而非常喜欢赞赏别人，比如代码量多，可以说别人这段时间幸苦了。逻辑复杂，可以说这个确实耗费了不少心力之类的话。</p><ul><li>2、代码review——如何推动</li></ul><p>其实人总是不想把自己的东西暴露出来，类似我写的代码，就是我的东西的感觉。<br>在推动代码review的时候，要从两方面下手，相辅相成。</p><p><strong>一方面是价值宣导，让大家认可这件事，认可代码review的重要性，另一方面是需要一定的强制性，因为这个是团队代码质量的需要，也是公司业务稳定性的</strong>需要。</p><p>依照个人经验，价值观宣导，可以从行业内大厂的做法，以及必要性，甚至团队成员的职业发展上说明，大概率是可以让大家认可的。<br>每次遇到重大问题的时候，其实也是机会，就看我们会不会利用，假如出现线上问题，提出代码review的事情，大家应该会接受。</p><ul><li>3、代码review——不忘初心</li></ul><p>时刻谨记，我们的目的是什么。<br>不要改一行样式代码，就要进行一次review。因为这个东西本身没有什么探讨的价值。<br>一般而言，代码量超过一定量的时候，其业务复杂度，代码的设计都是可以进行探讨的。</p><h2 id="review的规范"><a href="#review的规范" class="headerlink" title="review的规范"></a>review的规范</h2><p>review的规范，应该结合团队具体的情况，举行施行。</p><p>不过还是有一些共性的东西：比如review的要点有那些？review的参与人都有那些？review的粒度是什么？</p><h3 id="review的要点"><a href="#review的要点" class="headerlink" title="review的要点"></a>review的要点</h3><ul><li><p>1、代码格式是否符合规范<br>这一部分包括lint规范、命名规范等。lint规范一般使用工具可以解决，但是命名是否规范需要我们去审查。</p></li><li><p>2、代码的可读性<br>是不是有深层的if else嵌套。<br>是不是有难以理解的函数、或者一个函数过于长。</p></li><li><p>3、边界问题<br>是不是有开发人员没有想到的异常情况，这一般是和具体的业务场景相关。</p></li><li><p>4、代码架构<br>代码的组织方式，是不是有调整的空间。是不是有可复用的代码，提取出来？</p></li></ul><h3 id="参与人员"><a href="#参与人员" class="headerlink" title="参与人员"></a>参与人员</h3><p>如果比较小的团队，比如三四个人，大家做的东西，应该都比较了解，可以全员参与<br>如果比较大型的团队，其实也是按照所熟悉的业务，分为不同的方向，相关人员可以参与reivew。<br>不过具体执行层面，需要具体问题，具体分析。</p><h3 id="review的粒度"><a href="#review的粒度" class="headerlink" title="review的粒度"></a>review的粒度</h3><p>个人认为，一些简单的改动，是不需要代码review的。<br>但是团队成员的管理上，需要一些硬性规定，那么可以把代码量超过500行，算作一个临界点。</p><h3 id="review的工具"><a href="#review的工具" class="headerlink" title="review的工具"></a>review的工具</h3><p>review是一个系统的工程，有参与的人员、有相关规范，一定也有工具。<br>个人实践上，在阿里内部，其实有类似的工具。<br>但是考虑大多数公司可能没有自己确定的工具，那么个人推荐开源工具<a href="http://www.reviewboard.org.cn/">reviewboard</a>。</p><h1 id="什么是一个埋点系统"><a href="#什么是一个埋点系统" class="headerlink" title="什么是一个埋点系统"></a>什么是一个埋点系统</h1><p><strong>埋点系统 = 埋点SDK + 埋点可视化平台 + 埋点接入方式</strong></p><p>埋点SDK，解决的问题，就是埋点的一些通用的功能的实现，比如统计用户的UV、PV等等。它在内部主要通过向埋点服务后台发送相关的数据。它对外暴露一套统一个api，方便我们接入。<br>埋点可视化平台，解决的问题，就是当我这些埋点数据被上报之后，我能看到相关的数据。比如今天的UV、PV是多少，相比昨天的环比增长是多少等等。</p><p>埋点接入方式，这是埋点系统对外开放的能力，一般会需要申请一个appid，这个appid是唯一的，然后每次上报埋点的时候，就知道是哪个项目的数据了。</p><p>更详细一点的：<br>上面的说法比较笼统，比如埋点SDK，定义的更详细一点，本质上它就是一个js文件，这个js文件是由开发商提供的，当然我们也可以做自己的埋点SDK。<br>之所以称之为SDK，还有一层原因，就是SDK基本上是不变的，就和我们开发Vue项目一样，我们需要引入vue.js文件。我们不需要知道vue.js文件怎么实现的，我们只需要知道它提供的api是什么就行。</p><p>SDK内部所做的事情，就是上报数据，所谓的上报数据，无非就是发送一个http请求接口，发送到后台服务器。然后存入数据库中。<br>埋点可视化平台，就是从数据库中，把这些数据读取出来，展示出来而已。更深层次的，无非就是做数据分析，转化率分析之类。</p><h2 id="埋点和监控是两回事"><a href="#埋点和监控是两回事" class="headerlink" title="埋点和监控是两回事"></a>埋点和监控是两回事</h2><p>好多同学把埋点和监控混为一谈，其实在大厂内部，他们完全是不一样的。</p><ul><li><strong>从功能上说:</strong></li></ul><p>监控主要是进行JS错误监控、接口异常监控、页面性能监控、资源加载异常、以及一些自定义的异常。而埋点主要做的事情是数据上报，数据统计，数据分析。</p><ul><li><strong>从使用的角度来说:</strong></li></ul><p>监控能准确的定位到错误，不需要我们在代码中添加额外的东西，只需要引入监控的SDK，就能实现错误的监控。<br>而埋点更多的是业务行为，我们在业务层面，得自己决定，自己想知道什么数据，想要怎么埋点，然后再做什么样的分析，所以我们接入埋点SDK之后，还需要调用埋点的api进行数据上报。</p><p>所以一定要明确，埋点和监控是两回事。</p><h2 id="埋点和监控的实现是有差异的"><a href="#埋点和监控的实现是有差异的" class="headerlink" title="埋点和监控的实现是有差异的"></a>埋点和监控的实现是有差异的</h2><p>这里所说的实现，是<strong>指这个相关的SDK的实现原理</strong>。</p><ul><li><strong>埋点的实现原理是什么？</strong></li></ul><p>埋点的本质是数据上报，那一定离不开这么一些纬度的数据：地理位置、页面路径、浏览器信息、userId、时间戳等等。类似这样的信息，在用户上报的时候，应该都是自动携带的。<br>一些上报的数据，可能会和业务相关，提供的埋点api中，加一条类似业务标识的ID，让相关数据关联起来。</p><ul><li><strong>监控的实现原理是什么？</strong></li></ul><p>其实无非在SDK内部，实现几种异常监控。</p><p>JS错误，可以使用<code>window.onerror</code>的方式监控。</p><p>接口异常，现在的请求一般是<code>fetch或者是ajax请求</code>，我们只需要把他们包装一层，在相应的响应事件中，获取我们的信息，如果返回的不是200的请求，直接上报错误。</p><p>页面性能，主要通过浏览器提供的一个对象来实现，<code>Performance相关的api</code>，它记录了浏览器加载、解析资源的时间占用情况。</p><p>资源加载错误，最简单的方式，可以通过<code>onerror</code>事件来实现。script可以用，img标签都可以用。<br>这些表述，比较笼统，比如js错误里面，关于promise、关于vue的错误，在错误捕获上都需要做补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6860365929927639047&quot;&gt;原文地址(codereview)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="杂文" scheme="https://shinichikudo-fe.github.io/categories/%E6%9D%82%E6%96%87/"/>
    
    
    <category term="CodeReview" scheme="https://shinichikudo-fe.github.io/tags/CodeReview/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL vs Restful Api</title>
    <link href="https://shinichikudo-fe.github.io/2020/11/18/GraphQL/GraphQL-vs-Restful-Api/"/>
    <id>https://shinichikudo-fe.github.io/2020/11/18/GraphQL/GraphQL-vs-Restful-Api/</id>
    <published>2020-11-18T09:07:34.000Z</published>
    <updated>2020-11-19T03:50:42.329Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://cloud.tencent.com/developer/news/572892">原文地址</a></p><h2 id="与传统-REST-API-相比，GraphQL-提供了哪些优势？"><a href="#与传统-REST-API-相比，GraphQL-提供了哪些优势？" class="headerlink" title="与传统 REST API 相比，GraphQL 提供了哪些优势？"></a>与传统 REST API 相比，GraphQL 提供了哪些优势？</h2><p>我们将讨论 GraphQL 的设计原则，比较 GraphQL 与 REST 中的相同请求，并深入探讨 GraphQL 相对其他架构的优点。</p><p>为理解 GraphQL 作为 API 架构的好处，我们要讨论 API 在<code>客户端 - 服务器</code>结构中的作用。<strong>API（应用程序编程接口）是一个中间层，它允许服务器从客户端接收结构化数据请求，并针对请求的数据发送结构化的响应</strong>。设计 API 架构的方法有很多种。</p><p>让我们来研究一下促使 GraphQL 适合现代化 Web 应用程序的重要基本设计原则。</p><h2 id="GraphQL-服务器的设计原则"><a href="#GraphQL-服务器的设计原则" class="headerlink" title="GraphQL 服务器的设计原则"></a>GraphQL 服务器的设计原则</h2><p> 1.<strong>查询为分层结构</strong>，使用将查询与响应数据1对1匹配的分层和嵌套字段格式。查询和响应的形状类似于树，可查询每个项的其他嵌套字段。在 Facebook 的新闻推送中，这种结构允许一个查询返回一个帖子列表、每个特定帖子的评论，以及每个评论的点赞。</p><p> 2.<strong>该结构以产品为中心，关注前端希望如何接收数据，并构建交付所需的运行时</strong>。这使得 Facebook 的新闻推送可通过一次请求从后端获取需要的所有数据，使服务器按照 GraphQL 的规范从不同的端点获取数据。</p><p> 3.<strong>它使用特定于应用程序的类型系统，该系统使开发人员能在执行前确保查询使用了有效类型，并且语法正确</strong>。例如，新闻推送的 GraphQL 模式要求字段“<code>user</code>”必须包含一个字符串，而“<code>likes</code>”必须包含一个数字。如果查询试图添加不同类型的输入，GraphQL 将在执行查询前抛出一个错误。</p><p> 4.<strong>GraphQL 查询是在客户端指定的，因此，客户端确切知道它将以何种格式接收数据</strong>。这意味着，如果前端请求的格式是包含用户名、评论和点赞的 post 数据，那么来自 Facebook 新闻推送的请求会构建在一个对象中，而不是像其他架构那样构建多个单独的数据块。</p><p> 5.<strong>使用 GraphQL 的服务器结构必须是内省的，或者可由 GraphQL 自己查询</strong>。于是才有了像 <a href="https://github.com/graphql/graphiql">GraphiQL</a> 或 <a href="https://www.apollographql.com/docs/apollo-server/testing/graphql-playground/">GraphQL playground</a> 这样的强大工具。这两种工具都可以让 Facebook 开发人员准确地看到在他们的服务器上使用了哪些查询和字段。</p><h2 id="传统的-RESTful-架构"><a href="#传统的-RESTful-架构" class="headerlink" title="传统的 RESTful 架构"></a>传统的 RESTful 架构</h2><p>REST 架构的设计范式侧重于分配 HTTP 请求方法（<code>GET、POST、PUT、PATCH、DELETE</code>）和 URL 端点之间的关系。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-7350649/gmtfcrky41.png?imageView2/2/w/1620" alt="restful"></p><p><strong>在 REST 架构中，方法和端点的每个组合得到不同的封装功能</strong>。如果客户端需要的数据特定端点 / 方法不提供，则可能需要额外请求。从 REST 请求返回的数据格式依赖于端点—不能保证这些数据会按照前端需要的方式进行格式化。为使用来自响应的数据（格式与缺省情况下从端点返回的格式不同），必须在客户端编写数据解析和数据操作。</p><p>接下来，让我们看看 GraphQL 规范与 REST 的不同之处，以及它的优点。这些优点使这个新架构成为特别适合解决客户端和服务器之间数据交付问题的解决方案。</p><h2 id="GraphQL-架构"><a href="#GraphQL-架构" class="headerlink" title="GraphQL 架构"></a>GraphQL 架构</h2><p>与 RESTful API 一样，GraphQL API 设计用于处理 HTTP 请求并对这些请求提供响应。无论如何，这就是相似之处。**REST API 构建在请求方法和端点之间的连接上，而 GraphQL API 被设计为只通过一个端点，始终使用 POST 请求进行查询，其 URL 通常是 <code>yourdomain.com/graphql</code>**。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-7350649/yvuf86kzg2.jpeg?imageView2/2/w/1620" alt="graphql"></p><p>请求到达 GraphQL 端点后，客户端请求的载荷完全在请求体中处理。这个请求体必须遵循 GraphQL 规范，API 必须<strong>有适当的服务器端逻辑来处理这些请求并提供适当的响应</strong>。</p><p>这提供了比 RESTful API 更流畅的客户端体验，后者可能要求客户端针对多个数据块发出多个请求，并在数据返回后进行操作。</p><p>为了阐明 GraphQL 是如何实现这一点的，让我们分解一下 GraphQL 服务器的结构。</p><h2 id="GraphQL-服务器"><a href="#GraphQL-服务器" class="headerlink" title="GraphQL 服务器"></a>GraphQL 服务器</h2><p>启用 GraphQL 逻辑的服务器端逻辑由定义了服务器功能的 <code>Documents</code> 组成。这些 <code>Documents</code> 包含可执行文件和类型系统定义。顾名思义，类型系统定义为每个数据字段定义可接受的类型和格式输入及结果。</p><p>可执行文件包含要处理的可能的操作列表，其中包括操作类型（查询、修改或订阅）、操作名称、要查询或写入的字段和一个选择集，该选择集准确定义了将从操作返回的数据。选择集是 GraphQL 的最大价值所在——它们允许客户端查询特定的数据集并接收包含所请求信息的响应：不多不少。</p><p>有关 GraphQL 规范的结构和语法的更多信息，请参阅 <a href="http://spec.graphql.org/June2018/#sec-Overview">GraphQL 的文档</a>。</p><p>接下来，我们将看下 GraphQL 中查询的结构。</p><h2 id="GraphQL-查询解析"><a href="#GraphQL-查询解析" class="headerlink" title="GraphQL 查询解析"></a>GraphQL 查询解析</h2><p>下面是一个结构化的 GraphQL 查询，用于获取特定书籍的数据，包括作者的姓和名。</p><pre><code class="js">GET /graphql?query=&#123; books(id:12) &#123; authors &#123; firstName, lastName &#125; title, yearPublished, length &#125; &#123;   Query &#123;                 //  operation type  books (id:12) &#123;         //  operation endpoint     authors &#123;            //  requested fields        firstName        lastName     &#125;      title     yearPublished        &#125;  &#125;&#125;</code></pre><p>这一切都可以通过一个查询由 GraphQL 服务器逻辑解析和处理完成。当把它与 REST 架构中相同结构的请求进行比较时，GraphQL 的优势就开始显现出来了。</p><p>让我们看看下面的 REST 请求结构，然后重点讨论其中的一些差异！</p><h2 id="REST-请求解析"><a href="#REST-请求解析" class="headerlink" title="REST 请求解析"></a>REST 请求解析</h2><p>要向 REST API 发出相同的请求，客户端首先需要向能够返回图书数据的端点发送一个请求，并将图书 id 作为参数传入：</p><pre><code class="js">GET /books/12</code></pre><p>这个请求可能会返回一个包含特定图书所有数据的对象，例如：</p><pre><code class="js">&#123;   “title” : “The Hitchhiker&#39;s Guide to the Galaxy”,  “authorID”: 42,  “yearPublished” : 1978,  “length”: 208,  “genre”: “Science Fiction”&#125;</code></pre><p>在我们的例子里，与相同的 GraphQL 查询相比，该响应有两个缺点：</p><ul><li>1.REST 响应包含类似 genre 这样的额外数据，返回的信息超出了我们的需求。</li><li>2.REST 需要再发送一个请求来获得我们实际上正在查找的数据：这个特定作者的所有书籍。</li></ul><p>为了获得这些数据，我们需要使用我们的 <code>authorID</code> 发出一个额外的请求：</p><pre><code class="js">GET /authors/42</code></pre><p>这个请求的响应应该包含我们正在查找的所有数据：</p><pre><code class="js">&#123;   “firstName” : “Douglas”,  “lastName”: “Adams”&#125;</code></pre><p>现在我们已经有了需要的所有书籍和作者数据，响应解析由客户端完成。现在，前端应用程序必须将来自不同端点的数据组合在一起，用于实现期望的功能。总的来说，与 REST API 相比，GraphQL 提供的性能优势可以为前端开发人员带来回报。使用 GraphQL 规范创建服务器可能需要更多的设置以及编写预测性的服务器端逻辑来解析和处理请求。</p><p>虽然 GraphQL 的设置成本可能比传统的 REST 架构要高，但是，更易于维护的代码、健壮的开发工具和精简的客户端查询所带来的好处通常会超过成本。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相同： 都拥有资源这个概念，而且都可以指定资源的身份<br>相同： 都能通过 HTTP GET 和一个 URL 来获取信息<br>相同： 请求的返回值都是 JSON 数据<br>不同： 在 REST 中，你所访问的终端就是所需对象的身份，在 GraphQL 中，对象的身份和获取的方式是独立存在的<br>不同： 在 REST 中，资源的形式和大小是由服务器所决定的。在 GraphQL 中，服务器声明哪些资源可以获得，而客户端会对其所需资源作出请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/news/572892&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;与传统-REST-AP</summary>
      
    
    
    
    <category term="GraphQL" scheme="https://shinichikudo-fe.github.io/categories/GraphQL/"/>
    
    
    <category term="GraphQL" scheme="https://shinichikudo-fe.github.io/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL 基础实践</title>
    <link href="https://shinichikudo-fe.github.io/2020/11/11/GraphQL/GraphQL%20%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/"/>
    <id>https://shinichikudo-fe.github.io/2020/11/11/GraphQL/GraphQL%20%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-11-11T05:18:03.000Z</published>
    <updated>2020-11-11T08:07:34.956Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.im/post/6844903641996869645#heading-19">原文地址</a></p><p><a href="https://ppt.baomitu.com/d/4248c64a#/1">PPT讲解地址</a></p><h1 id="什么是GraphQL"><a href="#什么是GraphQL" class="headerlink" title="什么是GraphQL"></a>什么是GraphQL</h1><p><code>GraphQL</code> 是一款由 Facebook 主导开发的数据查询和操作语言， 写过 SQL 查询的同学可以把它想象成是 SQL 查询语言，但 <code>GraphQL</code> 是给客户端查询数据用的。虽然这让你听起来觉得像是一款数据库软件，但实际上 <code>GraphQL</code> 并不是数据库软件。<strong>你可以将 <code>GraphQL</code> 理解成一个中间件，是连接客户端和数据库之间的一座桥梁，客户端给它一个描述，然后从数据库中组合出符合这段描述的数据返回</strong>。这也意味着 <code>GraphQL</code> 并不关心数据存在什么数据库上。</p><p>同时 GraphQL 也是一套标准，在这个标准下不同平台不同语言有相应的实现。GraphQL 中还设计了一套类型系统，在这个类型系统的约束下，可以获得与 <code>TypeScript</code> 相近的相对安全的开发体验。</p><h2 id="GraphQL-解决了什么问题"><a href="#GraphQL-解决了什么问题" class="headerlink" title="GraphQL 解决了什么问题"></a>GraphQL 解决了什么问题</h2><p>我们先来回顾一下我们已经非常熟悉的 RESTful API 设计。简单的说 RESTful API 主要是使用 URL 的方式表达和定位资源，用 HTTP 动词来描述对这个资源的操作。</p><p>我们以 IMDB 电影信息详情页为例子，看看我们得需要什么样的 API 才能满足 RESTful API 设计的要求。先来看看主页面上都需要什么信息。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzuD8b0MhgbohicKNzDDHlXNjCdTl00r1vryK0nicEnnlHWN5o1ibteyjRQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="imdb demo"></p><p>可以看到页面上由<em>电影基本信息，演员和评分/评论信息组成</em>，按照设计要求，我们需要将这三种资源放在不同 API 之下。首先是电影基本信息，我们有 API <code>/movie/:id</code>，给定一个电影ID返回基本信息数据。</p><p>假装 GET 一下获得一个 JSON 格式的数据：</p><pre><code class="js">&#123;  name: “Manchester by the Sea”,  ratings: “PG-13”,  score: 8.2,  release: “2016”,  actors:[“https://api/movie/1/actor/1/”],  reviews:[“https://api/movie/1/reviews”]&#125;</code></pre><p>这里面包含了我们所需的电影名、分级等信息，以及一种叫做 <code>HyperMedia</code> 的数据，通常是一个 URL，指明了能够获取这个资源的 API 端点地址。如果我们跟着 <code>HyperMedia</code> 指向的连接请求下去，我们就能得到我们页面上所需的所有信息。</p><p><code>GET /api/movue/1/actor/1</code></p><pre><code class="js">&#123;  name: “Ben Affleck”,  dob: “1971-01-26”,  desc: “blablabla”,  movies:[“https://api/movie/1”]&#125;</code></pre><p><code>GET /api/movie/1/reviews</code></p><pre><code class="js">[  &#123;     content: “Its’s as good as…”,     score: 9  &#125;]</code></pre><p>最后根据需要，我们要将所有包含需要信息的 API 端点都请求一遍，<strong>对于移动端来说，发起一个 HTTP 请求还是比较消耗资源的</strong>，特别是在一些网络连接质量不佳的情况下，一下发出多个请求反而会导致不好的体验。</p><p>而且在这样的 API 设计之中，特定资源分布在特定的 API 端点之中，对于后端来说写起来是挺方便的，但对于Web端或者客户端来说并不一定。例如在 Android 或 iOS 客户端上，发版升级了一个很爆炸的功能，同一个API上可能为了支持这个功能而多吐一些数据。但是对于未升级的客户端来说，这些新数据是没有意义的，也造成了一定的资源浪费。如果单单将所有资源整合到一个 API 之中，还有可能会因为整合了无关的数据而导致数据量的增加。</p><p>而 <code>GraphQL</code> 就是为了解决这些问题而来的，<strong>向服务端发送一次描述信息，告知客户端所需的所有数据，数据的控制甚至可以精细到字段</strong>，达到一次请求获取所有所需数据的目的。</p><h2 id="GraphQL-Hello-World"><a href="#GraphQL-Hello-World" class="headerlink" title="GraphQL Hello World"></a>GraphQL Hello World</h2><h3 id="GraphQL-请求体"><a href="#GraphQL-请求体" class="headerlink" title="GraphQL 请求体"></a>GraphQL 请求体</h3><p>我们先来看一下一个 GraphQL 请求长什么样：</p><pre><code class="js">query myQry ($name: String!) &#123;  movie(name: “Manchester”) &#123;    name    desc    ratings  &#125;&#125;</code></pre><p>那么，上面的这个请求描述称为一个 <code>GraphQL</code> 请求体，请求体即用来描述你要从服务器上取什么数据用的。一般请求体由几个部分组成，从里到外了解一下。</p><p>首先是字段，字段请求的是一个数据单元。同时在 <code>GraphQL</code> 中，标量字段是粒度最细的一个数据单元了，同时作为返回 JSON 响应数据中的最后一个字段。也就是说，如果是一个 Object，还必须选择至少其中的一个字段。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzViawDHFfDRibXSlV3o9tLpPTWK9OU42F887H8AIREaAbnj0DUibsQ6dSA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="字段"></p><p>把我们所需要的字段合在一起，我们把它称之为某某的选择集。上面的 <code>name、desc、ratings</code> 合在一起则称之为 <code>movie</code> <code>的选择集，同理，movie</code> 是 <code>myQry</code> 的选择集。需要注意的是，在标量上不能使用选择集这种操作，因为它已经是最后一层了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzhKXezDO26xBpnuyiaX1LP2ich5JvESXXBXJqibg5jc2ckQgjIv7luy8KQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="选择集"></p><p>在 <code>movie</code> 的旁边，<code>name: &quot;Manchester&quot;</code>，这个代表着传入 <code>movie</code> 的参数，参数名为 <code>name</code> 值为<code>Manchester</code>，利用这些参数向服务器表达你所需的数据需要符合什么条件。</p><p>最后我们来到请求体的最外层：</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdz4daRBcWjtx0slTOtNUtkwvyZFEafEqvzyic2CvwGp8qKvJcZ5Bws7Jg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="最外层"></p><ul><li><p><code>操作类型</code>：指定本请求体要对数据做什么操作，类似与 <code>REST</code> 中的 <code>GET POST</code>。<code>GraphQL</code> 中基本操作类型有 <code>query 表示查询，mutation 表示对数据进行操作</code>，例如增删改操作，<code>subscription 订阅操作</code>。</p></li><li><p><code>操作名称</code>：操作名称是个可选的参数，操作名称对整个请求并不产生影响，只是赋予请求体一个名字，可以作为调试的依据。</p></li><li><p><code>变量定义</code>：在 <code>GraphQL</code> 中，声明一个变量使用<code>$</code>符号开头，冒号后面紧跟着变量的传入类型。如果要使用变量，直接引用即可，例如上面的 <code>movie</code> 就可以改写成 <code>movie(name: $name)</code>。</p></li></ul><p>如果上述三者都没有提供，那么这个请求体默认会被视为一个 query 操作。</p><h3 id="请求的结果"><a href="#请求的结果" class="headerlink" title="请求的结果"></a>请求的结果</h3><p>如果我们执行上面的请求体，我们将会得到如下的数据：</p><pre><code class="js">&#123;  &quot;data&quot;: &#123;    &quot;movie&quot;: &#123;      &quot;name&quot;: &quot;Manchester By the Sea&quot;,      &quot;desc&quot;: &quot;A depressed uncle is asked to take care of his teenage nephew after the boy&#39;s father dies. &quot;,      &quot;ratings&quot;: &quot;R&quot;    &#125;  &#125;&#125;</code></pre><p>仔细对比结果和请求体的结构，你会发现，与请求体的结构是完全一致的。也就是说，<strong>请求体的结构也确定了最终返回数据的结构</strong>。</p><h3 id="GraphQL-Server"><a href="#GraphQL-Server" class="headerlink" title="GraphQL Server"></a>GraphQL Server</h3><p>在前面的 <code>REST</code> 举例中，我们请求多个资源有多个 API 端点。在 GraphQL 中，只有一个 API 端点，同样也接受 <code>GET</code> 和 <code>POST</code> 动词，如要操作 <code>mutation</code> 则使用 <code>POST</code> 请求。</p><p>前面还提到 <code>GraphQL</code> 是一套标准，怎么用呢，我们可以借助一些库去解析。例如 Facebook 官方的 <code>GraphQL.js</code>。以及 Meteor 团队开发的 <code>Apollo</code>，同时开发了客户端和服务端，同时也支持流行的 Vue 和 React 框架。调试方面，可以使用 <code>Graphiql</code> 进行调试，得益于 <code>GraphQL</code> 的类型系统和 <code>Schema</code>，我们还可以在 <code>Graphiql</code> 调试中使用自动完成功能。</p><h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><p>前面我们提到，<code>GraphQL</code> 拥有一个类型系统，那么每个字段的类型是怎么约定的呢？答案就在本小节中。在 <code>GraphQL</code> 中，<strong>类型的定义以及查询本身都是通过 <code>Schema</code> 去定义的</strong>。<code>GraphQL</code> 的 <code>Schema</code> 语言全称叫 <code>Schema Definition Language</code>。<code>Schema</code> 本身并不代表你数据库中真实的数据结构，它的定义决定了<strong>这整个端点能干些什么事情，确定了我们能向端点要什么，操作什么</strong>。再次回顾一下前面的请求体，请求体决定了返回数据的结构，而 <code>Schema</code> 的定义决定了端点的能力。</p><p>接下来我们就通过一个一个的例子了解一下 <code>Schema</code>。</p><h3 id="类型系统、标量类型、非空类型、参数"><a href="#类型系统、标量类型、非空类型、参数" class="headerlink" title="类型系统、标量类型、非空类型、参数"></a>类型系统、标量类型、非空类型、参数</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzibIm98cIybzWGqaEHhRI4mCY0icrkn9DnwnK2MKruYib1LCWnib0jjJD1A/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="schema"></p><p>先看右边的 <code>Schema</code>：<code>type</code> 是 GraphQL <code>Schema</code> 中最基本的一个概念，表示一个 GraphQL 对象类型，可以简单地将其理解为 JavaScript 中的一个对象，在 JavaScript 中一个对象可以包含各种 key，在 GraphQL 中，<code>type</code> 里面同样可以包含各种字段（field）,而且字段类型不仅仅可以是标量类型，还可以是 <code>Schema</code> 中定义的其他 <code>type</code>。例如上面的 <code>Schema</code> 中， Query 下的 movie 字段的类型就可以是 Movie。</p><p>在 GraphQL 中，有如下几种标量类型：<code>Int, Float, String, Boolean, ID</code> ，分别表示<code>整型、浮点型、字符串、布尔型以及一个ID类型</code>。ID类型<strong>代表着一个独一无二的标识，ID 类型最终会被转化成String类型，但它必须是独一无二的</strong>，例如 mongodb 中的 _id 字段就可以设置为ID类型。同时这些标量类型可以理解为 JavaScript 中的原始类型，上面的标量类型同样可以对应 JavaScript 中的 <code>Number, Number, String, Boolean, Symbol</code> 。</p><p>通过上面的类型定义，可以看到 <code>GraphQL</code> 中的类型系统起到了很重要的角色。在本例中，Schema 定义了 name 为 String类型，那么你就不能传 Int类型进去，此时会抛出类型不符的错误。同样的，如果传出的 <code>ratings</code> 数据类型不为 <code>String</code>，也同样会抛出类型不符的错误。</p><h3 id="列表（List）、枚举类型（Enum）"><a href="#列表（List）、枚举类型（Enum）" class="headerlink" title="列表（List）、枚举类型（Enum）"></a>列表（List）、枚举类型（Enum）</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzVM5h5I7ibtMbRh9HMGqVAeLfqHUSbArCBYaHUWdET4QfeONw0kO0aeg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><p>如果我们的某个字段返回不止一个标量类型的数据，而是一组，则需要使用List类型声明，在该标量类型两边使用中括号<code>[]</code>包围即可，与 JavaScript 中数组的写法相同，而且返回的数据也将会是数组类型。</p><p>需要注意的是<code>[Movie]!</code>与 <code>[Movie!]</code>两种写法的含义是不同的：<strong>前者表示 <code>movies</code>字段始终返回不可为空但Movie元素可以为空</strong>。<strong>后者表示<code>movies</code>中返回的 Movie 元素不能为空，但 <code>movies</code>字段的返回是可以为空的</strong>。</p><p>你可能在请求体中注意到，<code>genre</code> 参数的值没有被双引号括起来，也不是任何内置类型。看到 <code>Schema</code> 定义，COMEDY是枚举类型MovieTypes中的枚举成员。枚举类型用于声明一组取值常量列表，如果声明了某个参数为某个枚举类型，那么该参数只能传入该枚举类型内限定的常量名。</p><h3 id="传入复杂结构的参数（Input）"><a href="#传入复杂结构的参数（Input）" class="headerlink" title="传入复杂结构的参数（Input）"></a>传入复杂结构的参数（Input）</h3><p>前面的例子中，传入的参数均为标量类型，那么如果我们想传入一个拥有复杂结构的数据该怎么定义呢。答案是使用<strong>关键字input</strong>。其使用方法和type完全一致。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdz7tz9DrrcqantibfXNo5Z2NZ3ymRE51y16Teeawibf5kjuE81HiaqLDibeQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="input"></p><p>根据本例中的 <code>Schema</code> 定义，我们在查询 search时data的参数必须为</p><pre><code class="js">&#123; term: &quot;Deepwater Horizon&quot; &#125;</code></pre><h3 id="别名（Alias）"><a href="#别名（Alias）" class="headerlink" title="别名（Alias）"></a>别名（Alias）</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdz87vwwe8S2CXvu20MPo6UzrDhY1gW3A87xRbicPW7f5DDibLvecSAyK1A/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="alias"></p><p>想象这么一个页面，我要列出两个电影的信息做对比，为了发挥 <code>GraphQL</code> 的优势，我要同时查询这两部电影的信息，在请求体中请求 <code>movie</code> 数据。前面我们说到，请求体决定了返回数据的结构。在数据返回前查出两个 key 为 <code>movie</code> 的数据，合并之后由于 key 重复而只能拿到一条数据。那么在这种情况下我们需要使用别名功能。</p><p>别名即为返回字段使用另一个名字，使用方法也很简单，只需要在请求体的字段前面使用别名<code>:</code>的形式即可，返回的数据将会自动替换为该名称。</p><h3 id="片段（Fragment）、片段解构（Fragment-Spread）"><a href="#片段（Fragment）、片段解构（Fragment-Spread）" class="headerlink" title="片段（Fragment）、片段解构（Fragment Spread）"></a>片段（Fragment）、片段解构（Fragment Spread）</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdz4duFiaoiaB7n6rSXibEqibDwFAaKibGUc2VUm4JkYVCSmqDibdNia4KaZweWA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="片段"></p><p>在上面的例子中，我们需要对比两部电影的数据。如果换作是硬件对比网站，需要查询的硬件数量往往不止两个。此时编写冗余的选择集显得非常的费劲、臃肿以及难维护。为了解决这个问题，我们可以使用片段功能。**<code>GraphQL</code> 允许定义一段公用的选择集，叫片段**。定义片段使用 <code>fragment name on Type</code> 的语法，其中 name为自定义的片段名称，Type为片段来自的类型。</p><p>本例中的请求体的选择集公共部分提取成片段之后为</p><pre><code class="js">fragment movieInfo on Movie &#123;   name   desc&#125;</code></pre><p>在正式使用片段之前，还需要向各位介绍<code>片段解构功能</code>。类似于 JavaScript 的结构。<strong>GraphQL 的片段结构符号将片段内的字段“结构”到选择集中</strong>。</p><p><img src="https://mmbiz.qlogo.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzvOpicOCfiajJPfWgs5LFr4Ujym34VqhZwicMITEOIGiamdNicr1DvbQhNcg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1&retryload=2" alt="片段解构"></p><h3 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h3><p>与其他大多数语言一样，<code>GraphQL</code> 也提供了定义接口的功能。接口指的是 <code>GraphQL</code> 实体类型本身提供字段的集合，定义一组与外部沟通的方式。使用了 <code>implements</code>的类型必须包含接口中定义的字段。</p><pre><code class="js">interface Basic &#123;    name: String!    year: Number!&#125;type Song implements Basic &#123;    name: String!    year: Number!    artist: [String]!&#125;type Video implements Basic &#123;    name: String!    year: Number!    performers: [String]!&#125;Query &#123;    search(term: String!): [Basic]!&#125;</code></pre><p>在本例中，定义了一个<code>Basic</code>接口，<code>Song</code>以及<code>Video</code>类型都要实现该接口的字段。然后在search查询中返回该接口。</p><p><code>searchMedia</code>查询返回一组<code>Basic</code>接口。由于该接口中的字段是所有实现了该接口的类型所共有的，在请求体上可以直接使用。而对于特定类型上的其他非共有字段，例如<code>Video</code>中的performers，直接选取是会有问题的，因为<code>searchMedia</code>在返回的数据中类型可能是所有实现了该接口的类型，而在 <code>Song</code>类型中就没有performers字段。此时我们可以借助内联片段的帮助（下面介绍）</p><h3 id="联合类型（Union）"><a href="#联合类型（Union）" class="headerlink" title="联合类型（Union）"></a>联合类型（Union）</h3><p>联合类型与接口概念差不多相同，不同之处在于联合类型下的类型之间没有定义公共的字段。在 <code>Union</code> 类型中必须使用内联片段的方式查询，原因与上面的接口类型一致。</p><pre><code class="js">union SearchResult = Song | VideoQuery &#123;  search(term: String!): [SearchResult]!&#125;</code></pre><h3 id="内联片段（Inline-Fragment）"><a href="#内联片段（Inline-Fragment）" class="headerlink" title="内联片段（Inline Fragment）"></a>内联片段（Inline Fragment）</h3><p>对接口或联合类型进行查询时，由于返回类型的不同导致选取的字段可能不同，此时需要通过内联片段的方式决定在特定类型下使用特定的选择集。内联选择集的概念和用法与普通片段基本相同，不同的是<strong>内联片段直接声明在选择集内，并且不需要fragment声明</strong>。</p><p>查询接口的例子：</p><pre><code class="js">query &#123;  searchMedia(term: &quot;AJR&quot;) &#123;    name    year    ...on Song &#123;        artist    &#125;    ...on Video &#123;        performers    &#125;  &#125;&#125;</code></pre><p>首选我们需要该接口上的两个公共字段，并且结果为Song类型时选取artist字段，结果为Video类型时选取performers字段</p><h3 id="GraphQL-内置指令"><a href="#GraphQL-内置指令" class="headerlink" title="GraphQL 内置指令"></a>GraphQL 内置指令</h3><p>GraphQL 中内置了两款逻辑指令，指令跟在字段名后使用。</p><h4 id="include"><a href="#include" class="headerlink" title="@include"></a>@include</h4><p>当条件成立时，查询此字段</p><pre><code class="js">query &#123;    search &#123;        actors @include(if: $queryActor) &#123;            name        &#125;    &#125;&#125;</code></pre><h4 id="skip"><a href="#skip" class="headerlink" title="@skip"></a>@skip</h4><p>当条件成立时，不查询此字段</p><pre><code class="js">query &#123;  search &#123;    comments @skip(if: $noComments) &#123;      from    &#125;  &#125;&#125;</code></pre><h2 id="Resolvers"><a href="#Resolvers" class="headerlink" title="Resolvers"></a>Resolvers</h2><p>前面我们已经了解了请求体以及 Schema，那么我们的数据到底怎么来呢？答案是来自 <code>Resolver</code> 函数。</p><p><code>Resolver</code> 的概念非常简单。<code>Resolver</code> 对应着 Schema 上的字段，当请求体查询某个字段时，对应的 <code>Resolver</code> 函数会被执行，由 <code>Resolver</code> 函数负责到数据库中取得数据并返回，最终将请求体中指定的字段返回。</p><pre><code class="js">type Movie &#123;    name    genre&#125;type Query &#123;    movie: Movie!&#125;</code></pre><p>当请求体查询movie时，同名的 <code>Resolver</code> 必须返回Movie类型的数据。当然你还可以单独为name字段使用独立的 <code>Resolver</code> 进行解析。后面的代码例子中将会清楚地了解 <code>Resolver</code></p><h2 id="GraphQL-的优缺点"><a href="#GraphQL-的优缺点" class="headerlink" title="GraphQL 的优缺点"></a>GraphQL 的优缺点</h2><blockquote><p>优点</p></blockquote><ul><li>所见即所得：所写请求体即为最终数据结构</li><li>减少网络请求：复杂数据的获取也可以一次请求完成</li><li>Schema 即文档：定义的 Schema 也规定了请求的规则</li><li>类型检查：严格的类型检查能够消除一定的认为失误</li></ul><blockquote><p>缺点</p></blockquote><ul><li>增加了服务端实现的复杂度：一些业务可能无法迁移使用 GraphQL，虽然可以使用<code>中间件的方式</code>将原业务的请求进行代理，这无疑也将增加复杂度和资源的消耗</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903641996869645#heading-19&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="GraphQL " scheme="https://shinichikudo-fe.github.io/categories/GraphQL/"/>
    
    
    <category term="GraphQL " scheme="https://shinichikudo-fe.github.io/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>Typescript基础及问题汇总</title>
    <link href="https://shinichikudo-fe.github.io/2020/11/02/Ts/Typescript%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://shinichikudo-fe.github.io/2020/11/02/Ts/Typescript%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2020-11-02T02:18:00.000Z</published>
    <updated>2020-11-02T11:33:24.069Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="是否可以将多个js文件合并为1个ts文件？如果是怎么做？"><a href="#是否可以将多个js文件合并为1个ts文件？如果是怎么做？" class="headerlink" title="是否可以将多个js文件合并为1个ts文件？如果是怎么做？"></a>是否可以将多个js文件合并为1个ts文件？如果是怎么做？</h2><p>可以合并为一个文件，为此我们需要添加–outFile[OutputJSFileName]编译选项</p><pre><code class="js">$tsc --outFile common.js file1.ts file2.js file3.js</code></pre><p>上述命令将三个文件合并到common.js文件中</p><h2 id="ts的基础类型都有哪些？与js有哪些区别？"><a href="#ts的基础类型都有哪些？与js有哪些区别？" class="headerlink" title="ts的基础类型都有哪些？与js有哪些区别？"></a>ts的基础类型都有哪些？与js有哪些区别？</h2><p>ts必须指定数据类型，可以分为3种：</p><ul><li>1.js有的类型</li></ul><p>blooean类型，number类型，string类型，null类型，undefined,数组类型</p><ul><li>2.ts特有的类型</li></ul><p>tuple类型（元组类型），emnu类型（枚举类型），any类型（任意类型）</p><ul><li>3.特别的类型</li></ul><p>void类型（没有任何类型）表示定义方法没有返回值</p><p>never类型：是undefind,null的子类型，表示从不会出现的值，这意味着声明never变量只能被never类型所赋值</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>1.定义数组的方式</p><pre><code class="ts">let arr1:number[] = [1,2,3,4,5]let arr2:Array[number] = [1,2,3,4,5]let arr3:[number,string] = [1,2,3,4,5]</code></pre><p>2.定义emnu枚举类型方法</p><pre><code class="ts">emnu flag&#123;success=1,error=2&#125;let s:flag = flag.successconsole.log(s)</code></pre><p>3.定义any任意类型方法</p><pre><code class="ts">let num1:any:truenum1 = true</code></pre><p>4.undefined类型</p><pre><code class="ts">let num2 =  number | undefinedconsole.log(num2)</code></pre><p>5.vold类型，函数没有返回值</p><pre><code class="ts">function run():void &#123;  console.log(&#39;run&#39;)&#125;</code></pre><p>6.never类型定义方法</p><pre><code class="ts">let c:never;c = (()=&gt;&#123;  throw new Error(&#39;error&#39;)&#125;)</code></pre><h2 id="ts为什么会流行？与ECMA新规范的关系？"><a href="#ts为什么会流行？与ECMA新规范的关系？" class="headerlink" title="ts为什么会流行？与ECMA新规范的关系？"></a>ts为什么会流行？与ECMA新规范的关系？</h2><ul><li>TypeScript快速、简单，最重要的是，容易学习。</li><li>TypeScript支持面向对象的编程特性，比如类、接口、继承、泛型等等。</li><li>TypeScript在编译时提供了错误检查功能。它将编译代码，如果发现任何错误，它将在运行脚本之前突出显示这些错误。</li><li>TypeScript支持所有JavaScript库，因为它是JavaScript的超集。</li><li>TypeScript通过使用继承来支持可重用性。</li><li>TypeScript使应用程序开发尽可能的快速和简单，并且TypeScript的工具支持为我们提供了自动完成、类型检查和源文档。</li><li>TypeScript支持最新的JavaScript特性，包括ECMAScript 2015。</li><li>TypeScript提供了ES6的所有优点和更高的生产力。</li><li>TypeScript支持静态类型、强类型、模块、可选参数等。</li></ul><h2 id="tslint都能配置哪些功能？对开发流程有何影响？"><a href="#tslint都能配置哪些功能？对开发流程有何影响？" class="headerlink" title="tslint都能配置哪些功能？对开发流程有何影响？"></a>tslint都能配置哪些功能？对开发流程有何影响？</h2><h2 id="如何使用ts实现类型约束，枚举等特性？"><a href="#如何使用ts实现类型约束，枚举等特性？" class="headerlink" title="如何使用ts实现类型约束，枚举等特性？"></a>如何使用ts实现类型约束，枚举等特性？</h2><h2 id="如何理解接口，泛型"><a href="#如何理解接口，泛型" class="headerlink" title="如何理解接口，泛型?"></a>如何理解接口，泛型?</h2><h2 id="和JS的区别"><a href="#和JS的区别" class="headerlink" title="和JS的区别"></a>和JS的区别</h2><p><img src="https://img-blog.csdnimg.cn/20201019091205642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODMyOA==,size_16,color_FFFFFF,t_70#pic_center" alt="区别"></p><h2 id="TS的接口"><a href="#TS的接口" class="headerlink" title="TS的接口"></a>TS的接口</h2><p>接口是在我们的应用程序中充当契约的结构。它定义了要遵循的类的语法，这意味着实现接口的类必须实现它的所有成员。它不能被实例化，但是可以被实现它的类对象引用。无论对象是否具有特定的结构，TypeScript编译器都使用接口进行类型检查</p><pre><code class="js">interface name&#123;  // 字段声明  // 方法声明&#125;</code></pre><p>接口只是声明方法和字段，它不能用来建造任何东西。不需要将接口转换为<code>JavaScript</code>来执行，它们对运行时<code>JavaScript</code>没有任何影响。因此，它们的唯一目的是在开发阶段提供帮助。</p><h2 id="你如何理解Typescript中的类？列出类的一些特性。"><a href="#你如何理解Typescript中的类？列出类的一些特性。" class="headerlink" title="你如何理解Typescript中的类？列出类的一些特性。"></a>你如何理解Typescript中的类？列出类的一些特性。</h2><p><code>TypeScript</code>是一种面向对象的<code>JavaScript</code>语言，支持OOP编程特性，比如类、接口等。与Java一样，类是用于创建可重用组件的基本实体。它是一组具有公共属性的对象。类是创建对象的模板或蓝图。它是一个逻辑实体。“class”关键字用于在<code>Typescript</code>中声明一个类。</p><pre><code class="js">class Student &#123;      studCode: number;      studName: string;      constructor(code: number, name: string) &#123;        this.studName = name;        this.studCode = code;      &#125;      getGrade() : string &#123;        return &quot;A+&quot; ;      &#125;    &#125;    </code></pre><p>类的特征是：</p><p>继承，封装，多态性，抽象</p><ul><li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</li><li>对象（Object）：类的实例，通过 new 生成</li><li>面向对象（OOP）的三大特性：封装、继承、多态</li><li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li><li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li><li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat还是 Dog，就可以直接调用 eat方法，程序会自动判断出来应该如何执行 eat</li><li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li><li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。<br>比如 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li><li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li><li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li><li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承可以通过使用<code>extend</code>关键字来实现。</p><pre><code class="js">class Shape &#123;        Area:number        constructor(area:number) &#123;           this.Area = area       &#125;     &#125;     class Circle extends Shape &#123;        display():void &#123;           console.log(&quot;圆的面积: &quot;+this.Area)        &#125;     &#125;    var obj = new Circle(320);     obj.display()  </code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在模块中声明的变量、函数、类和接口不能在模块外部直接访问。</p><pre><code class="js">//可以使用export关键字创建模块，也可以在其他模块中使用import关键字。module module_name&#123;    class xyz&#123;      export sum(x, y)&#123;        return x+y;      &#125;    &#125;  &#125;  </code></pre><p><img src="https://img-blog.csdnimg.cn/20201019093902395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODMyOA==,size_16,color_FFFFFF,t_70#pic_center" alt="模块"></p><p>“内部模块”现在称做“<code>命名空间</code>”。<br>“外部模块”现在则简称为“模块”模块在其自身的作用域里执行，而不是在全局作用域里;</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><pre><code class="js">/** * 新建一个db.ts 将数据库方法封装并且暴露出来 * 暴露一个获取数据的方法 */export function getData():any[]&#123;  return [      &#123;          name:&#39;123&#39;,          ahe:20      &#125;,      &#123;          name:&#39;123425&#39;,          age:30      &#125;  ]&#125;export function saveData():boolean&#123;    console.log(&#39;保存数据成功！&#39;)    return true;&#125;/** * 在index.ts文件中引入 * 在这里引入我暴露的函数 */import &#123;getData&#125; from &#39;./modules/db&#39;console.log(getData());saveData();</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code class="js">/** * 暴露一个获取数据的方法 */function getData():any[]&#123;  return [    &#123;        name:&#39;123&#39;,        ahe:20    &#125;,    &#123;        name:&#39;123425&#39;,        age:30    &#125;  ]&#125;function saveData():boolean&#123;    console.log(&#39;保存数据成功！&#39;)    return true;&#125;export &#123;getData, saveData&#125;/** * 在index.ts文件中引入 * 在这里引入我暴露的函数 */import &#123;getData&#125; from &#39;./modules/db&#39;console.log(getData());saveData();</code></pre><h3 id="命名空间："><a href="#命名空间：" class="headerlink" title="命名空间："></a>命名空间：</h3><p>它封装了共享某些关系的特性和对象。名称空间也称为内部模块。名称空间还可以包括接口、类、函数和变量，以支持一组相关功能。<br><strong>注意</strong>: 名称空间可以在多个文件中定义，并允许将每个文件都定义在一个地方。它使代码更容易维护。</p><pre><code class="ts">namespace &lt;namespace_name&gt; &#123;      export interface I1 &#123; &#125;      export class c1&#123; &#125;    &#125;    </code></pre><h2 id="TypeScript是如何在函数中支持可选参数的？"><a href="#TypeScript是如何在函数中支持可选参数的？" class="headerlink" title="TypeScript是如何在函数中支持可选参数的？"></a>TypeScript是如何在函数中支持可选参数的？</h2><p>我们可以通过使用问号符号(‘?’)来使用可选参数。这意味着可以或不可以接收值的参数可以附加一个”?”可选的。</p><pre><code class="js">function Demo(arg1: number, arg2? :number) &#123;              &#125;</code></pre><p>因此，<code>arg1</code>总是必需的，而<code>arg2</code>是一个可选参数要放后面。<br>注意: 可选参数必须遵循要求的参数。如果我们想让<code>arg1</code>成为可选的，而不是arg2，那么我们需要改变顺序，<code>arg1</code>必须放在<code>arg2</code>之后。</p><pre><code class="js">function Demo(arg2: number, arg1? :number) &#123;  &#125;  </code></pre><h2 id="什么是TypeScript-Declare关键字"><a href="#什么是TypeScript-Declare关键字" class="headerlink" title="什么是TypeScript Declare关键字?"></a>什么是TypeScript Declare关键字?</h2><p>我们知道所有的<code>JavaScript</code>库/框架都没有<code>TypeScript</code>声明文件，但是我们希望在<code>TypeScript</code>文件中使用它们时不会出现编译错误。为此，我们使用<code>declare</code>关键字。在我们希望定义可能存在于其他地方的变量的环境声明和方法中，可以使用<code>declare</code>关键字。</p><p>例如，假设我们有一个名为myLibrary的库，它没有<code>TypeScript</code>声明文件，在全局命名空间中有一个名为myLibrary的命名空间。如果我们想在TypeScript代码中使用这个库，我们可以使用以下代码:</p><pre><code class="ts">declare var myLibrary;</code></pre><h2 id="解释TypeScript中的泛型？"><a href="#解释TypeScript中的泛型？" class="headerlink" title="解释TypeScript中的泛型？"></a>解释TypeScript中的泛型？</h2><p><code>TypeScript</code>泛型是一个提供创建可重用组件方法的工具。它能够创建可以处理多种数据类型而不是单一数据类型的组件。泛型在不影响性能或生产率的情况下提供类型安全性。泛型允许我们创建泛型类、泛型函数、泛型方法和泛型接口。</p><p>在泛型中，类型参数写<code>在开(&lt;)和闭(&gt;)</code>括号之间，这使得它是强类型集合。泛型使用一种特殊类型的类型变量，它表示类型。泛型集合只包含类似类型的对象。</p><pre><code class="ts">function identity&lt;T&gt;(arg: T): T &#123;          return arg;      &#125;      let output1 = identity&lt;string&gt;(&quot;myString&quot;);      let output2 = identity&lt;number&gt;( 100 );    console.log(output1);    console.log(output2);     </code></pre><h2 id="TS的“接口”和“type”语句有什么区别？"><a href="#TS的“接口”和“type”语句有什么区别？" class="headerlink" title="TS的“接口”和“type”语句有什么区别？"></a>TS的“接口”和“type”语句有什么区别？</h2><pre><code class="ts">interface X &#123;      a: number      b: string  &#125;  type X = &#123;      a: number      b: string  &#125;;  </code></pre><p><img src="https://img-blog.csdnimg.cn/20201019100145600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODMyOA==,size_16,color_FFFFFF,t_70#pic_center" alt="type与interface"></p><h2 id="什么是TypeScript中的类型断言？"><a href="#什么是TypeScript中的类型断言？" class="headerlink" title="什么是TypeScript中的类型断言？"></a>什么是TypeScript中的类型断言？</h2><p>类型断言的工作方式类似于其他语言中的类型转换，但是它不像其他语言一样执行C＃和Java那样的类型检查或数据重组。类型转换附带运行时支持，而类型断言对运行时没有影响。但是，类型断言仅由编译器使用，并向编译器提供有关我们希望如何分析代码的提示。</p><pre><code class="ts">let empCode: any = 111;     let employeeCode = &lt;number&gt; code;     console.log(typeof(employeeCode)); // : number  </code></pre><p>例将 something 断言成 string</p><pre><code class="ts">function getLength(something: string | number): number &#123;  if ((&lt;string&gt;something).length) &#123;      return (&lt;string&gt;something).length;  &#125; else &#123;      return something.toString().length;  &#125;&#125;</code></pre><h2 id="TypeScript的as语法是什么？"><a href="#TypeScript的as语法是什么？" class="headerlink" title="TypeScript的as语法是什么？"></a>TypeScript的as语法是什么？</h2><p>as是TypeScript中类型断言的附加语法，引入as-语法的原因是<strong>原始语法()与JSX冲突</strong>。</p><pre><code class="js">let empCode: any = 111;     let employeeCode = code as number;   </code></pre><p>当使用带有JSX的TypeScript时，只允许as风格的断言。</p><h2 id="什么是JSX？我们可以在TypeScript中使用JSX吗？"><a href="#什么是JSX？我们可以在TypeScript中使用JSX吗？" class="headerlink" title="什么是JSX？我们可以在TypeScript中使用JSX吗？"></a>什么是JSX？我们可以在TypeScript中使用JSX吗？</h2><p>JSX只不过是带有不同扩展名的Javascript。Facebook提出了这个新的扩展，以便与JavaScript中类似xml的HTML实现区分开来。</p><p>JSX是一种可嵌入的类似xml的语法。它将被转换成有效的JavaScript。JSX随着React框架而流行起来。TypeScript支持嵌入、类型检查和直接将JSX编译成JavaScript。</p><p>要使用JSX，我们必须做两件事。</p><p><code>使用.tsx扩展名命名文件</code><br><code>启用jsx选项</code></p><h2 id="什么是Rest参数？"><a href="#什么是Rest参数？" class="headerlink" title="什么是Rest参数？"></a>什么是Rest参数？</h2><p>rest参数用于向函数传递零个或多个值。它是通过在参数前加上三个点字符(‘…’)来声明的。它允许函数在不使用arguments对象的情况下拥有可变数量的参数。当我们有不确定数量的参数时，这是非常有用的。</p><p>rest参数要遵循的规则:</p><ol><li>一个函数中只允许有一个rest参数。</li><li>它必须是数组类型。</li><li>它必须是参数列表中的最后一个参数。</li></ol><pre><code class="js">function sum(a: number, ...b: number[]): number &#123;     let result = a;     for (var i = 0; i &lt; b.length; i++) &#123;     result += b[i];     &#125;     console.log(result);    &#125;    let result1 = sum(3, 5);    let result2 = sum(3, 5, 7, 9);   </code></pre><h2 id="解释TypeScript的Enum枚举类型？"><a href="#解释TypeScript的Enum枚举类型？" class="headerlink" title="解释TypeScript的Enum枚举类型？"></a>解释TypeScript的Enum枚举类型？</h2><p>枚举或枚举是一种数据类型，允许我们定义一组命名常量。使用枚举可以更容易地记录意图，或者创建一组不同的案例。它是相关值的集合，可以是数值或字符串值。</p><pre><code class="js">enum Gender &#123;    Male,    Female    Other  &#125;  console.log(Gender.Female); // : 1  // 我们还可以通过enum值的number值来访问它console.log(Gender[1]); // : Female</code></pre><h2 id="解释相对模块和非相对模块的导入"><a href="#解释相对模块和非相对模块的导入" class="headerlink" title="解释相对模块和非相对模块的导入"></a>解释相对模块和非相对模块的导入</h2><ul><li>非相对</li><li>非相对导入可以相对于baseUrl解析，也可以通过路径映射解析。换句话说，我们在导入任何外部依赖项时使用非相对路径。 例子:</li></ul><pre><code class="js"> import * as $ from “jquery”;  import &#123; Component &#125; from “@angular/core”;</code></pre><ul><li>相对</li><li>相对导入可以用于我们自己的模块，这些模块保证在运行时维护它们的相对位置。相对导入以/、./或…/开头。 例子:</li></ul><pre><code class="js"> import Entry from “./components/Entry”;  import &#123;DefaultHeaders&#125; from “../constants/http”;</code></pre><h2 id="什么是匿名函数？"><a href="#什么是匿名函数？" class="headerlink" title="什么是匿名函数？"></a>什么是匿名函数？</h2><p>匿名函数是声明时没有任何命名标识符的函数。这些函数是在运行时动态声明的。与标准函数一样，匿名函数可以接受输入和返回输出。匿名函数在初始创建之后通常是不可访问的。</p><pre><code class="js">let myAdd = function(x: number, y: number): number &#123;       return x + y;   &#125;;  console.log(myAdd())  </code></pre><h2 id="什么是声明合并？"><a href="#什么是声明合并？" class="headerlink" title="什么是声明合并？"></a>什么是声明合并？</h2><p><code>声明合并</code>是编译器随后合并两个或多个独立声明的过程。将具有相同名称的声明声明为单个定义。这个合并的定义具有两个原始声明的特性。</p><p>最简单也是最常见的声明合并类型是接口合并。在最基本的层次上，merge将两个声明的成员机械地连接到一个具有相同名称的接口中</p><pre><code class="js">interface Cloner &#123;      clone(animal: Animal): Animal;  &#125;  interface Cloner &#123;      clone(animal: Sheep): Sheep;  &#125;  interface Cloner &#123;      clone(animal: Dog): Dog;      clone(animal: Cat): Cat;  &#125;  // 这三个接口将合并为一个单独的声明interface Cloner &#123;    clone(animal: Dog): Dog;    clone(animal: Cat): Cat;    clone(animal: Sheep): Sheep;    clone(animal: Animal): Animal;  &#125;  </code></pre><p>注: 在TypeScript中不是所有的合并都允许。目前，类不能与其他类或变量合并。</p><h2 id="TypeScript中的方法重写是什么"><a href="#TypeScript中的方法重写是什么" class="headerlink" title="TypeScript中的方法重写是什么?"></a>TypeScript中的方法重写是什么?</h2><p>如果子类(子类)具有与父类中声明的相同的方法，则称为方法覆盖。换句话说，在派生类或子类中重新定义基类方法。</p><p>方法重写的规则:</p><ol><li>该方法必须具有与父类相同的名称</li><li>该方法必须具有与父类相同的参数。</li><li>必须有一个IS-A关系(继承)。</li></ol><pre><code class="js">class NewPrinter extends Printer &#123;      doPrint(): any &#123;          super.doPrint();          console.log(&quot;Called Child class.&quot;);      &#125;      doInkJetPrint(): any &#123;          console.log(&quot;Called doInkJetPrint().&quot;);      &#125;  &#125;  let printer: new () =&gt; NewPrinter;  printer.doPrint();  printer.doInkJetPrint();  </code></pre><h2 id="Lambda-箭头函数是什么？"><a href="#Lambda-箭头函数是什么？" class="headerlink" title="Lambda/箭头函数是什么？"></a>Lambda/箭头函数是什么？</h2><p>ES6版本的<code>TypeScript</code>提供了定义匿名函数的简写语法，也就是用于函数表达式。<br>这些箭头函数也称为<code>Lambda</code>函数。<code>lambda</code>函数是没有名称的函数，箭头函数省略了<code>function</code>关键字。</p><pre><code class="js">let sum = (a: number, b: number): number =&gt; &#123;      return a + b;    &#125;    console.log(sum(20, 30)); //returns 50    </code></pre><p>在上面，<code>?=&gt;?</code>是一个lambda操作符，(a + b)是函数的主体，(a: number, b: number)是内联参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;是否可以将多个js文件合并为1个ts文件？如果是怎么做？&quot;&gt;&lt;a href=&quot;#是否可以将多个js文件合并为1个ts文件？如果是怎么做？&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/categories/Ts/"/>
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之DOM树和渲染过程</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/30/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BDOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/30/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BDOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</id>
    <published>2020-09-30T01:15:38.000Z</published>
    <updated>2020-09-30T02:18:26.765Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><p>平时中因为有各个框架的API使用，使我们对DOM的操作，慢慢变得淡忘，但是我们要知道的是各个框架也是操作dom的，只是将方法暴露出来，方便我们使用。通过学习DOM操作，加深对Javascript的理解</p><p>DOM操作并没有你想象的那么难。</p><p><img src="https://user-gold-cdn.xitu.io/2016/11/29/8d195c29c5f16f86e390d4c6f26084da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dom操作"></p><h3 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h3><p>让我们开始创建HTML元素，为了创建元素，你需要用<code>document.createElement(tagName) </code>方法：</p><pre><code class="js">const h1 = document.createElement(&#39;h1&#39;)//</code></pre><h3 id="修改文本内容"><a href="#修改文本内容" class="headerlink" title="修改文本内容"></a>修改文本内容</h3><pre><code class="js">h1.textContent = &#39;hello world&#39;</code></pre><h3 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h3><pre><code class="js">h1.setAttributes(&#39;class&#39;,&#39;hello&#39;)</code></pre><p>为了管理类，用<code>element.className</code>属性</p><pre><code class="js">h1.className = &#39;world&#39;</code></pre><p>然而，最好的办法还是用<code>classList</code></p><pre><code class="js">h1.classList.add(&#39;hello&#39;)h1.classList.remove(&#39;hello&#39;)</code></pre><p>要设置元素的ID,你可以用attribute或者直接设置id属性</p><pre><code class="js">h1.setAttribute(&#39;id&#39;, &#39;hello-world&#39;)h1.id = &#39;hello-world&#39;</code></pre><blockquote><p>如果你不确定是用attributes还是properties，那就用attributes，除了表单元素的状态，像value和checked</p></blockquote><p>除了下面这些，你不能用<code>element.setAttribute(someBoolean, false)</code>来设置bool值：</p><pre><code class="js">input.checked = true// input.checked = false// input.setAttribute(‘checked’, ‘’)// input.removeAttribute(&#39;checked&#39;)// </code></pre><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><pre><code class="js">document.body.appendChild(h1)</code></pre><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><pre><code class="js">document.body.removeChild(h1)</code></pre><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><pre><code class="js">document.getElementById(id)element.childNodes[i]element.firstChild === element.childNodes[0]element.lastChild === element.childNodes[element.childNodes.length - 1]element.getElementsByTagName(tagName)element.getElementsByClassName(className)element.querySelector(query)element.querySelectorAll(query)</code></pre><p><strong>注意</strong>：<code>getElementsByTagName, getElementsByClassName 和 querySelectorAll</code>返回的不是数组，而是一个<code>NodeList</code>，所以不能用ES5的数组迭代器迭代，这里有一些关于<a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList#Workarounds">NodeList的介绍</a></p><h3 id="元素之间插入元素"><a href="#元素之间插入元素" class="headerlink" title="元素之间插入元素"></a>元素之间插入元素</h3><pre><code class="js"> document.body.insertBefore(h1, document.body.firstChild)</code></pre><h3 id="创建很多元素"><a href="#创建很多元素" class="headerlink" title="创建很多元素"></a>创建很多元素</h3><pre><code class="js">const data = [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ]  ]const table = document.createElement(&#39;table&#39;)data.forEach(row =&gt; &#123;  const tr = document.createElement(&#39;tr&#39;)  row.forEach(cell =&gt; &#123;    const td = document.createElement(&#39;td&#39;)    td.textContent = cell    tr.appendChild(td)  &#125;)  table.appendChild(tr)&#125;)document.body.appendChild(table)</code></pre><h3 id="更新一系列元素"><a href="#更新一系列元素" class="headerlink" title="更新一系列元素"></a>更新一系列元素</h3><pre><code class="js">const table = document.createElement(&#39;table&#39;)document.body.appendChild(table)updateTable(table, [  [ 1, 2 ],  [ 3, 4, 5 ],  [ 6, 7, 8, 9 ]  ])setTimeout(() =&gt; &#123;  updateTable(table, [    [ 1, 2, 3, 4 ],    [ 5, 6, 7 ],    [ 8, 9 ]  ])  &#125;, 1000)function updateTable (table, data) &#123;  const rowLookup = table._lookup || (table._lookup = [])  setChildren(table, updateRows(rowLookup, data))&#125;function updateRows (rowLookup, rows) &#123;  return rows.map((row, y) =&gt; &#123;    const tr = rowLookup[y] || (rowLookup[y] = document.createElement(&#39;tr&#39;))    const cellLookup = tr._lookup || (tr._lookup = [])    setChildren(tr, updateCells(cellLookup, row))    return tr  &#125;)&#125;function updateCells (cellLookup, cells) &#123;  return cells.map((cell, x) =&gt; &#123;      const td = cellLookup[x] || (cellLookup[x] = document.createElement(&#39;td&#39;))      td.textContent = cell      return td    &#125;)&#125;function setChildren (parent, children) &#123;  let traverse = parent.firstChild  for (let i = 0; i &lt; children.length; i++) &#123;    const child = children[i]    if (child == null) &#123;      return    &#125;    if (child === traverse) &#123;      traverse = traverse.nextSibling    &#125; else if (traverse) &#123;      parent.insertBefore(child, traverse)    &#125; else &#123;      parent.appendChild(child)    &#125;  &#125;  while (traverse) &#123;    const next = traverse.nextSibling    parent.removeChild(traverse)    traverse = next  &#125;&#125;</code></pre><p>这里发生了两件事：</p><ul><li>1.这里有一个隐藏的元素<code>element._lookup = []</code>，用来查找子元素（可能是一个有id的元素），用这个方法我们可以重复利用已经存在的dom，更新他们</li><li>2.<code>setChildren(parent, children)</code>方法里有包含子元素的列表</li></ul><p>你还可以用<code>setChildren</code>方法来<code>mount/unmount</code>子元素</p><pre><code class="js">setChildren(login, [  email,  !forgot &amp;&amp; pass])</code></pre><h2 id="DOM树的渲染"><a href="#DOM树的渲染" class="headerlink" title="DOM树的渲染"></a>DOM树的渲染</h2><h3 id="CSS-不会阻塞-DOM-的解析"><a href="#CSS-不会阻塞-DOM-的解析" class="headerlink" title="CSS 不会阻塞 DOM 的解析"></a>CSS 不会阻塞 DOM 的解析</h3><p>首先在头部插入<code>&lt;script defer src=&quot;/js/logDiv.js&quot;&gt;&lt;/script&gt;</code>，JS文件的内容是：</p><pre><code class="js">const div = document.querySelector(&#39;div&#39;);console.log(div);</code></pre><p><code>defer</code>属性相信大家也很熟悉了，MDN对此的描述是用来通知浏览器该脚本将在文档完成解析后，触发 <code>DOMContentLoaded</code> 事件前执行。设置这个属性，能保证DOM解析后马上打印出div。</p><p>浏览器是解析DOM生成<code>DOM Tree</code>，结合CSS生成的<code>CSS Tree</code>，最终组成<code>render tree</code>，再渲染页面。由此可见，在此过程中CSS完全无法影响<code>DOM Tree</code>，因而无需阻塞DOM解析。然而，<code>DOM Tree</code>和<code>CSS Tree</code>会组合成<code>render tree</code>，那CSS会不会页面阻塞渲染呢？</p><h3 id="CSS-阻塞页面渲染"><a href="#CSS-阻塞页面渲染" class="headerlink" title="CSS 阻塞页面渲染"></a>CSS 阻塞页面渲染</h3><p>如果脚本的内容是获取元素的样式，宽高等CSS控制的属性，浏览器是需要计算的，也就是依赖于CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行JS。因而造成了之前例子的情况。</p><h3 id="JS-阻塞-DOM-解析"><a href="#JS-阻塞-DOM-解析" class="headerlink" title="JS 阻塞 DOM 解析"></a>JS 阻塞 DOM 解析</h3><p>浏览器遇到<code> &lt;script&gt;</code> 标签时，会触发页面渲染</p><p>每次碰到<code>&lt;script&gt;</code>标签时，浏览器都会渲染一次页面。这是基于同样的理由，浏览器不知道脚本的内容，因而碰到脚本时，只好先渲染页面，确保脚本能获取到最新的DOM元素信息，尽管脚本可能不需要这些信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;DOM操作&quot;&gt;&lt;a href=&quot;#DOM操作&quot; class=&quot;headerlink&quot; title=&quot;DOM操作&quot;&gt;&lt;/a&gt;DOM操作&lt;/h2&gt;&lt;p&gt;平时中因为有各个框架的</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习JavaScript应懂得33个概念之按位操作符, 类数组对象和类型化数组</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/29/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/29/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84/</id>
    <published>2020-09-29T01:25:07.000Z</published>
    <updated>2020-09-29T06:33:06.082Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="先了解下十进制与二进制互转"><a href="#先了解下十进制与二进制互转" class="headerlink" title="先了解下十进制与二进制互转"></a>先了解下十进制与二进制互转</h2><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p><strong>正整数转成二进制</strong>，除二取余，然后倒序排列，高位补零</p><p><img src="https://exp-picture.cdn.bcebos.com/c255efc595ee41c19c2f7ce08d88912ca5ca9b5f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo"></p><p><strong>负整数转二进制</strong>，先是将对应的正整数转换成二进制后，对二进制取反（1取0，0取1），然后对结果再加一</p><p><strong>tip: 和0相加是0，0和1相加是1，1和1相加是0但要产生一个进位1，加到下一列。如果最高位相加后产生进位，则最后得到的结果要加1。</strong></p><p><img src="https://exp-picture.cdn.bcebos.com/906dbbcadce8904832f4a744130e5f204371925f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo1"></p><p><strong>小数转换为二进制的方法</strong>,对小数点以后的数乘以2，有一个结果吧，取结果的整数部分（不是1就是0喽），然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小数部分为0或者位数已经够了就OK了</p><p><img src="https://exp-picture.cdn.bcebos.com/5e615d715fdb362080321d3aabc5260f88358d5f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo2"></p><h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><p><strong>整数二进制转换为十进制</strong>,首先将二进制数补齐位数，首位如果是0就代表是正整数，如果首位是1则代表是负整数。</p><p><img src="https://exp-picture.cdn.bcebos.com/3931cb413a8ca608e307444fdb8c9bcec7f8fe5f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo3"></p><p><strong>二进制的负数转为十进制</strong>,二进制转十进制跟十进制转二进制互为逆操作；</p><p><img src="https://exp-picture.cdn.bcebos.com/bf6e59704618dfda8cd40c3589214f5792567746.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo4"></p><p><strong>有小数的二进制转换为十进制</strong>,将二进制中的四位数分别于下边（如图9所示）对应的值相乘后相加得到的值即为换算后的十进制</p><p><img src="https://exp-picture.cdn.bcebos.com/6a408cdd3340b6f3c78fd3af12c0affce186ee5f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo5"></p><h2 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h2><p><code>按位操作符（Bitwise operators）</code> 将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制数值。</p><p>例如，十进制数9，用二进制表示则为1001。<em>按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值</em>。</p><table><thead><tr><th align="left">运算符</th><th align="left">用法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">按位与（ AND）</td><td align="left">a &amp; b</td><td align="left">对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。</td></tr><tr><td align="left">按位或（OR）</td><td align="left">a I b</td><td align="left">对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。</td></tr><tr><td align="left">按位异或（XOR）</td><td align="left">a ^ b</td><td align="left">对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。</td></tr><tr><td align="left">按位非（NOT）</td><td align="left">~ a</td><td align="left">反转操作数的比特位，即0变成1，1变成0。</td></tr><tr><td align="left">左移（Left shift）</td><td align="left">a &lt;&lt; b</td><td align="left">将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用0填充。</td></tr><tr><td align="left">有符号右移</td><td align="left">a &gt;&gt; b</td><td align="left">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。</td></tr><tr><td align="left">无符号右移</td><td align="left">a &gt;&gt;&gt; b</td><td align="left">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。</td></tr></tbody></table><h2 id="有符号32位整数"><a href="#有符号32位整数" class="headerlink" title="有符号32位整数"></a>有符号32位整数</h2><p>所有的按位操作符的操作数都会被转成补码（two’s complement）形式的有符号32位整数。<br><strong>补码形式是指一个数的负对应值（negative counterpart）（如 5和-5）为数值的所有比特位反转后，再加1。</strong><br>反转比特位即该数值进行’非‘位运算，也即该数值的反码。</p><ul><li><p>0 是所有比特数字0组成的整数。<br><code>0 (base 10) = 00000000000000000000000000000000 (base 2)</code></p></li><li><p>-1 是所有比特数字1组成的整数。<br><code>-1 (base 10) = 11111111111111111111111111111111 (base 2)</code></p></li><li><p>-2147483648（十六进制形式：-0x80000000）是除了最左边为1外，其他比特位都为0的整数。<br><code>-2147483648 (base 10) = 10000000000000000000000000000000 (base 2)</code></p></li><li><p>2147483647（十六进制形式：0x7fffffff）是除了最左边为0外，其他比特位都为1的整数。<br><code>2147483647 (base 10) = 01111111111111111111111111111111 (base 2)</code></p></li></ul><p>数字<code>-2147483648</code> 和 <code>2147483647</code> 是32位有符号数字所能表示的最小和最大整数。</p><h3 id="按位逻辑操作符"><a href="#按位逻辑操作符" class="headerlink" title="按位逻辑操作符"></a>按位逻辑操作符</h3><h4 id="amp-（按位与）"><a href="#amp-（按位与）" class="headerlink" title="&amp;（按位与）"></a>&amp;（按位与）</h4><p>对每对比特位执行<code>与（AND）</code>操作。只有 a 和 b 都是 1 时，a AND b 才是 1。将任一数值 x 与 0 执行按位与操作，其结果都为 0。将任一数值 x 与 -1 执行按位与操作，其结果都为 x。</p><h4 id="（按位或）"><a href="#（按位或）" class="headerlink" title="|（按位或）"></a>|（按位或）</h4><p>对每一对比特位执行<code>或（OR）</code>操作。如果 a 或 b 为 1，则 a OR b 结果为 1。将任一数值 x 与 0 进行按位或操作，其结果都是 x。将任一数值 x 与 -1 进行按位或操作，其结果都为 -1。。</p><h4 id="（按位非）"><a href="#（按位非）" class="headerlink" title="~（按位非）"></a>~（按位非）</h4><p>对每一个比特位执行<code>非（NOT）</code>操作。NOT a 结果为 a 的反转（即反码）。对任一数值 x 进行按位非操作的结果为 -(x + 1)</p><h4 id="（按位异或）"><a href="#（按位异或）" class="headerlink" title="^（按位异或）"></a>^（按位异或）</h4><p>对每一对比特位执行<code>异或（XOR）</code>操作。当 a 和 b 不相同时，a XOR b 的结果为 1。将任一数值 x 与 0 进行异或操作，其结果为 x。将任一数值 x 与 -1 进行异或操作，其结果为 ~x。</p><h3 id="按位移动操作符"><a href="#按位移动操作符" class="headerlink" title="按位移动操作符"></a>按位移动操作符</h3><p>按位移动操作符有两个操作数：<strong>第一个是要被移动的数字，而第二个是要移动的长度</strong>。移动的方向根据操作符的不同而不同。</p><h4 id="lt-lt-左移"><a href="#lt-lt-左移" class="headerlink" title="&lt;&lt; (左移)"></a>&lt;&lt; (左移)</h4><p>该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。</p><p>For example,<code>9 &lt;&lt; 2</code> yields 36:</p><pre><code class="js">9 (base 10): 00000000000000000000000000001001 (base 2)//--------------------------------9 &lt;&lt; 2 (base 10): 00000000000000000000000000100100 (base 2) = 36 (base 10)</code></pre><p>在数字 <code>x</code> 上左移<code> y</code> 比特得到 <code>x * 2y</code>.</p><h4 id="gt-gt-右移"><a href="#gt-gt-右移" class="headerlink" title="&gt;&gt; (右移)"></a>&gt;&gt; (右移)</h4><p>该操作符会<strong>将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变</strong>。</p><p>例如， <code>9 &gt;&gt; 2</code> 得到 2:</p><pre><code class="js">9 (base 10): 00000000000000000000000000001001 (base 2)//--------------------------------9 &gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</code></pre><p>相比之下， <code>-9 &gt;&gt; 2</code> 得到 -3，因为符号被保留了。</p><pre><code class="js"> -9 (base 10): 11111111111111111111111111110111 (base 2)//---------------------------------9 &gt;&gt; 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)</code></pre><h4 id="gt-gt-gt-无符号右移"><a href="#gt-gt-gt-无符号右移" class="headerlink" title="&gt;&gt;&gt; (无符号右移)"></a>&gt;&gt;&gt; (无符号右移)</h4><p>该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的</p><p><strong>对于非负数，有符号右移和无符号右移总是返回相同的结果</strong>。例如 <code>9 &gt;&gt;&gt; 2</code> 和 <code>9 &gt;&gt; 2</code> 一样返回 2：</p><pre><code class="js">9 (base 10): 00000000000000000000000000001001 (base 2)// --------------------------------9 &gt;&gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</code></pre><p><strong>但是对于负数却不尽相同</strong>。<code>-9 &gt;&gt;&gt; 2</code>产生<code> 1073741821</code> 这和 <code>-9 &gt;&gt; 2</code> 不同：</p><pre><code class="js">-9 (base 10): 11111111111111111111111111110111 (base 2)//---------------------------------9 &gt;&gt;&gt; 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10)</code></pre><h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><p>JavaScript类型化数组是一种类似数组的对象，并提供了一种用于访问原始二进制数据的机制。 </p><p>正如你可能已经知道，Array 存储的对象能动态增多和减少，并且可以存储任何JavaScript值。JavaScript引擎会做一些内部优化，以便对数组的操作可以很快。</p><p>然而，随着Web应用程序变得越来越强大，尤其一些新增加的功能例如：<code>音频视频编辑，访问WebSockets的原始数据</code>等，很明显有些时候如果使用JavaScript代码可以快速方便地通过<strong>类型化数组来操作原始的二进制数据</strong>将会非常有帮助。</p><p>类型数组不等于数组，可以使用<code>Array.isArray</code>可以判断出类型数组为<code>false</code></p><h3 id="缓冲和视图：类型数组架构"><a href="#缓冲和视图：类型数组架构" class="headerlink" title="缓冲和视图：类型数组架构"></a>缓冲和视图：类型数组架构</h3><p>为了达到最大的灵活性和效率，JavaScript 类型数组（Typed Arrays）将实现拆分为<strong>缓冲</strong>和<strong>视图</strong>两部分。</p><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><p><code>ArrayBuffer</code> 是一种数据类型，用来表示一个通用的、固定长度的二进制数据缓冲区。你不能直接操纵一个<code>ArrayBuffer</code>中的内容；你需要创建一个类型化数组的视图或一个描述缓冲数据格式的<code>DataView</code>，使用它们来读写缓冲区中的内容.</p><h4 id="类型数组视图"><a href="#类型数组视图" class="headerlink" title="类型数组视图"></a>类型数组视图</h4><p>类型化数组视图具有自描述性的名字和所有常用的数值类型像<code>Int8</code>，<code>Uint32</code>，<code>Float64</code> 等等。有一种特殊类型的数组<code>Uint8ClampedArray</code>。它仅操作0到255之间的数值。</p><h4 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h4><p><code>DataView</code> 是一种底层接口，它提供有可以操作缓冲区中任意数据的读写接口。这对操作不同类型数据的场景很有帮助，例如：类型化数组视图都是运行在本地字节序模式(参考 Endianness)，可以通过使用 <code>DataView</code> 来控制字节序。默认是大端字节序(Big-endian)，但可以调用读写接口改为小端字节序(Little-endian)。</p><h3 id="使用类型数组的Web-API"><a href="#使用类型数组的Web-API" class="headerlink" title="使用类型数组的Web API"></a>使用类型数组的Web API</h3><p><code>FileReader.prototype.readAsArrayBuffer()</code><br><code>FileReader.prototype.readAsArrayBuffer()</code> 读取对应的<code>Blob</code> 或 <code>File</code>的内容</p><p><code>XMLHttpRequest.prototype.send()</code><br><code>XMLHttpRequest</code> 实例的 send() 方法现在使用支持类型化数组和 <code>ArrayBuffer</code> 对象作为参数。</p><p><code>ImageData.data</code><br>是一个 <code>Uint8ClampedArray</code> 对象，用来描述包含按照RGBA序列的颜色数据的一维数组，其值的范围在0到255（包含255）之间。</p><p><code>ImageData</code> 接口描述 <code>&lt;canvas&gt;</code> 元素的一个隐含像素数据的区域。使用 <code>ImageData()</code> 构造函数创建或者使用和 <code>canvas</code> 在一起的 <code>CanvasRenderingContext2D</code> 对象的创建方法： <code>createImageData() 和 getImageData()</code>。也可以使用 <code>putImageData()</code> 设置 <code>canvas</code> 的一部分。</p><h2 id="ArrayBuffer-1"><a href="#ArrayBuffer-1" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><p><strong>ArrayBuffer又称类型化数组</strong>。</p><blockquote><p>javascript数组（Array）长什么样子，相信大家都清楚，那么我说说差别应该就可以了解这究竟是个什么了！</p></blockquote><ul><li>数组里面可以放数字、字符串、布尔值以及对象和数组等，<code>ArrayBuffer</code>放0和1组成的二进制数据</li><li>数组放在堆中，<code>ArrayBuffer</code>则把数据放在栈中（所以取数据时后者快）</li><li><code>ArrayBuffer</code>初始化后固定大小，数组则可以自由增减。(准确的说，视图才应该跟数组来比较这个特点)</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="js">// new ArrayBuffer(Bytelength);var arraybuffer = new ArrayBuffer(8);//类方法ArrayBuffer.isView() 判断某对象是否为 视图(这是什么？往下看)var int8a = new Int8Array(arraybuffer);ArrayBuffer.isView(int8a)  //return true//类属性ArrayBuffer.length 默认值1，暂未发现用处ArrayBuffer.length //return 1//返回的对象具有byteLength属性 值为参数Bytelengtharraybuffer.byteLength //return 8</code></pre><p>如上所诉：实例化一个对象的时候，仅需要传入一个参数，即字节数。</p><p><code>字节(Byte)</code>：存储空间的基本计量单位。一个字节等于8位(bit)，每一位用0或1表示。</p><h3 id="视图："><a href="#视图：" class="headerlink" title="视图："></a>视图：</h3><p><code>ArrayBuffer</code>对象并没有提供任何读写内存的方法，而是允许在其上方建立“视图”，从而插入与读取内存中的数据。如上：我们在内存中分配了16个格子也就是两个字节，如果我们要划分出A视图与B视图来瓜分这16个格子的话，代码是这样的：</p><pre><code class="js">var arraybuffer = new ArrayBuffer(8);var aView = new Int8Array(arraybuffer,0,1);var bView = new Int8Array(arraybuffer,1,1);aView[0] = 1;  //二进制00000001bView[0] = 2;  //二进制00000010</code></pre><table><thead><tr><th align="left">视图类型</th><th align="left">数据类型</th><th align="left">占用位数</th><th align="left">占用字节</th><th align="left">有无符号</th></tr></thead><tbody><tr><td align="left">Int8Array</td><td align="left">整数</td><td align="left">8</td><td align="left">1</td><td align="left">有</td></tr><tr><td align="left">Uint8Array</td><td align="left">整数</td><td align="left">8</td><td align="left">1</td><td align="left">无</td></tr><tr><td align="left">Uint8ClampedArray</td><td align="left">整数</td><td align="left">8</td><td align="left">1</td><td align="left">无</td></tr><tr><td align="left">Int16Array</td><td align="left">整数</td><td align="left">16</td><td align="left">2</td><td align="left">有</td></tr><tr><td align="left">Uint16Array</td><td align="left">整数</td><td align="left">16</td><td align="left">2</td><td align="left">无</td></tr><tr><td align="left">Int32Array</td><td align="left">整数</td><td align="left">32</td><td align="left">4</td><td align="left">有</td></tr><tr><td align="left">Uint32Array</td><td align="left">整数</td><td align="left">32</td><td align="left">4</td><td align="left">无</td></tr><tr><td align="left">Float32Array</td><td align="left">浮点数</td><td align="left">32</td><td align="left">4</td><td align="left">\</td></tr><tr><td align="left">Float64Array</td><td align="left">浮点数</td><td align="left">64</td><td align="left">8</td><td align="left">\</td></tr></tbody></table><p> <strong>有无符号则表示该类数据类型是否包含负数</strong>，如：Int8Array代表8位有符号整数，其范围为 -128<del>127，而Uint8Array代表8位无符号整数，范围是 0</del>255。</p><h3 id="DataView视图"><a href="#DataView视图" class="headerlink" title="DataView视图"></a>DataView视图</h3><p>为了解决各种硬件设备、数据传输等对默认字节序的设定不一而导致解码时候会发生的混乱问题，javascript提供了<code>DataView</code>类型的视图来让开发者在对内存进行读写时手动设定字节序的类型。</p><p>（一）DataView构造函数</p><pre><code class="js">//new DataView(arraybuffer,byteOffset [, byteLength])var arraybuffer = new ArrayBuffer(8);var dv1 = new DataView(arraybuffer);    //0-7var dv2 = new DataView(arraybuffer,2);    //2-7var dv3 = new DataView(arraybuffer,3,2);    //3-4</code></pre><p>（二）DataView实例化后的对象所具有的功能</p><table><thead><tr><th align="left">Read</th><th align="left">Write</th></tr></thead><tbody><tr><td align="left">getInt8()</td><td align="left">setInt8()</td></tr><tr><td align="left">getUint8()</td><td align="left">setUint8()</td></tr><tr><td align="left">getInt16()</td><td align="left">setInt16()</td></tr><tr><td align="left">getUint16()</td><td align="left">setUint16()</td></tr><tr><td align="left">getInt32()</td><td align="left">setInt32()</td></tr><tr><td align="left">getUint32()</td><td align="left">setUint32()</td></tr><tr><td align="left">getFloat32()</td><td align="left">setFloat32()</td></tr><tr><td align="left">getFloat64()</td><td align="left">setFloat64()</td></tr></tbody></table><p>你可以通过如下的方式来<strong>判断运行当前javascript的机器使用哪一种字节序</strong></p><pre><code class="js">var littleEndian = (function() &#123;  var buffer = new ArrayBuffer(2);  new DataView(buffer).setInt16(0, 256, true);  return new Int16Array(buffer)[0] === 256;&#125;)();console.log(littleEndian); // true ----&gt;littleEndian                            //false ----&gt;BigEndian</code></pre><h3 id="ArrayBuffer与字符串"><a href="#ArrayBuffer与字符串" class="headerlink" title="ArrayBuffer与字符串"></a>ArrayBuffer与字符串</h3><p>javascript的字符串使用<code>UTF-16</code>编码的方式，所以我们可以这样来做：</p><pre><code class="js">function Uint162Str(arraybuffer)&#123;  return String.fromCharCode.apply(null,new Uint16Array(arraybuffer));&#125;function Str2Uint16(str)&#123;  //假设字符串”abc“ length=3,使用16位，则每一个字母占据2字节，总字节为length乘以2  var arraybuffer =new ArrayBuffer(str.length*2);  var view = new Uint16Array(arraybuffer);  for(var i=0,l=str.length;i&lt;l;i++)&#123;      view[i] = str.charCodeAt(i);  &#125;  return view;&#125;    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;先了解下十进制与二进制互转&quot;&gt;&lt;a href=&quot;#先了解下十进制与二进制互转&quot; class=&quot;headerlink&quot; title=&quot;先了解下十进制与二进制互转&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习JavaScript应懂得33个概念之封装多态继承</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/28/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E5%A4%9A%E6%80%81%E7%BB%A7%E6%89%BF/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/28/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E5%A4%9A%E6%80%81%E7%BB%A7%E6%89%BF/</id>
    <published>2020-09-28T05:36:18.000Z</published>
    <updated>2020-09-28T06:19:51.422Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.im/post/6844903480868470798">原文地址</a></p><p><img src="https://user-gold-cdn.xitu.io/2017/6/8/99f977fcc9ad71ee0c197cbdaecd52b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="面向对象编程"></p><p>先上一张图，可以对面向对象有一个大致的了解，然而什么是面向对象呢，用java中的一句经典语句来说就是：万事万物皆对象。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。</p><blockquote><p>面向对象是把<strong>构成问题事务分解成各个对象</strong>，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p></blockquote><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>面向对象和面向过程是两种不同的编程思想，我们经常会听到两者的比较，刚开始编程的时候，大部分应该都是使用的面向过程的编程，但是随着我们的成长，还是面向对象的编程思想比较好一点~其实面向对象和面向过程并不是完全相对的，也并不是完全独立的。我认为面向对象和面向过程的主要区别是面向过程主要是以动词为主，解决问题的方式是按照顺序一步一步调用不同的函数。而面向对象主要是以名词为主，将问题抽象出具体的对象，而这个对象有自己的属性和方法，在解决问题的时候是将不同的对象组合在一起使用。所以说面向对象的好处就是可扩展性更强一些，解决了代码重用性的问题。</p><ul><li>面向过程就是分析出解决问题所需要的步骤，然后<strong>用函数把这些步骤一步一步实现</strong>，使用的时候一个一个依次调用就可以了。</li><li>面向对象是把<strong>构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤</strong>，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li></ul><p>有一个知乎的高票回答很有意思，给大家分享一下~</p><blockquote><p>面向对象： 狗.吃(屎)<br>面向过程： 吃.(狗,屎)</p></blockquote><p>具体的实现我们看一下最经典的“<code>把大象放冰箱</code>”这个问题</p><h3 id="面向过程的解决方法"><a href="#面向过程的解决方法" class="headerlink" title="面向过程的解决方法"></a>面向过程的解决方法</h3><p>在面向过程的编程方式中实现“把大象放冰箱”这个问题答案是耳熟能详的，一共分三步：</p><ul><li>开门（冰箱）；</li><li>装进（冰箱，大象）；</li><li>关门（冰箱）。面向对象的解决方法</li></ul><h3 id="面向对象的解决方法"><a href="#面向对象的解决方法" class="headerlink" title="面向对象的解决方法"></a>面向对象的解决方法</h3><ul><li>冰箱.开门（）</li><li>冰箱.装进（大象）</li><li>冰箱.关门（）</li></ul><p>可以看出来面向对象和面向过程的侧重点是不同的，<strong>面向过程是以动词为主</strong>，完成一个事件就是将不同的动作函数按顺序调用。<strong>面向对象是以主谓为主</strong>。将主谓看成一个一个的对象，然后对象有自己的属性和方法。</p><p>比如说，冰箱有自己的id属性，有开门的方法。然后就可以直接调用冰箱的开门方法给其传入一个参数大象就可以了。简单的例子面向对象和面向过程的好处还不是很明显。</p><h3 id="五子棋例子"><a href="#五子棋例子" class="headerlink" title="五子棋例子"></a>五子棋例子</h3><p>下面是一个我认为比较能够说明两者区别的一个栗子~：例如五子棋，面向过程的设计思路就是首先分析问题的步骤：</p><ol><li>开始游戏</li><li>黑子先走</li><li>绘制画面</li><li>判断输赢</li><li>轮到白子</li><li>绘制画面</li><li>判断输赢</li><li>返回步骤2</li></ol><p>把上面每个步骤用分别的函数来实现，问题就解决了。<br>而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为 </p><ul><li>黑白双方，这两方的行为是一模一样的</li><li>棋盘系统，负责绘制画面</li></ul><p>第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的i变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。<br>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了总多步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。<br>功能上的统一保证了面向对象设计的可扩展性。比如我要加入悔棋的功能，如果要改动面向过程的设计，那么从输入到判断到显示这一连串的步骤都要改动，甚至步骤之间的循序都要进行大规模调整。如果是面向对象的话，只用改动棋盘对象就行了，棋盘系统保存了黑白双方的棋谱，简单回溯就可以了，而显示和规则判断则不用顾及，同时整个对对象功能的调用顺序都没有变化，改动只是局部的。<br>再比如我要把这个五子棋游戏改为围棋游戏，如果你是面向过程设计，那么五子棋的规则就分布在了你的程序的每一个角落，要改动还不如重写。但是如果你当初就是面向对象的设计，那么你只用改动规则对象就可以了，五子棋和围棋的区别不就是规则吗？（当然棋盘大小好像也不一样，但是你会觉得这是一个难题吗？直接在棋盘对象中进行一番小改动就可以了。）而下棋的大致步骤从面向对象的角度来看没有任何变化。<br>当然，要达到改动只是局部的需要设计的人有足够的经验，使用对象不能保证你的程序就是面向对象，初学者或者很蹩脚的程序员很可能以面向对象之虚而行面向过程之实，这样设计出来的所谓面向对象的程序很难有良好的可移植性和可扩展性。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象有三大特性，<code>封装、继承和多态</code>。对于ES5来说，没有<code>class</code>的概念，并且由于js的函数级作用域（在函数内部的变量在函数外访问不到），所以我们就可以模拟 <code>class</code>的概念，在es5中，类其实就是保存了一个函数的变量，这个函数有自己的属性和方法。将属性和方法组成一个类的过程就是封装。</p><blockquote><p>封装：<strong>把客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口。</strong></p></blockquote><h3 id="通过构造函数添加"><a href="#通过构造函数添加" class="headerlink" title="通过构造函数添加"></a>通过构造函数添加</h3><p>javascript提供了一个构造函数（Constructor）模式，用来在创建对象时初始化对象。构造函数其实就是普通的函数，只不过有以下的特点</p><ul><li>首字母大写（建议构造函数首字母大写，即使用大驼峰命名，非构造函数首字母小写）</li><li>内部使用this</li><li>使用 new生成实例</li></ul><p>通过构造函数添加属性和方法实际上也就是通过this添加的属性和方法。因为this总是指向当前对象的，所以通过this添加的属性和方法只在当前对象上添加，是该对象自身拥有的。所以我们实例化一个新对象的时候，this指向的属性和方法都会得到相应的创建，也就是会在内存中复制一份，这样就造成了内存的浪费。</p><pre><code class="js">function Cat(name,color)&#123;  this.name = name;  this.color = color;  this.eat = function () &#123;      alert(&#39;吃老鼠&#39;)  &#125;&#125;//复制代码生成实例：var cat1 = new Cat(&#39;tom&#39;,&#39;red&#39;)复制代码通过this定义的属性和方法，我们实例化对象的时候都会重新复制一份</code></pre><h3 id="通过原型prototype"><a href="#通过原型prototype" class="headerlink" title="通过原型prototype"></a>通过原型prototype</h3><p>在类上通过 this的方式添加属性和对象会导致内存浪费的问题，我们就考虑，有什么方法可以让实例化的类所使用的方法直接使用指针指向同一个方法。于是，就想到了原型的方式</p><p>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。也就是说，对于那些不变的属性和方法，我们可以直接将其添加在类的prototype 对象上。</p><pre><code class="js">function Cat(name,color)&#123;　this.name = name;　this.color = color;&#125;Cat.prototype.type = &quot;猫科动物&quot;;Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;复制代码然后生成实例var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠复制代码这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</code></pre><h3 id="在类的外部通过-语法添加"><a href="#在类的外部通过-语法添加" class="headerlink" title="在类的外部通过.语法添加"></a>在类的外部通过.语法添加</h3><p>我们还可以在类的外部通过. 语法进行添加，因为在实例化对象的时候，并不会执行到在类外部通过. 语法添加的属性，所以实例化之后的对象是不能访问到. 语法所添加的对象和属性的，只能通过该类访问。</p><h3 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h3><p>通过构造函数、原型和. 语法三者都可以在类上添加属性和方法。但是三者是有一定的区别的。构造函数：通过this添加的属性和方法总是指向当前对象的，所以在实例化的时候，通过this添加的属性和方法都会在内存中复制一份，这样就会造成内存的浪费。但是这样创建的好处是即使改变了某一个对象的属性或方法，不会影响其他的对象（因为每一个对象都是复制的一份）。原型：通过原型继承的方法并不是自身的，我们要在原型链上一层一层的查找，这样创建的好处是只在内存中创建一次，实例化的对象都会指向这个prototype 对象，但是这样做也有弊端，因为实例化的对象的原型都是指向同一内存地址，改动其中的一个对象的属性可能会影响到其他的对象. 语法：在类的外部通过. 语法创建的属性和方法只会创建一次，但是这样创建的实例化的对象是访问不到的，只能通过类的自身访问</p><h3 id="javascript也有private-public-protected"><a href="#javascript也有private-public-protected" class="headerlink" title="javascript也有private public protected"></a>javascript也有private public protected</h3><p>对于java程序员来说<code>private public protected</code>这三个关键字应该是很熟悉的哈，但是在js中，并没有类似于<code>private public protected</code>这样的关键字，但是我们又希望我们定义的属性和方法有一定的访问限制，于是我们就可以模拟<code>private public protected</code>这些访问权限。不熟悉java的小伙伴可能不太清楚<code>private public protected</code>概念（其他语言我也不清楚有没有哈，但是应该都是类似的<del>），先来科普一下小知识点</del></p><ul><li>public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</li><li>private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。</li><li>protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。</li></ul><h4 id="js中的private"><a href="#js中的private" class="headerlink" title="js中的private"></a>js中的private</h4><p>因为javascript函数级作用域的特性（在函数中定义的属性和方法外界访问不到），所以我们在函数内部直接定义的属性和方法都是私有的。</p><h4 id="js中的public"><a href="#js中的public" class="headerlink" title="js中的public"></a>js中的public</h4><p>通过new关键词实例化时，this定义的属性和变量都会被复制一遍，所以通过this定义的属性和方法就是公有的。通过prototype创建的属性在类的实例化之后类的实例化对象也是可以访问到的，所以也是公有的。</p><h4 id="js中的protected"><a href="#js中的protected" class="headerlink" title="js中的protected"></a>js中的protected</h4><p>在函数的内部，我们可以通过this定义的方法访问到一些类的私有属性和方法，在实例化的时候就可以初始化对象的一些属性了。</p><h4 id="new的实质"><a href="#new的实质" class="headerlink" title="new的实质"></a>new的实质</h4><p>虽然很多人都已经了解了new的实质，那么我还是要再说一下new 的实质 var o = new Object()</p><ol><li>新建一个对象o</li><li><code>o. __proto__ = Object.prototype</code> 将新创建的对象的<code>__proto__</code>属性指向构造函数的<code>prototype</code></li><li>将this指向新创建的对象</li><li>返回新对象，但是这里需要看构造函数有没有返回值，如果构造函数的返回值为基本数据类型<code>string,boolean,number,null,undefined</code>,那么就返回新对象，如果构造函数的返回值为对象类型，那么就返回这个对象类型</li></ol><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code class="js">var Book = function (id, name, price) &#123;  //private(在函数内部定义，函数外部访问不到，实例化之后实例化的对象访问不到)  var num = 1;  var id = id;  function checkId() &#123;      console.log(&#39;private&#39;)  &#125;  //protected(可以访问到函数内部的私有属性和私有方法，在实例化之后就可以对实例化的类进行初始化拿到函数的私有属性)  this.getName = function () &#123;      console.log(id)  &#125;  this.getPrice = function () &#123;      console.log(price)  &#125;  //public(实例化的之后，实例化的对象就可以访问到了~)  this.name = name;  this.copy = function () &#123;      console.log(&#39;this is public&#39;)  &#125;&#125;//在Book的原型上添加的方法实例化之后可以被实例化对象继承Book.prototype.proFunction = function () &#123;  console.log(&#39;this is proFunction&#39;)&#125;//在函数外部通过.语法创建的属性和方法，只能通过该类访问，实例化对象访问不到Book.setTime = function () &#123;  console.log(&#39;this is new time&#39;)&#125;var book1 = new Book(&#39;111&#39;,&#39;悲惨世界&#39;,&#39;$99&#39;)book1.getName();        // 111 getName是protected，可以访问到类的私有属性，所以实例化之后也可以访问到函数的私有属性book1.checkId();        //报错book1.checkId is not a functionconsole.log(book1.id)   // undefined id是在函数内部通过定义的，是私有属性，所以实例化对象访问不到console.log(book1.name) //name 是通过this创建的，所以在实例化的时候会在book1中复制一遍name属性，所以可以访问到book1.copy()            //this is publicbook1.proFunction();    //this is proFunctionBook.setTime();         //this is new timebook1.setTime();        //报错book1.setTime is not a function</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承：子类可以使用父类的所有功能，并且对这些功能进行扩展。继承的过程，就是从一般到特殊的过程。</p></blockquote><p>其实继承都是基于以上封装方法的三个特性来实现的。</p><h3 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h3><p>所谓的类式继承就是使用的原型的方式，将方法添加在父类的原型上，然后子类的原型是父类的一个实例化对象。</p><pre><code class="js">//声明父类  var SuperClass = function () &#123;      var id = 1;      this.name = [&#39;javascript&#39;];      this.superValue = function () &#123;          console.log(&#39;superValue is true&#39;);          console.log(id)      &#125;  &#125;;  //为父类添加共有方法  SuperClass.prototype.getSuperValue = function () &#123;      return this.superValue();  &#125;;  //声明子类  var SubClass = function () &#123;      this.subValue = function () &#123;          console.log(&#39;this is subValue &#39;)      &#125;  &#125;;  //继承父类  SubClass.prototype = new SuperClass() ;  //为子类添加共有方法  SubClass.prototype.getSubValue= function () &#123;      return this.subValue()  &#125;;  var sub = new SubClass();  var sub2 =  new  SubClass();  sub.getSuperValue();   //superValue is true  sub.getSubValue();     //this is subValue  console.log(sub.id);    //undefined  console.log(sub.name);  //javascript  sub.name.push(&#39;java&#39;);  //[&quot;javascript&quot;]  console.log(sub2.name)  //[&quot;javascript&quot;, &quot;java&quot;]</code></pre><p>其中最核心的一句代码是<code>SubClass.prototype = new SuperClass()</code> ;类的原型对象<code>prototype</code>对象的作用就是为类的原型添加共有方法的，但是类不能直接访问这些方法，只有将类实例化之后，新创建的对象复制了父类构造函数中的属性和方法，并将原型<code>__proto__ </code>指向了父类的原型对象。这样子类就可以访问父类的<code>public</code> 和<code>protected </code>的属性和方法，同时，父类中的<code>private</code> 的属性和方法不会被子类继承。</p><p>如上述代码的最后一段，使用类继承的方法，如果父类的构造函数中有引用类型，就会在子类中被所有实例共用，因此<strong>一个子类的实例如果更改了这个引用类型，就会影响到其他子类的实例</strong>。</p><p>提一个小问题~<strong>为什么一个子类的实例如果更改了这个引用类型，就会影响到其他子类的实例呢，在javascript中，什么是引用类型呢，引用类型和其他的类型又有什么区别呢？</strong></p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>正式因为有了上述的缺点，才有了构造函数继承，构造函数继承的核心思想就是<code>SuperClass.call(this,id)</code>,直接改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题</p><pre><code class="js">//构造函数继承//声明父类function SuperClass(id) &#123;    var name = &#39;javascript&#39;    this.books=[&#39;javascript&#39;,&#39;html&#39;,&#39;css&#39;];    this.id = id&#125;//声明父类原型方法SuperClass.prototype.showBooks = function () &#123;    console.log(this.books)&#125;//声明子类function SubClass(id) &#123;    SuperClass.call(this,id)&#125;//创建第一个子类实例var subclass1 = new SubClass(10);var subclass2 = new SubClass(11);console.log(subclass1.books);console.log(subclass2.id);console.log(subclass1.name);   //undefinedsubclass2.showBooks();</code></pre><h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>类继承    </p><ul><li>核心思想:子类的原型是父类实例化的对象</li><li>优点:子类实例化对象的属性和方法都指向父类的原型</li><li>缺点:子类之间可能会互相影响</li></ul><p>构造函数继承</p><ul><li>核心思想:<code>SuperClass.call(this,id)</code></li><li>优点:每个实例化的子类互不影响</li><li>缺点:内存浪费</li></ul><p>所以组合式继承就是汲取两者的优点，即避免了内存浪费，又使得每个实例化的子类互不影响。</p><pre><code class="js">//组合式继承//声明父类var SuperClass = function (name) &#123;    this.name = name;    this.books=[&#39;javascript&#39;,&#39;html&#39;,&#39;css&#39;]&#125;;//声明父类原型上的方法SuperClass.prototype.showBooks = function () &#123;    console.log(this.books)&#125;;//声明子类var SubClass = function (name) &#123;    SuperClass.call(this, name)&#125;;//子类继承父类（链式继承）SubClass.prototype = new SuperClass();//实例化子类var subclass1 = new SubClass(&#39;java&#39;);var subclass2 = new SubClass(&#39;php&#39;);subclass2.showBooks();subclass1.books.push(&#39;ios&#39;);    //[&quot;javascript&quot;, &quot;html&quot;, &quot;css&quot;]console.log(subclass1.books);  //[&quot;javascript&quot;, &quot;html&quot;, &quot;css&quot;, &quot;ios&quot;]console.log(subclass2.books);   //[&quot;javascript&quot;, &quot;html&quot;, &quot;css&quot;]</code></pre><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><p>组合式继承的方法固然好，但是会导致一个问题，<strong>父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍）</strong>，所以为了解决这个问题，又出现了寄生组合继承。</p><p>刚刚问题的关键是<strong>父类的构造函数在类继承和构造函数继承的组合形式中被创建了两遍，但是在类继承中我们并不需要创建父类的构造函数，我们只是要子类继承父类的原型</strong>即可。所以说我们先给父类的原型创建一个副本，然后修改子类<code>constructor</code>属性，最后在设置子类的原型就可以了~</p><pre><code class="js">//原型式继承//原型式继承其实就是类式继承的封装,实现的功能是返回一个实例，改实例的原型继承了传入的o对象function inheritObject(o) &#123;    //声明一个过渡函数对象    function F() &#123;&#125;    //过渡对象的原型继承父对象    F.prototype = o;    //返回一个过渡对象的实例，该实例的原型继承了父对象    return new F();&#125;//寄生式继承//寄生式继承就是对原型继承的第二次封装，使得子类的原型等于父类的原型。并且在第二次封装的过程中对继承的对象进行了扩展function inheritPrototype(subClass, superClass)&#123;    //复制一份父类的原型保存在变量中，使得p的原型等于父类的原型    var p = inheritObject(superClass.prototype);    //修正因为重写子类原型导致子类constructor属性被修改    p.constructor = subClass;    //设置子类的原型    subClass.prototype = p;&#125;//定义父类var SuperClass = function (name) &#123;    this.name = name;    this.books = [&#39;javascript&#39;,&#39;html&#39;,&#39;css&#39;]&#125;;//定义父类原型方法SuperClass.prototype.getBooks = function () &#123;    console.log(this.books)&#125;;//定义子类var SubClass = function (name) &#123;    SuperClass.call(this,name)&#125;inheritPrototype(SubClass,SuperClass);var subclass1 = new SubClass(&#39;php&#39;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903480868470798&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://use</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之setTimeout, setInterval 和 requestAnimationFrame</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/27/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BsetTimeout-setInterval-%E5%92%8C-requestAnimationFrame/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/27/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BsetTimeout-setInterval-%E5%92%8C-requestAnimationFrame/</id>
    <published>2020-09-27T08:58:52.000Z</published>
    <updated>2020-09-27T09:32:27.065Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>[原文地址](https://segmentfault.com/a/1190000014661035)<h2 id="一-常见定时器"><a href="#一-常见定时器" class="headerlink" title="一.常见定时器"></a>一.常见定时器</h2><pre><code class="html">我们常见的定时器有以下两种1. window.setTimeout 用于在指定的毫秒数后执行某段既定的代码2. window.setInterval 用于每隔一段毫秒数重复执行既定的代码这两个方法都可以通过手工设置时间来设定是多少毫秒后执行这段代码，或者是每隔多少毫秒执行这段代码。  </code></pre><blockquote><p>虽然我们期待浏览器按照我们设定的时间精确的执行代码，但是js却不能保证代码能恰好在那个时间点被运行，原因有两个。</p></blockquote><ul><li><p>大多数浏览器并没有精确到毫秒级别的触发事件，例如，我们设定某个函数在3毫秒后执行，在老版本的IE中，这个函数至少会在15毫秒以后执行。而在现代浏览器中，这个数值会短一点，但时间差一般也会超过1毫秒。</p></li><li><p>第二个原因与js的运行机制有关，具体见<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a>.简单来说，就是js是一个单线程的解释器，一段时间只能执行一段代码，所以运行时分为主线程和任务队列两部分。而我们在定时器中设置的时间，仅代表1000毫秒后把这个任务插入到任务队列中，而此时必须要等到主线程的代码执行完毕，才能执行任务队列中的定时器的任务（在任务队列中也有调度，不一定第一个执行当前任务），因此时间是无法保证的。</p></li></ul><h2 id="二、requestAnimationFrame"><a href="#二、requestAnimationFrame" class="headerlink" title="二、requestAnimationFrame"></a>二、requestAnimationFrame</h2><p>那有没有时间准确的定时器呢？有一种选择是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">requestAnimationFrame</a>. 示例如下：</p><pre><code class="js"> function animateMe()&#123;    requestAnimationFrame(function()&#123;      console.log(new Date());      animateMe();    &#125;)&#125;animateMe();</code></pre><p>这个api的原理<strong>是在由系统来决定回调函数的执行时机</strong>，在每一次系统绘制之前，会主动调用requestAnimationFrame中的回调函数，而频率也紧紧跟随浏览器的刷新频率。比如一般电脑的刷新频率通常为<code>60Hz</code>，即一秒钟重绘<code>60</code>次，那么回调函数就等于<code>1000/60=16.7</code>毫秒被执行一次，而如果刷新频率变为<code>75Hz</code>，那么这个时间就变为<code>1000/75=13.3</code>毫秒被执行一次。这样能保证回调函数在每一次绘制的间隔时间内只被执行一次，因此它的时间是可靠的。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="阿里前端面试题：requestAnimationFrame实现类似setInterval-setTimeout的计时器"><a href="#阿里前端面试题：requestAnimationFrame实现类似setInterval-setTimeout的计时器" class="headerlink" title="阿里前端面试题：requestAnimationFrame实现类似setInterval,setTimeout的计时器"></a>阿里前端面试题：requestAnimationFrame实现类似setInterval,setTimeout的计时器</h3><pre><code class="js">const RAF = &#123;  intervalTimer: null,  timeoutTimer: null,  setTimeout (cb, interval) &#123; // 实现setTimeout功能    let now = Date.now    let stime = now()    let etime = stime    let loop = () =&gt; &#123;    this.timeoutTimer = requestAnimationFrame(loop)    etime = now()    if (etime - stime &gt;= interval) &#123;      cb()      cancelAnimationFrame(this.timeoutTimer)    &#125;  &#125;    this.timeoutTimer = requestAnimationFrame(loop)    return this.timeoutTimer  &#125;,    clearTimeout () &#123;    cancelAnimationFrame(this.timeoutTimer)  &#125;,  setInterval (cb, interval) &#123; // 实现setInterval功能    let now = Date.now    let stime = now()    let etime = stime    let loop = () =&gt; &#123;      this.intervalTimer = requestAnimationFrame(loop)      etime = now()      if (etime - stime &gt;= interval) &#123;        stime = now()        etime = stime        cb()      &#125;    &#125;    this.intervalTimer = requestAnimationFrame(loop)    return this.intervalTimer  &#125;,    clearInterval () &#123;    cancelAnimationFrame(this.intervalTimer)  &#125;&#125;</code></pre><p>调用：</p><pre><code class="js">let count = 0function a() &#123;console.log(count)count++&#125;RAF.setInterval(a, 1000)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
[原文地址](https://segmentfault.com/a/1190000014661035)

&lt;h2 id=&quot;一-常见定时器&quot;&gt;&lt;a href=&quot;#一-常见定时器&quot; class</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之消息队列与事件循环</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-09-25T08:11:23.000Z</published>
    <updated>2020-09-27T08:37:14.110Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html">原文地址</a></p><h2 id="区分进程与线程"><a href="#区分进程与线程" class="headerlink" title="区分进程与线程"></a>区分进程与线程</h2><p>线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：</p><pre><code class="html">- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）- 工厂之间的相互独立 -&gt; 进程之间相互独立- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</code></pre><p>然后再巩固下：</p><p>如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。</p><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/process_list.png" alt="cpu"></p><p>所以，应该更容易理解了：<strong>进程是cpu资源分配的最小单位（系统会给它分配内存）</strong></p><blockquote><p>最后，再用较为官方的术语描述一遍：</p></blockquote><ul><li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li><li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li></ul><p><strong>tips</strong></p><ul><li>不同进程之间也可以通信，不过代价较大</li><li>现在，一般通用的叫法：<strong>单线程与多线程，都是指在一个进程内的单和多</strong>。（所以核心还是得属于一个进程才行）</li></ul><h2 id="浏览器是属于多进程的"><a href="#浏览器是属于多进程的" class="headerlink" title="浏览器是属于多进程的"></a>浏览器是属于多进程的</h2><blockquote><p>理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</p></blockquote><ul><li>浏览器是多进程的</li><li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li><li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。</li></ul><p><strong>注意</strong>：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了<br>（所以每一个Tab标签对应一个进程并不一定是绝对的）</p><h3 id="浏览器包含哪些进程"><a href="#浏览器包含哪些进程" class="headerlink" title="浏览器包含哪些进程"></a>浏览器包含哪些进程</h3><blockquote><p>知道了浏览器是多进程后，再来看看它<em>到底包含哪些进程</em>：（为了简化理解，仅列举主要进程）</p></blockquote><ul><li><strong>Browser进程</strong>：浏览器的主进程（负责协调、主控），<blockquote><p>只有一个。作用有</p></blockquote></li></ul><p>1.负责浏览器界面显示，与用户交互。如前进，后退等<br>2.负责各个页面的管理，创建和销毁其他进程<br>3.将Renderer进程得到的内存中的Bitmap，绘制到用户界面上<br>4.网络资源的管理，下载等</p><ul><li><strong>第三方插件进程</strong>：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li><strong>GPU进程</strong>：最多一个，用于3D绘制等</li><li><strong>浏览器渲染进程（浏览器内核）</strong>（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为</li><li><strong>页面渲染</strong>，脚本执行，事件处理等</li></ul><p>强化记忆：<strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</strong></p><p>当然，浏览器有时<strong>会将多个进程合并</strong>（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程</p><p>另外，可以通过Chrome的<code>更多工具 -&gt; 任务管理器</code>自行验证</p><h3 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h3><blockquote><p>相比于单进程浏览器，多进程有如下优点：</p></blockquote><ul><li>避免单个page crash影响整个浏览器</li><li>避免第三方插件crash影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性<br>简单点理解：<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势</strong></li></ul><p>当然，内存等资源消耗也会更大，有点空间换时间的意思。</p><h3 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）</h3><p>重点来了，我们可以看到，上面提到了这么多的进程，那么，<strong>对于普通的前端操作来说，最终要的是什么呢？答案是渲染进程</strong></p><p>可以这样理解，<code>页面的渲染，JS的执行，事件的循环</code>，都在这个进程内进行。接下来重点分析这个进程</p><p>请牢记，<strong>浏览器的渲染进程是多线程的</strong>（这点如果不理解，请回头看进程和线程的区分）</p><p>看看它都包含了哪些线程（列举一些主要常驻线程）：</p><h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h4><p>负责渲染浏览器界面，解析<code>HTML</code>，<code>CSS</code>，构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。<br>当界面需要<code>重绘（Repaint）</code>或由于某种操作引发<code>回流(reflow)</code>时，该线程就会执行<br>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p><h4 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h4><p>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）<br>JS引擎线程负责解析Javascript脚本，运行代码。<br>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序<br>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p><em>归属于浏览器而不是JS引擎，用来控制事件循环</em>（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）<br>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中<br>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</p><p><strong>注意</strong>，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</p><h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><p>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程<br>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）<br>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</p><p><strong>注意</strong>，W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms。</p><h4 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h4><p>在<code>XMLHttpRequest</code>在连接后是通过浏览器新开一个线程请求<br>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</p><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/browser_inner_thread.png" alt="浏览器内核"></p><p><strong>为什么JS引擎是单线程的？</strong> 这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。</p><h3 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程</h3><p>看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，<br>这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。</p><p>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），<br>然后在这前提下，看下整个的过程：(简化了很多)</p><ul><li><p>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过<code>RendererHost接口</code>传递给<code>Render进程</code></p></li><li><p>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</p></li></ul><ol><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要<code>GPU进程</code>来帮助渲染</li><li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li><li>最后Render进程将结果传递给<code>Browser进程</code></li></ol><ul><li>Browser进程接收到结果并将结果绘制出来</li></ul><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/browser_rending_interact.png" alt="流程"></p><h2 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系</h2><h3 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h3><p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，<br>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p><h3 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h3><p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p><p>譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。<br>然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p><p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h3 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h3><p>前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？</p><p>所以，后来HTML5中支持了<code>Web Worker</code>。</p><p><strong>MDN的官方解释是</strong>：</p><pre><code class="html">Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误</code></pre><p>这样理解下：</p><ul><li>创建<code>Worker</code>时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS引擎线程与<code>worker</code>线程间通过特定的方式通信（<code>postMessage API</code>，需要通过序列化对象来与线程交互特定的数据）</li></ul><p>所以，如果有非常耗时的工作，请单独开一个<code>Worker</code>线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!</p><p>而且注意下，<strong>JS引擎是单线程的</strong>，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><h3 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h3><p>既然都到了这里，就再提一下<code>SharedWorker</code>（避免后续将这两个概念搞混）</p><p><code>WebWorker</code>只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</p><p>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</p><p><code>SharedWorker</code>是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</p><p>所以Chrome浏览器为<code>SharedWorker</code>单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个<code>SharedWorker</code>进程，不管它被创建多少次。<br>看到这里，应该就很容易明白了，<strong>本质上就是进程和线程的区别</strong>。<code>SharedWorker</code>由独立的进程管理，<code>WebWorker</code>只是属于render进程下的一个线程</p><h2 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h2><p>为了简化理解，前期工作直接省略成：</p><pre><code class="html">- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程- 浏览器渲染流程开始浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：1.解析html建立dom树2.解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）3.布局render树（Layout/reflow），负责各元素尺寸、位置的计算4.绘制render树（paint），绘制页面像素信息5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</code></pre><p>所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p><p>既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。</p><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/browser_rending.png" alt="渲染过程"></p><h3 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h3><p>上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？</p><p>很简单，知道它们的定义就可以了：</p><blockquote><p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。(譬如如果有async加载的脚本就不一定完成)</p></blockquote><blockquote><p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。(渲染完毕了)</p></blockquote><p>所以，顺序是：<code>DOMContentLoaded -&gt; load</code></p><h3 id="css加载是否会阻塞dom树渲染？"><a href="#css加载是否会阻塞dom树渲染？" class="headerlink" title="css加载是否会阻塞dom树渲染？"></a>css加载是否会阻塞dom树渲染？</h3><p>这里说的是头部引入css的情况</p><p>首先，我们都知道：<strong>css是由单独的下载线程异步下载的</strong>。</p><p>然后再说下几个现象：</p><blockquote><p>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）<br>但会阻塞render树渲染(渲染时需等css加载完毕，因为render树需要css信息)<br>这可能也是浏览器的一种优化机制。</p></blockquote><p>因为你加载css的时候，可能会修改下面DOM节点的样式，<br>如果css加载不阻塞render树渲染的话，那么当css加载完之后，<br>render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。<br>所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，</p><p>在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p><h2 id="从Event-Loop谈JS的运行机制"><a href="#从Event-Loop谈JS的运行机制" class="headerlink" title="从Event Loop谈JS的运行机制"></a>从Event Loop谈JS的运行机制</h2><p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。</p><p>注意，这里不谈可执行上下文，<code>VO，scop chain</code>等概念（这些完全可以整理成另一篇文章了），这里主要是结合<code>Event Loop</code>来谈JS代码是如何执行的。</p><p>读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）</p><blockquote><p>JS引擎线程</p></blockquote><ul><li>事件触发线程</li><li>定时触发器线程</li></ul><blockquote><p>然后再理解一个概念：</p></blockquote><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/js_event_loop.png" alt="图"></p><p>看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在<strong>它推入到事件列表时，主线程还不空闲，正在执行其它代码</strong>，<br>所以自然有误差。</p><h3 id="事件循环机制进一步补充"><a href="#事件循环机制进一步补充" class="headerlink" title="事件循环机制进一步补充"></a>事件循环机制进一步补充</h3><p>这里就直接引用一张图片来协助理解：（参考自<a href="http://vimeo.com/96425312">Philip Roberts的演讲《Help, I’m stuck in an event-loop》</a>）</p><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/js_event_loop2.png" alt="事件循环"></p><blockquote><p>上图大致描述就是：</p></blockquote><ul><li>主线程运行时会产生执行栈，</li><li>栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）</li><li>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</li></ul><p>如此循环<br><strong>注意</strong>，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件(栈执行完,才会执行队列中的事件)</p><h3 id="单独说说定时器"><a href="#单独说说定时器" class="headerlink" title="单独说说定时器"></a>单独说说定时器</h3><p>上述事件循环机制的核心是：JS引擎线程和事件触发线程</p><p>但事件上，里面还有一些隐藏细节，譬如<em>调用setTimeout后，是如何等待特定时间后才添加到事件队列中的</em>？</p><p>是JS引擎检测的么？当然不是了。它是由<code>定时器线程控制</code>（因为JS引擎自己都忙不过来，根本无暇分身）</p><p><strong>为什么要单独的定时器线程</strong>？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</p><p><strong>什么时候会用到定时器线程</strong>？当使用<code>setTimeout</code>或<code>setInterval</code>时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p><p>譬如:</p><pre><code class="js">setTimeout(function()&#123;    console.log(&#39;hello!&#39;);&#125;, 1000);</code></pre><p>这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</p><pre><code class="js">setTimeout(function()&#123;    console.log(&#39;hello!&#39;);&#125;, 0);console.log(&#39;begin&#39;);</code></pre><p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行</p><p>注意：</p><p>执行结果是：<code>先begin后hello!</code></p><p>虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定<strong>要求setTimeout中低于4ms的时间间隔算为4ms</strong>。<br>(不过也有一说是不同浏览器有不同的最小时间设定)</p><p>就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列）</p><h3 id="setTimeout而不是setInterval"><a href="#setTimeout而不是setInterval" class="headerlink" title="setTimeout而不是setInterval"></a>setTimeout而不是setInterval</h3><p>用<code>setTimeout</code>模拟定期计时和直接用<code>setInterval</code>是有区别的。</p><p>因为每次<code>setTimeout</code>计时到后就会去执行，然后执行一段时间后才会继续<code>setTimeout</code>，中间就多了误差<br>（误差多少与代码执行时间有关）</p><p>而<code>setInterval</code>则是每次都精确的隔一段时间推入一个事件<br>（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</p><p>而且<code>setInterval</code>有<strong>一些比较致命的问题</strong>就是：</p><ul><li>某些间隔会被跳过（丢帧现象）</li><li>定时器之间的间隔会比预期小</li></ul><p>把浏览器最小化显示等操作时，<code>setInterval</code>并不是不执行程序，<br>它会把<code>setInterval</code>的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时</p><p>所以，鉴于这么多但问题，目前一般认为的最佳方案是：用<code>setTimeout</code>模拟<code>setInterval</code>，或者特殊场合直接用<code>requestAnimationFrame</code></p><pre><code class="js">// setTimeout模拟setTimeIntervallet count = 0;let timerId = null;timerId = setTimeout(function run() &#123;  console.log(&quot;run -&gt; &quot;, count);  if (count &gt;= 3) &#123;    clearTimeout(timerId);    return;  &#125;  count += 1;  timerId = setTimeout(run, 1000);&#125;, 1000);</code></pre><p>补充：JS高程中有提到，JS引擎会对<code>setInterval</code>进行优化，如果当前事件队列中有<code>setInterval</code>的回调，不会重复添加。不过，仍然是有很多问题。。。</p><h2 id="事件循环进阶：macrotask与microtask"><a href="#事件循环进阶：macrotask与microtask" class="headerlink" title="事件循环进阶：macrotask与microtask"></a>事件循环进阶：macrotask与microtask</h2><p>这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下），<br>强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：</p><p>(<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)[https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/]">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)[https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/]</a></p><p>上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：</p><pre><code class="js">console.log(&#39;script start&#39;);setTimeout(function() &#123;    console.log(&#39;setTimeout&#39;);&#125;, 0);Promise.resolve().then(function() &#123;    console.log(&#39;promise1&#39;);&#125;).then(function() &#123;    console.log(&#39;promise2&#39;);&#125;);console.log(&#39;script end&#39;);// 执行顺序/* script startscript endpromise1promise2setTimeout */</code></pre><p>为什么呢？因为<code>Promise</code>里有了一个一个新的概念：<code>microtask</code></p><p>或者，进一步，JS中分为两种任务类型：<code>macrotask和microtask</code>，在ECMAScript中，<code>microtask称为jobs，macrotask可称为task</code></p><blockquote><p>它们的定义？区别？简单点可以按如下理解：</p></blockquote><ul><li><code>macrotask</code>（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li></ul><p>每一个task会从头到尾将这个任务执行完毕，不会执行其它<br>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染<br>（<code>task-&gt;渲染-&gt;task-&gt;...</code>）</p><ul><li><code>microtask</code>（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</li></ul><p>也就是说，在当前task任务后，下一个task之前，在渲染之前<br>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染</p><p>也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）</p><p>分别什么样的场景会形成<code>macrotask</code>和<code>microtask</code>呢？</p><ul><li><strong>macrotask：主代码块，setTimeout，setInterval等</strong>（可以看到，事件队列中的每一个事件都是一个macrotask）</li><li><strong>microtask：Promise，process.nextTick等</strong></li></ul><p>补充：在node环境下，<code>process.nextTick</code>的优先级高于<code>Promise</code>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的<code>nextTickQueue</code>部分，然后才会执行微任务中的<code>Promise</code>部分。</p><p>参考：(<a href="https://segmentfault.com/q/1010000011914016)[https://segmentfault.com/q/1010000011914016]">https://segmentfault.com/q/1010000011914016)[https://segmentfault.com/q/1010000011914016]</a></p><p>再根据线程来理解下：</p><ul><li><code>macrotask</code>中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护;</li><li><code>microtask</code>中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前<code>macrotask</code>执行完毕后执行，而这个队列由JS引擎线程维护<br>（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</li></ul><blockquote><p>所以，总结下运行机制：</p></blockquote><ol><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li><li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li></ol><p><img src="https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/js_macrotask_microtask.png" alt="如图"></p><p>另外，请注意下<code>Promise</code>的<code>polyfill</code>与官方版本的区别：</p><ul><li>官方版本中，是标准的microtask形式</li><li><code>polyfill</code>，一般都是通过setTimeout模拟的，所以是macrotask形式</li></ul><p>请特别注意这两点区别<br>注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），<br>但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p><p><strong>使用MutationObserver实现microtask</strong></p><p><code>MutationObserver</code>可以用来实现microtask<br>（它属于microtask，优先级小于Promise，一般是Promise不支持时才会这样做）</p><p><strong>它是HTML5中的新特性，作用是：监听一个DOM变动，</strong><br>当DOM对象树发生任何变动时，<code>Mutation Observer</code>会得到通知</p><p>像以前的Vue源码中就是<strong>利用它来模拟nextTick的</strong>，</p><p><strong>具体原理</strong>是，创建一个<code>TextNode</code>并监听内容变化，然后要<code>nextTick</code>的时候去改一下这个节点的文本内容，</p><p>如下：（Vue的源码，未修改）</p><pre><code class="js">var counter = 1var observer = new MutationObserver(nextTickHandler)var textNode = document.createTextNode(String(counter))observer.observe(textNode, &#123;    characterData: true&#125;)timerFunc = () =&gt; &#123;    counter = (counter + 1) % 2    textNode.data = String(counter)&#125;</code></pre><p><a href="https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95">vue对应源码链接</a></p><p>不过，现在的<code>Vue（2.5+）</code>的nextTick实现<strong>移除了MutationObserver的方式</strong>（据说是兼容性原因），<br>取而代之的是使用<strong>MessageChannel</strong><br>（当然，默认情况仍然是Promise，不支持才兼容的）。</p><p><strong>MessageChannel</strong>属于宏任务，优先级是：<code>MessageChannel-&gt;setTimeout</code>，<br>所以<code>Vue（2.5+）</code>内部的nextTick与2.4及之前的实现是不一样的，需要注意下。</p><p>这里不展开，可以看下(地址)[<a href="https://juejin.im/post/5a1af88f5188254a701ec230]">https://juejin.im/post/5a1af88f5188254a701ec230]</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之数据结构</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-09-25T08:10:59.000Z</published>
    <updated>2020-09-25T08:12:17.099Z</updated>
    
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之算法</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%AE%97%E6%B3%95/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/25/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-25T07:51:16.000Z</published>
    <updated>2020-09-27T08:37:00.920Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法应该算是高级前端工程是的必备技能了,接下来排列下,我知道的一些算法及应该掌握的算法</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p><a href="https://juejin.im/post/6844903444365443080">排序</a></p><h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><p><a href="https://singsing.io/blog/tags/FreeCodeCamp/page/5/">leetcode</a></p><h2 id="JavaScript-数据结构与算法之美"><a href="#JavaScript-数据结构与算法之美" class="headerlink" title="JavaScript 数据结构与算法之美"></a>JavaScript 数据结构与算法之美</h2><p><a href="https://github.com/biaochenxuying/blog/issues/43">数据结构与算法之美</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;p&gt;算法应该算是高级前端工程是的必备技能了,接下来</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之递归</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/24/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/24/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%80%92%E5%BD%92/</id>
    <published>2020-09-24T06:05:16.000Z</published>
    <updated>2020-09-24T07:56:03.634Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ruanyf/es6tutorial/blob/2e1c10776a9350debfec47de8ddeaf1c2c5a80cc/docs/function.md">原文地址</a></p><h1 id="递归简介"><a href="#递归简介" class="headerlink" title="递归简介"></a>递归简介</h1><blockquote><p>一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。</p></blockquote><p>在看递归之前，你首先要明白”<strong>栈</strong>“的知识，知道的太多不好，你只需记住  <code>栈---“后进先出”</code>，就能了。</p><h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>递归的意思就是函数自己调用自己本身，或者在自己函数调用的下级函数中调用自己。</p><blockquote><p>在程序中函数直接或间接调用自己</p></blockquote><ol><li>直接调用自己</li><li>间接调用自己<br>· 跳出结构,有了跳出才有结果</li></ol><h2 id="递归的思想"><a href="#递归的思想" class="headerlink" title="递归的思想"></a>递归的思想</h2><p>· 递归的调用,最终还是要转换为自己这个函数</p><ol><li>如果有个函数foo,如果他是递归函数,到最后问题还是转换为函数foo的形式</li><li>递归的思想就是将一个未知问题转换为一个已解决的问题来实现</li></ol><p>简单的理解：递归就是<em>程序运行到某个点的时候，调用自身，这个时候，之前没运行完的程序会暂时不运行，等到下一层调用完了之后再运行</em>。这个正是符合栈的先进后出。这个时候就会有个进栈，等到下一层调用完运行了，之后就可以出栈继续运行</p><pre><code class="js">function foo()&#123;  ...foo(...)...&#125;</code></pre><h2 id="递归的步骤-技巧"><a href="#递归的步骤-技巧" class="headerlink" title="递归的步骤(技巧)"></a>递归的步骤(技巧)</h2><ol><li>假设递归函数已经写好</li><li>寻找递推关系</li><li>将递推关系的结构转换为递归体</li><li>将临界条件加入到递归体中</li></ol><blockquote><p>递归的两个必要因素：<br><strong>递归方程，递归结束条件。</strong></p></blockquote><p>我们来举个例子，我们可以用4的阶乘乘以4来定义5的阶乘，3的阶乘乘以4来定义4的阶乘，以此类推。</p><pre><code class="js">factorial(5) = factorial(4) * 5factorial(5) = factorial(3) * 4 * 5factorial(5) = factorial(2) * 3 * 4 * 5factorial(5) = factorial(1) * 2 * 3 * 4 * 5factorial(5) = factorial(0) * 1 * 2 * 3 * 4 * 5factorial(5) = 1 * 1 * 2 * 3 * 4 * 5</code></pre><p>用<code>Haskell</code>的<code>Pattern matching</code> 可以很直观的定义<code>factorial</code>函数:</p><pre><code class="js">factorial n = factorial (n-1)  * nfactorial 0 = 1</code></pre><h2 id="什么是尾调用"><a href="#什么是尾调用" class="headerlink" title="什么是尾调用"></a>什么是尾调用</h2><p><code>尾调用（Tail Call）</code>是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是<strong>指某个函数的最后一步是调用另一个函数</strong>。</p><pre><code class="js">function f(x)&#123;  return g(x);&#125;</code></pre><p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</p><pre><code class="js">// 情况一function f(x)&#123;  let y = g(x);  return y;  //情况一是调用函数g之后，还有赋值操作，所以不属于尾调用&#125;// 情况二function f(x)&#123;  return g(x) + 1;  //属于调用后还有操作，即使写在一行内&#125;// 情况三function f(x)&#123;  g(x);&#125;// 等同于下面的代码。/* function f(x)&#123;  g(x);  return undefined;&#125; */</code></pre><p><strong>尾调用不一定出现在函数尾部</strong>，只要是最后一步操作即可。</p><pre><code class="js">function f(x) &#123;  if (x &gt; 0) &#123;    return m(x)  &#125;  return n(x);&#125;//函数m和n都属于尾调用，因为它们都是函数f的最后一步操作</code></pre><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><p>尾调用之所以与其他调用不同，就在于它的<strong>特殊的调用位置</strong>。</p><p><strong>调用栈概念</strong></p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）</p><p>尾调用由于是<strong>函数的最后一步操作，所以不需要保留外层函数的调用帧</strong>，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了</p><pre><code class="js">function f() &#123;  let m = 1;  let n = 2;  return g(m + n);&#125;f();// 等同于function f() &#123;  return g(3);&#125;f();// 等同于g(3);</code></pre><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p><p>这就叫做<code>“尾调用优化”（Tail call optimization）</code>，即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“<strong>尾调用优化</strong>”的意义。</p><pre><code class="js">function addOne(a)&#123;  var one = 1;  function inner(b)&#123;    return b + one;  &#125;  return inner(a);&#125;</code></pre><p>上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。</p><p><font color="red"><strong>注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</strong></font></p><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p><strong>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</strong></p><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生<code>“栈溢出”错误（stack overflow</code>）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p><pre><code class="js">function factorial(n) &#123;  if (n === 1) return 1;  return n * factorial(n - 1);&#125;factorial(5) // 120</code></pre><p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，**复杂度 O(n) **。</p><p>如果改写成尾递归，只保留一个调用记录，<strong>复杂度 O(1)</strong> 。</p><pre><code class="js">function factorial(n, total) &#123;  if (n === 1) return total;  return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120</code></pre><p>还有一个比较著名的例子，就是计算 <code>Fibonacci 数列</code>，也能充分说明尾递归优化的重要性。</p><p>非尾递归的 <code>Fibonacci 数列</code>实现如下。</p><pre><code class="js">function Fibonacci (n) &#123;  if ( n &lt;= 1 ) &#123;return 1&#125;;  return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 超时Fibonacci(500) // 超时</code></pre><p>尾递归优化过的 <code>Fibonacci 数列</code>实现如下。</p><pre><code class="js">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;  if( n &lt;= 1 ) &#123;return ac2&#125;;  return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity</code></pre><p>由此可见，<strong>“尾调用优化”对递归操作意义重大</strong>，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，<strong>ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存</strong>。</p><h2 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h2><p><strong>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身</strong>。做到这一点的方法，就是<strong>把所有用到的内部变量改写成函数的参数</strong>。比如上面的例子，阶乘函数 <code>factorial</code> 需要用到一个中间变量<code>total</code>，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，<code>为什么计算5的阶乘，需要传入两个参数5和1？</code></p><p>两个方法可以解决这个问题。方法一<strong>是在尾递归函数之外，再提供一个正常形式的函数</strong>。</p><pre><code class="js">function tailFactorial(n, total) &#123;  if (n === 1) return total;  return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123;  return tailFactorial(n, 1);&#125;factorial(5) // 120</code></pre><p>上面代码通过一个正常形式的<code>阶乘函数factorial</code>，调用<code>尾递归函数tailFactorial</code>，看起来就正常多了。</p><p>函数式编程有一个概念，叫做<strong>柯里化（currying）</strong>，意思是将<strong>多参数的函数转换成单参数的形式</strong>。这里也可以使用柯里化。</p><pre><code class="js">function currying(fn, n) &#123;  return function (m) &#123;    return fn.call(this, m, n);  &#125;;&#125;function tailFactorial(n, total) &#123;  if (n === 1) return total;  return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120</code></pre><p>上面代码<code>通过柯里化，将尾递归函数tailFactorial</code>变为只接受一个参数的<code>factorial</code>。</p><p><strong>第二种方法就简单多了，就是采用 ES6 的函数默认值。</strong></p><pre><code class="js">function factorial(n, total = 1) &#123;  if (n === 1) return total;  return factorial(n - 1, n * total);&#125;factorial(5) // 120</code></pre><p>上面代码中，参数total有默认值1，所以调用时不用提供这个值。</p><p>总结一下，递归本质上<strong>是一种循环操作</strong>。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道<strong>循环可以用递归代替，而一旦使用递归，就最好使用尾递归</strong>。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p><font color="red">ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</font></p><blockquote><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p></blockquote><p><code>func.arguments</code>：返回调用时函数的参数。<br><code>func.caller</code>：返回调用当前函数的那个函数。</p><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><pre><code class="js">function restricted() &#123;  &#39;use strict&#39;;  restricted.caller;    // 报错  restricted.arguments; // 报错&#125;restricted();</code></pre><h2 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h2><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是<strong>自己实现尾递归优化</strong>。</p><p>它的原理非常简单。尾递归之所以需要优化，原因<em>是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出</em>。怎么做可以减少调用栈呢？就是采用 <strong>“循环”换掉“递归”</strong>。</p><p>下面是一个正常的递归函数。</p><pre><code class="js">function sum(x, y) &#123;  if (y &gt; 0) &#123;    return sum(x + 1, y - 1);  &#125; else &#123;    return x;  &#125;&#125;sum(1, 100000)// Uncaught RangeError: Maximum call stack size exceeded(…)</code></pre><p>上面代码中，<code>sum</code>是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定<code>sum</code>递归 100000 次，就会报错，提示超出调用栈的最大次数。</p><p><code>蹦床函数（trampoline）</code>可以将递归执行转为循环执行。</p><pre><code class="js">function trampoline(f) &#123;  while (f &amp;&amp; f instanceof Function) &#123;    f = f();  &#125;  return f;&#125;</code></pre><p>上面就是蹦床函数的一个实现，<em>它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题</em>。</p><p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p><pre><code class="js">function sum(x, y) &#123;  if (y &gt; 0) &#123;    return sum.bind(null, x + 1, y - 1);  &#125; else &#123;    return x;  &#125;&#125;</code></pre><p>上面代码中，sum函数的每次执行，都会返回自身的另一个版本。</p><p>现在，使用蹦床函数执行sum，就不会发生调用栈溢出。</p><pre><code class="js">trampoline(sum(1, 100000))// 100001</code></pre><p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p><pre><code class="js">function tco(f) &#123;  var value;  var active = false;  var accumulated = [];  return function accumulator() &#123;    accumulated.push(arguments);    if (!active) &#123;      active = true;      while (accumulated.length) &#123;        value = f.apply(this, accumulated.shift());      &#125;      active = false;      return value;    &#125;  &#125;;&#125;var sum = tco(function(x, y) &#123;  if (y &gt; 0) &#123;    return sum(x + 1, y - 1)  &#125;  else &#123;    return x  &#125;&#125;);sum(1, 100000)// 100001</code></pre><p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮sum执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/ruanyf/es6tutorial/blob/2e1c10776a9350debfec47de8ddeaf1c2c5a80cc/docs/function.md&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;递归简介&quot;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之立即执行函数, 模块化, 命名空间</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/22/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/22/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</id>
    <published>2020-09-22T05:45:52.000Z</published>
    <updated>2020-09-27T08:32:50.536Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://segmentfault.com/a/1190000006966358">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>立即执行函数, 模块化, 命名空间 ，主要是解决两个问题——“<strong>命名空间冲突”，“文件依赖管理</strong>”。</p><p>坑：<br>1.命名空间冲突</p><ul><li>(1)我自己测试好的代码和大家合并后怎么起冲突了？</li><li>(2)页面脚本的变量或函数覆盖了公有脚本的。                                                 </li></ul><p>2.文件依赖管理</p><ul><li>(1)明明项目需要引入的包都引进来了怎么还报缺少包？</li><li>(2)手动管理依赖，有天要更换某个插件，要深入代码内部进行修改</li><li>(3)如下图，显示的代码加载，依赖关系复杂。在F.js中，分不清某个变量是来自C.js，还是E.js</li><li>(4)两次加载同一个模块。比如引入了两遍JQ</li></ul><p><img src="https://segmentfault.com/img/bVDlA5?w=398&h=183" alt="keng"></p><p>3.其他的</p><ul><li>(1)为了实现脚本复用，将一个很大的公用public文件引入各个页面中，其中的某些函数，只有个别页面用到。</li><li>(2)某个功能的函数群函数，与另一个功能的函数群摆在一起，使用注释来分隔。</li></ul><p><strong>目前解决的方法是:模块化</strong></p><p>1.<em>命名空间</em>：各个模块的命名空间独立。A模块的变量x不会覆盖B模块的变量x。<br>2.<em>模块的依赖关系</em>:通过模块管理工具如<code>webpack/requireJS/browserify</code>等进行管理。</p><h2 id="模块化的基本原理——解决命名空间冲突"><a href="#模块化的基本原理——解决命名空间冲突" class="headerlink" title="模块化的基本原理——解决命名空间冲突"></a>模块化的基本原理——解决命名空间冲突</h2><p>JavaScript的缺陷，首当其冲就是全局变量。这使得每想命名一个变量的时候都要三思又三思，生怕上方无穷远的地方有一个同事些的代码和自己冲突。以下是一些防范方法</p><h3 id="一、使用命名空间"><a href="#一、使用命名空间" class="headerlink" title="一、使用命名空间"></a>一、使用命名空间</h3><p>代码如下：</p><pre><code class="js">//定义var module = &#123;    name: &#39;rouwan&#39;,    sayName:function()&#123;        console.log(this.name)    &#125;&#125;//使用var a = module.name;console.log(a)</code></pre><p><strong>总结</strong>：直接修改name不会影响<code>module.name</code>，一定程度保护了命名空间。<br>有两个缺点，一，外部还是可以修改module的属性和方法。二，命名空间有时长起来超乎你的想象。适合一些小型的封装，如一些配置。</p><h3 id="二、立即执行函数-闭包（实现模块的基本方法）"><a href="#二、立即执行函数-闭包（实现模块的基本方法）" class="headerlink" title="二、立即执行函数 + 闭包（实现模块的基本方法）"></a>二、立即执行函数 + 闭包（实现模块的基本方法）</h3><p>立即函数可以创建作用域，闭包则可以形成私有变量和函数</p><pre><code class="js">//创建var module = (function()&#123;  var privateName = &#39;inner&#39;;            //私有变量  var privateFunc = function()&#123;        //私有函数      console.log(&#39;私有函数&#39;)  &#125;  return &#123;                                  name: &#39;rouwan&#39;,                    //公有属性      sayName:function()&#123;                //公有函数          console.log(this.name)      &#125;  &#125;&#125;)()//使用module.sayName();    //&#39;rouwan&#39;</code></pre><p>总结：这是目前比较常用的模块定义方式，<strong>可以区分私有成员和公有成员</strong>。<br>公有变量和方法，和之前一样可以直接通过<code>module.name</code>的方式修改。私有变量和方法，是无法访问的，除非给你个修改私有成员的公有方法。</p><h3 id="三、在上述基础上，引入其他模块"><a href="#三、在上述基础上，引入其他模块" class="headerlink" title="三、在上述基础上，引入其他模块"></a>三、在上述基础上，引入其他模块</h3><pre><code class="js">//定义var module1 = (function(mod)&#123;  var privateName = &#39;inner1&#39;;  var privateFunc = function()&#123;    console.log(&#39;私有函数1&#39;)  &#125;  return &#123;    name : &#39;rouwan1&#39;,    sayName: function()&#123;        console.log(this.name)    &#125;,    anotherName:mod.name,            //另一个模块上的公有参数    sayAnotherName:mod.sayName       //另一个模块上的公有方法  &#125;&#125;)(anotherModule) //引入了另一个模块//使用module1.sayOtherName()</code></pre><h3 id="四、其他的方式"><a href="#四、其他的方式" class="headerlink" title="四、其他的方式"></a>四、其他的方式</h3><p>放大模式等是以往用来管理大型模块，进行文件拆分的方法。现在<code>webpack</code>等模块化工具都很完善的情况下，已经显得有点落后了。就不介绍了。</p><h2 id="告别刀耕火种的时代——模块化构建工具（解决依赖管理）"><a href="#告别刀耕火种的时代——模块化构建工具（解决依赖管理）" class="headerlink" title="告别刀耕火种的时代——模块化构建工具（解决依赖管理）"></a>告别刀耕火种的时代——模块化构建工具（解决依赖管理）</h2><p>我了解js模块是从<strong>立即执行函数</strong>开始的。但是等到真正使用构建工具的时候，却发现业界采用的模块化方案，却并非是<strong>一个一个由立即函数+闭包</strong>形成的集群。</p><p>而是用了诸如<strong>AMD/CMD/CommonJS/ES6</strong>模块等等模块化实现。</p><p>这里面的原因可能有这几个，<br>一，闭包的性能问题。<br>二，当模块增多的时候，需要解决模块间的依赖管理问题。</p><p>关于依赖管理，目前项目里碰到了几个不舒服的地方：</p><p>1.引用多个不同的文件<br>2.HTML中引入了两遍的jq，导致脚本报错。<br>3.有一个公用脚本，包含了N多的公用模块。有些页面明明只用到了一个模块，也必须全部加载一遍。</p><p>因此，必须使用模块化管理工具!</p><p>webpack和requireJS比较：<br><img src="https://segmentfault.com/img/bVDm01?w=746&h=254" alt="webpack和requireJS"></p><p>几种模块化规范比较：<br><img src="https://segmentfault.com/img/bVDm2P?w=890&h=316" alt="模块化"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000006966358&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之promise</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/21/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bpromise/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/21/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bpromise/</id>
    <published>2020-09-21T06:24:41.000Z</published>
    <updated>2020-09-27T08:44:35.052Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>promise</code>是一个对象，它代表了一个异步操作的最终完成或者失败。本质上<code>Promise</code>是个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。</p><pre><code class="js">const promise1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(&#39;foo&#39;);  &#125;, 3000);&#125;);promise1.then((value) =&gt; &#123;  console.log(value);  // expected output: &quot;foo&quot;&#125;);console.log(promise1);// expected output: [object Promise]</code></pre><h2 id="promise-约定"><a href="#promise-约定" class="headerlink" title="promise 约定"></a>promise 约定</h2><p>在使用<code>Promise</code>时会有以下约定：</p><ul><li>1.在本轮 事件循环 运行完成之前，回调函数是不会被调用的。</li><li>2.即使异步操作已经完成（成功或失败），在这之后通过 <code>then()</code> 添加的回调函数也会被调用。</li><li>3.通过多次调用 <code>then()</code> 可以添加多个回调函数，它们会按照插入顺序进行执行。</li></ul><p><code>Promise</code>的另一个好处就是<strong>链式调用(chaining)</strong></p><p>原有的回调地狱：</p><pre><code class="js">doSomething(function(result) &#123;  doSomethingElse(result, function(newResult) &#123;    doThirdThing(newResult, function(finalResult) &#123;      console.log(&#39;Got the final result: &#39; + finalResult);    &#125;, failureCallback);  &#125;, failureCallback);&#125;, failureCallback);</code></pre><p>Promise链：</p><pre><code class="js">doSomething().then(function(result) &#123;  return doSomethingElse(result);&#125;).then(function(newResult) &#123;  return doThirdThing(newResult);&#125;).then(function(finalResult) &#123;  console.log(&#39;Got the final result: &#39; + finalResult);&#125;).catch(failureCallback);</code></pre><p>通常，一遇到异常抛出，浏览器就会顺着 <code>Promise</code> 链寻找下一个 <code>onRejected</code> 失败回调函数或者由 <code>.catch()</code> 指定的回调函数。这和以下同步代码的工作原理（执行过程）非常相似。</p><pre><code class="js">try &#123;  let result = syncDoSomething();  let newResult = syncDoSomethingElse(result);  let finalResult = syncDoThirdThing(newResult);  console.log(`Got the final result: $&#123;finalResult&#125;`);&#125; catch(error) &#123;  failureCallback(error);&#125;</code></pre><p>在 ECMAScript 2017 标准的 <code>async/await</code> 语法糖中，这种异步代码的对称性得到了极致的体现：</p><pre><code class="js">async function foo() &#123;  try &#123;    const result = await doSomething();    const newResult = await doSomethingElse(result);    const finalResult = await doThirdThing(newResult);    console.log(`Got the final result: $&#123;finalResult&#125;`);  &#125; catch(error) &#123;    failureCallback(error);  &#125;&#125;</code></pre><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>Promise</code> 对象是<strong>一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的</strong>。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的<code>promise</code>对象&gt; </p><blockquote><p>一个 <code>Promise</code>有以下几种状态:<br><code>pending</code>: 初始状态，既不是成功，也不是失败状态。<br><code>fulfilled</code>: 意味着操作成功完成。<br><code>rejected</code>: 意味着操作失败。</p></blockquote><p><img src="https://mdn.mozillademos.org/files/8633/.png" alt="promise"></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h3><p>这个方法返回一个新的<code>promise</code>对象，该<code>promise</code>对象在<code>iterable</code>参数对象里所有的<code>promise</code>对象都成功的时候才会触发成功，一旦有任何一个iterable里面的<code>promise</code>对象失败则立即触发该<code>promise</code>对象的失败</p><pre><code class="js">const arr = [1,2,3,4];const promiseArr = arr.map(arg =&gt; &#123;    return new Promise((resolve,reject) =&gt; &#123;        if(arg) &#123;            resolve(arg*2);        &#125;else&#123;            reject(&#39;no value&#39;);        &#125;    &#125;)&#125;);Promise.all(promiseArr).then(data =&gt; &#123;    console.log(data);  // [2,4,6,8]&#125;).catch(err =&gt; &#123;    console.log(err); &#125;)</code></pre><h3 id="Promise-allSettled-iterable"><a href="#Promise-allSettled-iterable" class="headerlink" title="Promise.allSettled(iterable)"></a>Promise.allSettled(iterable)</h3><p>等到所有<code>promise</code>都完成（每个<code>promise</code>返回成功或失败）。<br>返回一个<code>promise</code>，该<code>promise</code>在所有<code>promise</code>完成后完成。并带有一个对象数组，每个对象对应每个<code>promise</code>的结果。</p><pre><code class="js">const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, &#39;foo&#39;));const promises = [promise1, promise2];Promise.allSettled(promises).  then((results) =&gt; results.forEach((result) =&gt; console.log(result.status)));// expected output:// &quot;fulfilled&quot;// &quot;rejected&quot;</code></pre><h3 id="Promise-any-iterable"><a href="#Promise-any-iterable" class="headerlink" title="Promise.any(iterable)"></a>Promise.any(iterable)</h3><p>接收一个<code>Promise</code>对象的集合，当其中的一个<code>promise</code> 成功，就返回那个成功的<code>promise</code>的值。(谁成功返回谁,用于返回第一个成功的 promise)</p><pre><code class="js">// 显示第一张已加载的图片function fetchAndDecode(url) &#123;  return fetch(url).then(response =&gt; &#123;    if(!response.ok) &#123;      throw new Error(`HTTP error! status: $&#123;response.status&#125;`);    &#125; else &#123;      return response.blob();    &#125;  &#125;)&#125;let coffee = fetchAndDecode(&#39;coffee.jpg&#39;);let tea = fetchAndDecode(&#39;tea.jpg&#39;);Promise.any([coffee, tea]).then(value =&gt; &#123;  let objectURL = URL.createObjectURL(value);  let image = document.createElement(&#39;img&#39;);  image.src = objectURL;  document.body.appendChild(image);&#125;).catch(e =&gt; &#123;  console.log(e.message);&#125;);</code></pre><h3 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h3><p>执行顺序是按照谁快 谁先输出</p><p>当<code>iterable</code>参数里的任意一个子<code>promise</code>被成功或失败后，父<code>promise</code>马上也会用子<code>promise</code>的成功返回值或失败详情作为参数调用父<code>promise</code>绑定的相应句柄，并返回该<code>promise</code>对象。</p><pre><code class="js">const pro1 = new Promise((resolve,reject) =&gt; &#123;    setTimeout(resolve,100,&#39;1&#39;);&#125;);const pro2 = new Promise((resolve,reject) =&gt; &#123;    setTimeout(resolve,200,&#39;2&#39;);&#125;);const pro3 = new Promise((resolve,reject) =&gt; &#123;    setTimeout(resolve,300,&#39;3&#39;);&#125;);const pro4 = new Promise((resolve,reject) =&gt; &#123;    setTimeout(resolve,10,&#39;4&#39;);&#125;);Promise.race([pro4,pro1,pro2,pro3]).then(data =&gt; &#123;    console.log(data);  // 1   输出最快的那个&#125;).catch(err =&gt; &#123;    console.log(err);&#125;)</code></pre><h3 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h3><p>返回一个状态为失败的<code>Promise</code>对象，并将给定的失败信息传递给对应的处理方法</p><pre><code class="js">const p_2 = Promise.reject(&#39;err&#39;);p_2.then(data =&gt; &#123;    console.log(data);  &#125;).catch(err =&gt; &#123;    console.log(err);  // err&#125;)</code></pre><h3 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h3><p>返回一个状态由给定<code>value</code>决定的<code>Promise</code>对象。<br>通常而言，如果你不知道一个值是否是<code>Promise</code>对象，使用<code>Promise.resolve(value)</code> 来返回一个<code>Promise</code>对象,这样就能将该value以<code>Promise</code>对象形式使用。</p><pre><code class="js">const p_1 = Promise.resolve(&#39;success&#39;);p_1.then(data =&gt; &#123;    console.log(data);   // success&#125;)2</code></pre><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p><code>catch()</code> 方法返回一个<code>Promise</code>，并且处理拒绝的情况。</p><pre><code class="js">//创建一个新的 Promise ，且已决议var p1 = Promise.resolve(&quot;calling next&quot;);var p2 = p1.catch(function (reason) &#123;    //这个方法永远不会调用    console.log(&quot;catch p1!&quot;);    console.log(reason);&#125;);p2.then(function (value) &#123;    console.log(&quot;next promise&#39;s onFulfilled&quot;); /* next promise&#39;s onFulfilled */    console.log(value); /* calling next */&#125;, function (reason) &#123;    console.log(&quot;next promise&#39;s onRejected&quot;);    console.log(reason);&#125;);</code></pre><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><p><code>finally()</code> 方法返回一个<code>Promise</code>。在<code>promise</code>结束时，无论结果是<code>fulfilled</code>或者是<code>rejected</code>，都会执行指定的回调函数。这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式。</p><pre><code class="js">let isLoading = true;fetch(myRequest).then(function(response) &#123;    var contentType = response.headers.get(&quot;content-type&quot;);    if(contentType &amp;&amp; contentType.includes(&quot;application/json&quot;)) &#123;      return response.json();    &#125;    throw new TypeError(&quot;Oops, we haven&#39;t got JSON!&quot;);  &#125;)  .then(function(json) &#123; /* process your JSON further */ &#125;)  .catch(function(error) &#123; console.log(error); &#125;)  .finally(function() &#123; isLoading = false; &#125;);</code></pre><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p><code>then()</code> 方法返回一个 <code>Promise</code>。它最多需要有两个参数：<code>Promise</code> 的成功和失败情况的回调函数。</p><pre><code class="js">var p1 = new Promise((resolve, reject) =&gt; &#123;  resolve(&#39;成功！&#39;);  // or  // reject(new Error(&quot;出错了！&quot;));&#125;);p1.then(value =&gt; &#123;  console.log(value); // 成功！&#125;, reason =&gt; &#123;  console.error(reason); // 出错了！&#125;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;promise&lt;/code&gt;是一个</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之变量提升</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/18/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/18/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</id>
    <published>2020-09-18T09:00:43.000Z</published>
    <updated>2020-09-27T08:42:44.486Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.im/post/6844903490989342728">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在不同作用域下变量与函数的提升表现也是不一致的。在 <code>JavaScript</code> 中，所有绑定的声明会在控制流到达它们出现的作用域时被初始化；这里的作用域其实就是所谓的<code>执行上下文（Execution Context）</code>，每个执行上下文分为<code>内存分配（Memory Creation Phase）</code>与<code>执行（Execution）</code>这两个阶段。在执行上下文的内存分配阶段会进行变量创建，即开始进入了变量的生命周期；变量的生命周期包含了<code>声明（Declaration phase）</code>、<code>初始化（Initialization phase）</code>与<code>赋值（Assignment phase）</code>过程这三个过程。</p><p>传统的 <code>var</code> 关键字声明的变量允许在声明之前使用，此时该变量被赋值为 <code>undefined</code>；而函数作用域中声明的函数同样可以在声明前使用，其函数体也被<strong>提升到了头部</strong>。这种特性表现也就是所谓的<code>提升（Hoisting）</code>；</p><p>虽然在 <code>ES6</code> 中以 <code>let 与 const</code> 关键字声明的变量同样会在作用域头部被初始化，不过这些变量仅允许在实际声明之后使用。在作用域头部与变量实际声明处之间的区域就称为所谓的<code>暂时死域（Temporal Dead Zone）</code>，，TDZ 能够避免传统的提升引发的潜在问题。</p><p>由于 ES6 <strong>引入了块级作用域，在块级作用域中声明的函数会被提升到该作用域头部，即允许在实际声明前使用</strong>；而在部分实现中该函数同时被提升到了所处函数作用域的头部，不过此时被赋值为 <code>undefined</code>。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><code>作用域（Scope）</code>即代码执行过程中的变量、函数或者对象的可访问区域，<strong>作用域决定了变量或者其他资源的可见性</strong>；计算机安全中一条基本原则即是<strong>用户只应该访问他们需要的资源，而作用域就是在编程中遵循该原则来保证代码的安全性</strong>。除此之外，<strong>作用域还能够帮助我们提升代码性能、追踪错误并且修复它们</strong>。<code>JavaScript</code> 中的作用域主要分为<code>全局作用域（Global Scope）</code>与<code>局部作用域（Local Scope）</code>两大类，在 ES5 中定义在函数内的变量即是属于某个局部作用域，而定义在函数外的变量即是属于<code>全局作用域</code>。</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>当我们在浏览器控制台或者 Node.js 交互终端中开始编写 JavaScript 时，即进入了所谓的全局作用域：</p><pre><code class="js">// the scope is by default globalvar name = &#39;Hammad&#39;;// 定义在全局作用域中的变量能够被任意的其他作用域中访问：var name = &#39;Hammad&#39;;console.log(name); // logs &#39;Hammad&#39;function logName() &#123;    console.log(name); // &#39;name&#39; is accessible here and everywhere else&#125;logName(); // logs &#39;Hammad&#39;</code></pre><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p><strong>定义在某个函数内的变量即从属于当前函数作用域</strong>，在每次函数调用中都会创建出新的上下文；换言之，我们可以在不同的函数中定义同名变量，这些变量会被绑定到各自的函数作用域中：</p><pre><code class="js">// Global Scopefunction someFunction() &#123;    // Local Scope #1    function someOtherFunction() &#123;        // Local Scope #2    &#125;&#125;// Global Scopefunction anotherFunction() &#123;    // Local Scope #3&#125;// Global Scope</code></pre><p><strong>函数作用域的缺陷在于粒度过大，在使用闭包或者其他特性时导致异常的变量传递</strong>：</p><pre><code class="js">var callbacks = [];// 这里的 i 被提升到了当前函数作用域头部for (var i = 0; i &lt;= 2; i++) &#123;    callbacks[i] = function () &#123;            return i * 2;        &#125;;&#125;console.log(callbacks[0]()); //6console.log(callbacks[1]()); //6console.log(callbacks[2]()); //6</code></pre><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>类似于 <code>if、switch</code> 条件选择或者 <code>for、while</code> 这样的循环体即是所谓的块级作用域；在 ES5 中，要实现块级作用域，即需要<strong>在原来的函数作用域上包裹一层</strong>，即<strong>在需要限制变量提升的地方手动设置一个变量来替代原来的全局变量</strong>，譬如：</p><pre><code class="js">var callbacks = [];for (var i = 0; i &lt;= 2; i++) &#123;    (function (i) &#123;        // 这里的 i 仅归属于该函数作用域        callbacks[i] = function () &#123;            return i * 2;        &#125;;    &#125;)(i);&#125;callbacks[0]() === 0;callbacks[1]() === 2;callbacks[2]() === 4;</code></pre><p>而在 ES6 中，可以直接利用 let 关键字达成这一点：</p><pre><code class="js">let callbacks = []for (let i = 0; i &lt;= 2; i++) &#123;    // 这里的 i 属于当前块作用域    callbacks[i] = function () &#123;        return i * 2    &#125;&#125;callbacks[0]() === 0callbacks[1]() === 2callbacks[2]() === 4</code></pre><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>。一般来说，在编程语言里我们常见的变量作用域就是词法作用域与动态作用域（Dynamic Scope），绝大部分的编程语言都是使用的词法作用域。词法作用域注重的是所谓的 Write-Time，即编程时的上下文，而动态作用域以及常见的 this 的用法，都是 Run-Time，即运行时上下文。<strong>词法作用域关注的是函数在何处被定义，而动态作用域关注的是函数在何处被调用</strong>JavaScript 是典型的词法作用域的语言，即一个符号参照到语境中符号名字出现的地方，局部变量缺省有着词法作用域</p><pre><code class="js">function foo() &#123;    console.log( a ); // 2 in Lexical Scope ，But 3 in Dynamic Scope&#125;function bar() &#123;    var a = 3;    foo();&#125;var a = 2;bar();</code></pre><h2 id="执行上下文与提升"><a href="#执行上下文与提升" class="headerlink" title="执行上下文与提升"></a>执行上下文与提升</h2><p><code>作用域（Scope）</code>与<code>上下文（Context）</code>常常被用来描述相同的概念，不过上下文更多的关注于代码中 <code>this</code> 的使用，而作用域则与变量的可见性相关；而 JavaScript 规范中的<code>执行上下文（Execution Context</code>）其实描述的是变量的作用域。众所周知，JavaScript 是单线程语言，同时刻仅有单任务在执行，而其他任务则会被压入执行上下文队列中；<strong>每次函数调用时都会创建出新的上下文，并将其添加到执行上下文队列中</strong>。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>每个执行上下文又会分为<code>内存创建（Creation Phase）</code>与<code>代码执行（Code Execution Phase）</code>两个步骤，在创建步骤中会进行变量对象的创建（<code>Variable Object</code>）、作用域链的创建以及设置当前上下文中的 this 对象。所谓的 <code>Variable Object</code> ，又称为 <code>Activation Object</code>，包含了当前执行上下文中的所有变量、函数以及具体分支中的定义。当某个函数被执行时，解释器会先扫描所有的函数参数、变量以及其他声明：</p><pre><code class="js">&#39;variableObject&#39;: &#123;    // contains function arguments, inner variable and function declarations&#125;</code></pre><p>在 <code>Variable Object</code> 创建之后，解释器会继续创建<code>作用域链（Scope Chain）</code>；作用域链往往指向其副作用域，往往被用于解析变量。当需要解析某个具体的变量时，JavaScript 解释器会在作用域链上递归查找，直到找到合适的变量或者任何其他需要的资源。作用域链可以被认为是包含了其自身 <code>Variable Object</code> 引用以及所有的父 <code>Variable Object</code> 引用的对象：</p><pre><code class="js">&#39;scopeChain&#39;: &#123;    // contains its own variable object and other variable objects of the parent execution contexts&#125;</code></pre><p>而执行上下文则可以表述为如下抽象对象：</p><pre><code class="js">executionContextObject = &#123;    &#39;scopeChain&#39;: &#123;&#125;, // contains its own variableObject and other variableObject of the parent execution contexts    &#39;variableObject&#39;: &#123;&#125;, // contains function arguments, inner variable and function declarations    &#39;this&#39;: valueOfThis&#125;</code></pre><h3 id="变量的生命周期与提升"><a href="#变量的生命周期与提升" class="headerlink" title="变量的生命周期与提升"></a>变量的生命周期与提升</h3><ul><li>变量的生命周期包含着<strong>变量声明（Declaration Phase）、变量初始化（Initialization Phase）以及变量赋值（Assignment Phase）</strong>三个步骤；</li></ul><p>其中声明步骤会在作用域中注册变量，初始化步骤负责为变量分配内存并且创建作用域绑定，此时变量会被初始化为 <code>undefined</code>，最后的分配步骤则会将开发者指定的值分配给该变量。</p><p>传统的使用 var 关键字声明的变量的生命周期如下：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/13/b9b8aa1b2352bd9c153d8dd502c8eae9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="varlife"></p><p>而 let 关键字声明的变量生命周期如下：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/13/b1963cb58e148aad82a6c26215f8754d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="letlife"></p><p>如上文所说，我们可以在某个变量或者函数定义之前访问这些变量，这即是所谓的<code>变量提升（Hoisting）</code>。传统的 var 关键字声明的变量会被提升到作用域头部，并被赋值为 <code>undefined</code>：</p><pre><code class="js">// var hoistingnum;     // =&gt; undefined  var num;  num = 10;  num;     // =&gt; 10  // function hoistinggetPi;   // =&gt; function getPi() &#123;...&#125;  getPi(); // =&gt; 3.14  function getPi() &#123;    return 3.14;&#125;</code></pre><p>变量提升只对 var 命令声明的变量有效，如果一个变量不是用 var 命令声明的，就不会发生变量提升。</p><pre><code class="js">console.log(b);b = 1;</code></pre><p>上面的语句将会报错，提示 <code>ReferenceError: b is not defined</code>，即变量 b 未声明，这是因为 b 不是用 var 命令声明的，JavaScript 引擎不会将其提升，而只是视为对顶层对象的 b 属性的赋值。ES6 引入了块级作用域，<strong>块级作用域中使用 let 声明的变量同样会被提升，只不过不允许在实际声明语句前使用</strong>：</p><pre><code class="js">&gt; let x = x;ReferenceError: x is not defined    at repl:1:9    at ContextifyScript.Script.runInThisContext (vm.js:44:33)    at REPLServer.defaultEval (repl.js:239:29)    at bound (domain.js:301:14)    at REPLServer.runBound [as eval] (domain.js:314:12)    at REPLServer.onLine (repl.js:433:10)    at emitOne (events.js:120:20)    at REPLServer.emit (events.js:210:7)    at REPLServer.Interface._onLine (readline.js:278:10)    at REPLServer.Interface._line (readline.js:625:8)&gt; let x = 1;SyntaxError: Identifier &#39;x&#39; has already been declared</code></pre><h3 id="函数的生命周期与提升"><a href="#函数的生命周期与提升" class="headerlink" title="函数的生命周期与提升"></a>函数的生命周期与提升</h3><p>基础的函数提升同样会将声明提升至作用域头部，不过不同于变量提升，函数同样会将其函数体定义提升至头部；譬如：</p><pre><code class="js">function b() &#123;     a = 10;     return;     function a() &#123;&#125; &#125;</code></pre><p>会被编译器修改为如下模式：</p><pre><code class="js">function b() &#123;  function a() &#123;&#125;  a = 10;  return;&#125;</code></pre><p>在内存创建步骤中，JavaScript 解释器会通过<code> function 关键字</code>识别出函数声明并且将其提升至头部；函数的生命周期则比较简单，声明、初始化与赋值三个步骤都被提升到了作用域头部：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/13/1715ccbd677cc0eccecdffb48764756d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="functionlife"></p><p>如果我们在作用域中<strong>重复地声明同名函数，则会由后者覆盖前者</strong>：</p><pre><code class="js">sayHello();function sayHello () &#123;    function hello () &#123;        console.log(&#39;Hello!&#39;);    &#125;    hello();    function hello () &#123;        console.log(&#39;Hey!&#39;);    &#125;&#125;// Hey!</code></pre><p>而 JavaScript 中提供了两种函数的创建方式，<code>函数声明（Function Declaration）</code>与<code>函数表达式（Function Expression）</code>；函数声明即是以 <strong>function 关键字开始，跟随者函数名与函数体</strong>。而函数表达式则是<strong>先声明函数名，然后赋值匿名函数给它</strong>；典型的函数表达式如下所示：</p><pre><code class="js">var sayHello = function() &#123;  console.log(&#39;Hello!&#39;);&#125;;sayHello();// Hello!</code></pre><p><strong>函数表达式遵循变量提升的规则，函数体并不会被提升至作用域头部</strong>：</p><pre><code class="js">sayHello();function sayHello () &#123;    function hello () &#123;        console.log(&#39;Hello!&#39;);    &#125;    hello();    var hello = function () &#123;        console.log(&#39;Hey!&#39;);    &#125;&#125;// Hello!</code></pre><p><strong>在 ES5 中，是不允许在块级作用域中创建函数的；而 ES6 中允许在块级作用域中创建函数</strong>,块级作用域中创建的函数同样会被提升至当前块级作用域头部与函数作用域头部。不同的是函数体并不会再被提升至函数作用域头部，而仅会被提升到块级作用域头部：</p><pre><code class="js">f; // Uncaught ReferenceError: f is not defined(function () &#123;  f; // undefined  x; // Uncaught ReferenceError: x is not defined  if (true) &#123;    f();    let x;    function f() &#123; console.log(&#39;I am function!&#39;); &#125;  &#125;&#125;());</code></pre><h2 id="避免全局变量"><a href="#避免全局变量" class="headerlink" title="避免全局变量"></a>避免全局变量</h2><p><strong>全局变量的不好</strong>：在计算机编程中，全局变量指的是在所有作用域中都能访问的变量。全局变量是一种不好的实践，因为它会导致一些问题，比如一个已经存在的方法和全局变量的覆盖，当我们不知道变量在哪里被定义的时候，代码就变得很难理解和维护了。</p><p>在 ES6 中可以利用 <code>let</code> 关键字来声明本地变量，好的 JavaScript 代码就是没有定义全局变量的。在 JavaScript 中，我们有时候会无意间创建出全局变量，即如果我们在使用某个变量之前忘了进行声明操作，那么该变量会被自动认为是全局变量，譬如:</p><pre><code class="js">function sayHello()&#123;  hello = &quot;Hello World&quot;;  return hello;&#125;sayHello();console.log(hello);</code></pre><p>在上述代码中因为我们在使用 <code>sayHello</code> 函数的时候并没有声明 <code>hello</code> 变量，因此其会创建作为某个全局变量。如果我们想要避免这种偶然创建全局变量的错误，可以通过强制使用 <code>strict mode</code> 来禁止创建全局变量。</p><h3 id="函数包裹"><a href="#函数包裹" class="headerlink" title="函数包裹"></a>函数包裹</h3><p>为了避免全局变量，第一件事情就是要确保所有的代码都被包在函数中。最简单的办法就是把所有的代码都直接放到一个函数中去:</p><pre><code class="js">(function(win) &#123;    &quot;use strict&quot;; // 进一步避免创建全局变量    var doc = window.document;    // 在这里声明你的变量    // 一些其他的代码&#125;(window));</code></pre><h3 id="声明命名空间"><a href="#声明命名空间" class="headerlink" title="声明命名空间"></a>声明命名空间</h3><pre><code class="js">var MyApp = &#123;    namespace: function(ns) &#123;        var parts = ns.split(&quot;.&quot;),            object = this, i, len;        for(i = 0, len = parts.lenght; i &lt; len; i ++) &#123;            if(!object[parts[i]]) &#123;                object[parts[i]] = &#123;&#125;;            &#125;            object = object[parts[i]];        &#125;    return object;    &#125;&#125;;// 定义命名空间MyApp.namespace(&quot;Helpers.Parsing&quot;);// 你现在可以使用该命名空间了MyApp.Helpers.Parsing.DateParser = function() &#123;    //做一些事情&#125;;</code></pre><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>另一项开发者用来避<strong>免全局变量的技术就是封装到模块 Module 中</strong>。一个模块就是不需要创建新的全局变量或者命名空间的通用的功能。不要将所有的代码都放一个负责执行任务或者发布接口的函数中。这里以异步模块定义 <code>Asynchronous Module Definition (AMD)</code> 为例</p><pre><code class="js">//定义define( &quot;parsing&quot;, //模块名字        [ &quot;dependency1&quot;, &quot;dependency2&quot; ], // 模块依赖        function( dependency1, dependency2) &#123; //工厂方法            // Instead of creating a namespace AMD modules            // are expected to return their public interface            var Parsing = &#123;&#125;;            Parsing.DateParser = function() &#123;              //do something            &#125;;            return Parsing;        &#125;);// 通过 Require.js 加载模块require([&quot;parsing&quot;], function(Parsing) &#123;    Parsing.DateParser(); // 使用模块&#125;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903490989342728&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之表达式和语句</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/17/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/17/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/</id>
    <published>2020-09-17T09:39:52.000Z</published>
    <updated>2020-09-17T10:19:18.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表达式与语句的区分"><a href="#表达式与语句的区分" class="headerlink" title="表达式与语句的区分"></a>表达式与语句的区分</h1><p>引子：表达式和语句很基础，但是有时会犯错，比如：</p><pre><code class="js">function()&#123;&#125;//报错(function()&#123;&#125;)//不报错function f(x)&#123; return x + 1 &#125;()//报错function f(x)&#123; return x + 1 &#125;(1)//不报错，为什么返回 1</code></pre><p>能明白为什么？</p><ul><li><p>第一行代码：因为<code>JavaScript</code> 将 <code>function</code> 关键字当作一个 <strong>函数声明语句</strong> 的开始，而函数声明语句 <code>function</code> 关键字后面应该是 函数名，这里后面跟圆括号，当然会报错。</p></li><li><p>第二行代码：给它加上一对圆括号，解析器会把()里的当做表达式去解析，在这里就会当做匿名函数表达式解析，所以不会报错。</p></li><li><p>第三行代码：在一条语句后面加上()会被当做分组操作符，分组操作符里必须要有表达式，所以这里报错；</p></li><li><p>第四行代码：在一条函数声明语句后面加上(1)，仅仅是相当于在声明语句之后又跟了一条毫无关系的表达式，等价于下面代码：</p></li></ul><pre><code class="js">function f(x)&#123; return x + 1 &#125;(1)//1</code></pre><p>所以返回了无关紧要的答案；</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="表达式（expression）"><a href="#表达式（expression）" class="headerlink" title="表达式（expression）"></a>表达式（expression）</h3><p>js 中的一个短语，js 解释器会将其计算出一个结果。程序中的常量是最简单的一类表达式。</p><p><strong>变量名也是一种简单的表达式</strong>，它的值就是赋值给变量的值。<br>复杂表达式是由简单表达式组成的。</p><p>比如，数据访问表达式是由一个表示数组的表达式、左方括号、一个整数表达式和右方括号构成。它们所组成的新的表达式的运算结果是该数组的特定位置的元素值。</p><p>同样的，函数调用表达式由一个表示函数对象的表达式和0个或多个参数表达式构成。</p><p>将简单表达式组合成复杂表达式最常用的方法就是使用运算符（opetator）。</p><p>运算符按照特定的运算规则对操作数（通常是两个）进行运算，并计算出新值。</p><p>乘法运算符<code>*</code>是比较简单的例子。表达式<code>x*y</code>是对两个变量表达式x和y进行运算并得出结果。有时我们更愿意说运算符返回了一个值而不是“计算”出了一个值。</p><h3 id="语句（statement）"><a href="#语句（statement）" class="headerlink" title="语句（statement）"></a>语句（statement）</h3><p><strong>js 整句或命令。js 语句是以分号结束；表达式计算出一个值，但语句用来自行以使某件事发生。</strong><br><strong>“使某件事发生”的一个方法是计算带有副作用的表达式。</strong></p><p>诸如赋值和函数调用这些有副作用的表达式，是可以作为单独的语句的，这种把表达式当做语句的用法也称作表达式语句（expression statement）。类似的语句还有声明语句（declaration statement），声明语句用来声明新变量或定义新函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;表达式与语句的区分&quot;&gt;&lt;a href=&quot;#表达式与语句的区分&quot; class=&quot;headerlink&quot; title=&quot;表达式与语句的区分&quot;&gt;&lt;/a&gt;表达式与语句的区分&lt;/h1&gt;&lt;p&gt;引子：表达式和语句很基础，但是有时会犯错，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code cl</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之map,reduce,filter等高阶函数</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/16/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bmap-reduce-filter%E7%AD%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/16/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bmap-reduce-filter%E7%AD%89%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</id>
    <published>2020-09-16T07:27:16.000Z</published>
    <updated>2020-09-16T08:36:28.605Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">原文地址来自MDN</a><br>跟着写一遍，加强下记录</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>map()</code> 方法<strong>创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值</strong>。</p><pre><code class="js">const array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32]</code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><pre><code class="js">var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array &#125;[, thisArg])</code></pre><p><strong>callback</strong><br>生成新数组元素的函数，使用三个参数：<br><strong>currentValue</strong><br>callback 数组中正在处理的当前元素。<br><strong>index可选</strong><br>callback 数组中正在处理的当前元素的索引。</p><p><strong>array可选</strong><br>map 方法调用的数组。<br>thisArg可选<br>执行 callback 函数时值被用作this。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><blockquote><p>一个由原数组每个元素执行回调函数的结果成的新数组</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通常情况下，<code>map</code> 方法中的 <code>callback</code> 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 <code>map</code> 只给 <code>callback</code> 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。</p><pre><code class="js">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt); // [1,NaN,NaN]</code></pre><p>我们期望输出 <code>[1, 2, 3]</code>, 而实际结果是 <code>[1, NaN, NaN]</code>.</p><p><code>parseInt</code> 经常被带着一个参数使用, 但是这里接受两个。第一个参数是一个表达式而第二个是<code>callback function</code>的基, <code>Array.prototype.map</code> 传递3个参数:</p><ul><li>the element</li><li>the index</li><li>the array</li></ul><pre><code class="js">// parseInt(string, radix) -&gt; map(parseInt(value, index))/*  first iteration (index is 0): */ parseInt(&quot;1&quot;, 0); // 1/* second iteration (index is 1): */ parseInt(&quot;2&quot;, 1); // NaN/*  third iteration (index is 2): */ parseInt(&quot;3&quot;, 2); // NaN</code></pre><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><p><code>filter</code> 为数组中的每个元素<strong>调用一次 callback 函数，并利用所有使得 callback 返回 true 或等价于 true 的值</strong>的元素创建一个新数组。</p><p><strong>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</strong></p><pre><code class="js">const words = [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</code></pre><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><pre><code class="js">var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</code></pre><p><strong>callback</strong><br>用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。它接受以下三个参数：<br>element<br>数组中当前正在处理的元素。<br><strong>index可选</strong><br>正在处理的元素在数组中的索引。<br><strong>array可选</strong><br>调用了 filter 的数组本身。<br><strong>thisArg可选</strong><br>执行 callback 时，用于 this 的值。</p><h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p><p>filter 不会改变原数组，它返回过滤后的新数组。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><pre><code class="js">var fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;grapes&#39;, &#39;mango&#39;, &#39;orange&#39;];/** * Array filters items based on search criteria (query) */function filterItems(query) &#123;  return fruits.filter(function(el) &#123;      return el.toLowerCase().indexOf(query.toLowerCase()) &gt; -1;  &#125;)&#125;console.log(filterItems(&#39;ap&#39;)); // [&#39;apple&#39;, &#39;grapes&#39;]console.log(filterItems(&#39;an&#39;)); // [&#39;banana&#39;, &#39;mango&#39;, &#39;orange&#39;]</code></pre><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><p><code>reduce()</code> 方法对**数组中的每个元素执行一个由您提供的reducer函数(升序执行)**，将其结果汇总为单个返回值。</p><pre><code class="js">const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15</code></pre><blockquote><p>reducer 函数接收4个参数:</p></blockquote><ul><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ul><h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>函数累计处理的结果</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>数组里所有值的和</p><pre><code class="js">var sum = [0, 1, 2, 3].reduce(function (accumulator, currentValue) &#123;  return accumulator + currentValue;&#125;, 0);// 和为 6</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce&quot;&gt;原文地址来自MDN&lt;/a&gt;&lt;br&gt;跟着写一遍，加强下记录&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之闭包</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/15/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/15/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%AD%E5%8C%85/</id>
    <published>2020-09-15T05:22:11.000Z</published>
    <updated>2020-09-15T05:52:47.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MDN上对闭包的解释是：函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起构成<strong>闭包（closure）</strong>。也就是说，闭包可以<strong>让你从内部函数访问外部函数作用域</strong>。在 JavaScript 中，每当函数被创建，就会<strong>在函数生成时生成闭包</strong>。</p><p>JavaScript中的函数会形成了闭包。 闭包是由<strong>函数以及声明该函数的词法环境组合而成的</strong>。该环境包含了这个闭包创建时作用域内的任何局部变量</p><h2 id="产生闭包"><a href="#产生闭包" class="headerlink" title="产生闭包"></a>产生闭包</h2><p>创建闭包最常见方式，就是在<strong>一个函数内部创建另一个函数</strong>。下面例子中的 <code>closure</code> 就是一个闭包：</p><pre><code class="js">function func()&#123;  var a = 1,b = 2;  function closure()&#123;    return a+b;  &#125;  return closure;&#125;</code></pre><p><strong>闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域</strong>。</p><h2 id="闭包的注意事项"><a href="#闭包的注意事项" class="headerlink" title="闭包的注意事项"></a>闭包的注意事项</h2><blockquote><p>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会<strong>一直保存到闭包不存在为止</strong>。</p></blockquote><pre><code class="js">function makeAdder(x) &#123;  return function(y) &#123;    return x + y;  &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2));  // 7console.log(add10(2)); // 12// 释放对闭包的引用add5 = null;add10 = null;</code></pre><p><code>add5</code> 和 <code>add10</code> 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 <code>add5</code> 的环境中，x 为 5。而在 <code>add10</code> 中，x 则为 10。最后通过 null 释放了 <code>add5</code> 和 <code>add10</code> 对闭包的引用。</p><blockquote><p>在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；<br>如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。</p></blockquote><ul><li>闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。</li></ul><pre><code class="js">function test()&#123;  var arr = [];  for(var i = 0;i &lt; 10;i++)&#123;    arr[i] = function()&#123;      return i;    &#125;;  &#125;  for(var a = 0;a &lt; 10;a++)&#123;    console.log(arr[a]());  &#125;&#125;test(); // 连续打印 10 个 10</code></pre><p>对于上面的情况，如果我们改变代码如下：</p><pre><code class="js">function test()&#123;  var arr = [];  for(let i = 0;i &lt; 10;i++)&#123;  // 仅在这里作出了改动    arr[i] = function()&#123;      return i;    &#125;;  &#125;  for(var a = 0;a &lt; 10;a++)&#123;    console.log(arr[a]());  &#125;&#125;test(); // 打印 0 到 9</code></pre><ul><li>闭包中的 this 对象</li></ul><pre><code class="js">var name = &quot;The Window&quot;;var obj = &#123;  name: &quot;My Object&quot;,  getName: function()&#123;    return function()&#123;      return this.name;    &#125;;  &#125;&#125;;console.log(obj.getName()());  // The Window</code></pre><p><code>obj.getName()()</code>实际上是<strong>在全局作用域中调用了匿名函数，this指向了window</strong>。这里要理解函数名与函数功能（或者称函数值）是分割开的，不要认为函数在哪里，其内部的this就指向哪里。<strong>匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window</strong>。</p><pre><code class="js">var name = &quot;The Window&quot;;var obj = &#123;  name: &quot;My Object&quot;,  getName: function()&#123;    var that = this;    return function()&#123;      return that.name;    &#125;;  &#125;&#125;;console.log(obj.getName()());  // My Object</code></pre><h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="应用闭包的主要场合是：设计私有的方法和变量。"><a href="#应用闭包的主要场合是：设计私有的方法和变量。" class="headerlink" title="应用闭包的主要场合是：设计私有的方法和变量。"></a>应用闭包的主要场合是：设计私有的方法和变量。</h3><p>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。私有变量包括函数的参数、局部变量和函数内定义的其他函数。</p><p>把有权访问私有变量的公有方法称为<code>特权方法（privileged method）</code>。</p><pre><code class="js">function Animal()&#123;  // 私有变量  var series = &quot;哺乳动物&quot;;  function run()&#123;    console.log(&quot;Run!!!&quot;);  &#125;  // 特权方法  this.getSeries = function()&#123;    return series;  &#125;;&#125;</code></pre><blockquote><p><code>模块模式（The Module Pattern）</code>：为单例创建私有变量和方法。</p></blockquote><blockquote><p><code>单例（singleton）</code>：指的是只有一个实例的对象。JavaScript 一般以对象字面量的方式来创建一个单例对象。</p></blockquote><pre><code class="js">var singleton = &#123;  name: &quot;percy&quot;,  speak:function()&#123;    console.log(&quot;speaking!!!&quot;);  &#125;,  getName: function()&#123;    return this.name;  &#125;&#125;;</code></pre><p>上面是普通模式创建的单例，下面使用模块模式创建单例：</p><pre><code class="js">var singleton = (function()&#123;  // 私有变量  var age = 22;  var speak = function()&#123;    console.log(&quot;speaking!!!&quot;);  &#125;;  // 特权（或公有）属性和方法  return &#123;    name: &quot;percy&quot;,    getAge: function()&#123;      return age;    &#125;  &#125;;&#125;)();</code></pre><h2 id="匿名函数最大的用途是创建闭包"><a href="#匿名函数最大的用途是创建闭包" class="headerlink" title="匿名函数最大的用途是创建闭包"></a>匿名函数最大的用途是创建闭包</h2><p>并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。</p><pre><code class="js">var objEvent = objEvent || &#123;&#125;;(function()&#123;     var addEvent = function()&#123;       // some code    &#125;;    function removeEvent()&#123;      // some code    &#125;    objEvent.addEvent = addEvent;    objEvent.removeEvent = removeEvent;&#125;)();</code></pre><p>在这段代码中函数 <code>addEvent</code> 和 <code>removeEvent</code> 都是局部变量，但我们可以通过全局变量 <code>objEvent</code> 使用它，这就大大减少了全局变量的使用，增强了网页的安全性</p><h3 id="一个闭包计数器"><a href="#一个闭包计数器" class="headerlink" title="一个闭包计数器"></a>一个闭包计数器</h3><pre><code class="js">var countNumber = (function()&#123;  var num = 0;  return function()&#123;    return ++num;  &#125;;&#125;)();</code></pre><h2 id="闭包的缺陷"><a href="#闭包的缺陷" class="headerlink" title="闭包的缺陷"></a>闭包的缺陷</h2><ul><li>闭包的缺点就是<strong>常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露</strong>。</li><li>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MDN上对闭包的解释是：函数和对其周围状态（&lt;strong&gt;lexical environment，词法环境&lt;/strong&gt;）的引用捆绑在</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习JavaScript应懂得33个概念之函数作用域,块级作用域和词法作用域</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-09-14T07:25:47.000Z</published>
    <updated>2020-09-25T08:11:58.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><blockquote><p>作用域：作用域是程序源代码中定义变量的区域。</p></blockquote><blockquote><p>作用域目的：作用域规定了如何查找、在哪查找变量的规则，也就是确定了当前执行代码对变量的访问权限。</p></blockquote><blockquote><p>作用域（Scope）即代码执行过程中的变量、函数或者对象的可访问区域，作用域决定了变量或者其他资源的可见性</p></blockquote><p><code>ECMAScript6 之前只有全局作用域和函数作用域，let const 之后才有块级作用域</code></p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><blockquote><p>一个变量的作用域 (scope) 是程序源代码中定义这个变量的区域。</p></blockquote><p><strong>注意点</strong> : <strong>在函数体内，局部变量相对于同名全局变量拥有高优先级。</strong></p><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>函数声明和变量声明总是被 <code>JavaScript</code> 解释器<strong>隐式地提升 (hoist) 到包含他们的作用域的最顶端</strong>。很明显的，语言自身定义和函数形参已经处于作用域顶端, 并被赋值为 <code>undefined</code></p><p>变量赋值不会被提升。</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><blockquote><p>函数作用域：变量在声明他们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p></blockquote><p>我的理解就是<strong>函数体的子嵌套函数可以访问父函数体的变量</strong>。这种关系是可以继承的，子嵌套函数可以访问父、爷函数体的变量。</p><pre><code class="js">function ()&#123;  function foo()&#123;    var tom = &#39;Tom&#39;    console.log(tom) // Tom  &#125;  foo()  console.log(tom) // ReferenceError Tom is not defined&#125;test()// 全局var name = &#39;zyc&#39;; // 全局变量function foo() &#123; // 全局变量    console.log(name);&#125;foo(); // zycfunction bar() &#123;    var name = 2;    foo(); // zyc 这里调用全局变量&#125;bar()</code></pre><blockquote><p>JavaScript 函数的执行用到了作用域链，这个作用域链是<strong>在函数定义的时候创建的</strong>。嵌套的函数 <code>f()</code> 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 <code>f()</code> ，这种绑定在执行 <code>f()</code> 时依然有效。</p></blockquote><h2 id="词法作用域-静态作用域"><a href="#词法作用域-静态作用域" class="headerlink" title="词法作用域(静态作用域)"></a>词法作用域(静态作用域)</h2><p>全局变量在程序中始终都是有定义的。局部变量在声明它的函数体内以及所嵌套的函数内始终是有定义的。</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当 <code>JavaScript</code> 需要查找变量的值的时候，会从链中的第一个对象开始查找，如果有就会直接使用这个值，如果没有就会继续查找下一个对象，如果链上不存在就会抛出一个引用错误 (ReferenceError)。</p><p>在 <code>JavaScript</code> 的最顶层代码中 (不包含在任何函数定义内的代码)，作用域链是由一个全局对象组成。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>块级作用域：在一些类似 c 语言的编程语言中，{ 内的每一段代码都具有各自的作用域，而且变量在声明他们的代码段之外是不可见的。</p><p>块级作用非常严格，就是作用域之外无法访问作用域内的变量。</p><p>ECMAScript5 中规定了 let 和 const 来支持块级作用域(只是效果一样)。</p><p>同时 ECMAScript5 之前 for if switch 是不会产生作用域的</p><p>下面题目的答案是 <code>5</code> </p><pre><code class="js">var a = 5; // 全局变量function todo()&#123;  var a = 9  return function()&#123;      a = 7  &#125;&#125;todo()()console.log(a) // 指向的是window</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作用域：作用域是程序源代码中定义变量的区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之this,call,apply和bind</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bthis-call-apply%E5%92%8Cbind/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bthis-call-apply%E5%92%8Cbind/</id>
    <published>2020-09-14T07:24:55.000Z</published>
    <updated>2020-09-14T09:11:51.320Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/6844903496253177863">原文地址</a></p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p>在 ES5 中，其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象</strong></p><blockquote><p>改变 this 的指向我总结有以下几种方法：</p></blockquote><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply、call、bind</code></li><li><code>new关键字</code> 实例化一个对象</li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>箭头函数的 this 始终指向函数定义时的 this</strong>，而非执行时。，箭头函数需要记着这句话：“<strong>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值</strong>，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。</p><pre><code class="js">var name = &quot;windowsName&quot;;var a = &#123;  name : &quot;Cherry&quot;,  func1: function () &#123;    console.log(this.name)       &#125;,  func2: function () &#123;    setTimeout( () =&gt; &#123;        this.func1()    &#125;,100);  &#125;&#125;;a.func2()     // Cherry</code></pre><h3 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 _this = this</h3><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。</p><h3 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h3><p><code>apply、call、bind</code> 都是可以改变 this 的指向的，但是这三个函数稍有不同。</p><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p></blockquote><blockquote><p> apply 和 call 基本类似，区别是 call 方法接受的是<strong>若干个参数列表</strong>，而 apply 接收的是一个包含<strong>多个参数的数组</strong>。</p></blockquote><blockquote><p>bind()方法<strong>创建一个新的函数</strong>, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><p>bind 是创建一个新的函数，我们必须<strong>要手动去调用</strong>：</p><pre><code class="js">var a =&#123;    name : &quot;Cherry&quot;,    fn : function (a,b) &#123;        console.log( a + b)    &#125;&#125;var b = a.fn;b.bind(a,1,2)()           // 3</code></pre><h2 id="JS-中的函数调用"><a href="#JS-中的函数调用" class="headerlink" title="JS 中的函数调用"></a>JS 中的函数调用</h2><blockquote><p>函数调用的方法一共有 4 种</p></blockquote><ul><li>作为一个函数调用</li><li>函数作为方法调用</li><li>使用构造函数调用函数</li><li>作为函数方法调用函数（call、apply）</li></ul><h3 id="作为一个函数调用"><a href="#作为一个函数调用" class="headerlink" title="作为一个函数调用"></a>作为一个函数调用</h3><pre><code class="js">var name = &quot;windowsName&quot;;function a() &#123;  var name = &quot;Cherry&quot;;  console.log(this.name);          // windowsName  console.log(&quot;inner:&quot; + this);    // inner: Window&#125;a();console.log(&quot;outer:&quot; + this)         // outer: Window</code></pre><h3 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h3><pre><code class="js">var name = &quot;windowsName&quot;;var a = &#123;    name: &quot;Cherry&quot;,    fn : function () &#123;        console.log(this.name);      // Cherry    &#125;&#125;a.fn();</code></pre><h3 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h3><blockquote><p>如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p></blockquote><pre><code class="js">// 构造函数:function myFunction(arg1, arg2) &#123;    this.firstName = arg1;    this.lastName  = arg2;&#125;// This    creates a new objectvar a = new myFunction(&quot;Li&quot;,&quot;Cherry&quot;);a.lastName;                             // 返回 &quot;Cherry&quot;</code></pre><h3 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h3><blockquote><p>在 JavaScript 中, 函数是对象。<br>JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身<br>在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。</p></blockquote><pre><code class="js">var name = &quot;windowsName&quot;;function fn() &#123;    var name = &#39;Cherry&#39;;    innerFunction();    function innerFunction() &#123;        console.log(this.name);      // windowsName    &#125;&#125;fn()</code></pre><p>这里的 <code>innerFunction()</code> 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的）</p><p><strong>匿名函数的 this 永远指向 window</strong> 匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903496253177863&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;this的指向&quot;&gt;&lt;a href=&quot;#this的指向&quot; class=&quot;headerlink&quot; title=&quot;this的指向&quot;&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
</feed>
