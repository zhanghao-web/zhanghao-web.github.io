<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>默默默默燃</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="https://shinichikudo-fe.github.io/atom.xml" rel="self"/>
  
  <link href="https://shinichikudo-fe.github.io/"/>
  <updated>2021-01-19T10:08:39.929Z</updated>
  <id>https://shinichikudo-fe.github.io/</id>
  
  <author>
    <name>张白告丶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>偏函数, 柯里化, Compose 和 Pipe</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/19/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%81%8F%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-Compose-%E5%92%8C-Pipe/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/19/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%81%8F%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-Compose-%E5%92%8C-Pipe/</id>
    <published>2021-01-19T08:13:58.000Z</published>
    <updated>2021-01-19T10:08:39.929Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>原文地址<br><img src="https://blog.csdn.net/qq_42129063/article/details/81874314" alt="https://blog.csdn.net/qq_42129063/article/details/81874314"><br><img src="https://blog.csdn.net/neweastsun/article/details/75947785" alt="https://blog.csdn.net/neweastsun/article/details/75947785"><br><img src="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html" alt="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch5.html"></p><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>所谓偏函数，就是<strong>固定一个函数的一个或者多个参数，返回一个新的函数，这个函数用于接受剩余的参数</strong></p><p>为什么我们通常使用偏函数？</p><p>这里我们偏函数的好处是：<strong>通过创建一个名称易懂的独立函数<code>（double，triple）</code>，调用是无需每次传入第一个参数，因为第一个参数通过<code>bind</code>提供了固定值</strong>。</p><p>另一种使用偏函数情况是，<strong>当我们有一个很通用的函数，为了方便提供一个较常用的变体</strong>。</p><p>首先，我们来看一个简单的例子，下面只是一个普普通通的函数，</p><pre><code class="js">function add(a,b)&#123;    return a + b;&#125;console.log(add(1,2));//结果3console.log(add(1,3));//结果4console.log(add(1,4));//结果5console.log(add(1,5));//结果6console.log(add(1,6));//结果7console.log(add(1,7));//结果8</code></pre><p>不知道大家有没有发现，往<code>add()</code>传入的第一个参数全都是相同的，也就是1，对于这样相同的参数，我们已经重复输入了6次。参数少的情况还好办，那参数多的时候就非常不方便了，请往下看：</p><pre><code class="js">function add(a,b,c,d,e)&#123;    return a + b + c + d + e;&#125;console.log(add(1,2,3,4,5));console.log(add(1,2,3,1,2));console.log(add(1,2,3,3,5));console.log(add(1,2,3,2,11));console.log(add(1,2,3,3,8));console.log(add(1,2,3,7,5));</code></pre><p>我们可以定义一个函数,把它命名为<code>partial</code>，这个函数就相当于一个工厂，需要接受一个入参函数，这个工厂用来生产偏函数，按照这个思路，可以写出大概的构架如下：</p><pre><code class="js">//入参函数function add(a,b)&#123;    return a + b;&#125;//生产偏函数的工厂，接受一个入参函数，返回一个新的函数，用于接受剩余的参数function partial(fn,a)&#123;    return function(b)&#123;        return fn(a,b);    &#125;&#125;var parAdd = partial(add,1);//变量parAdd接受返回的新函数console.log(parAdd(2));//在调用的时候传入剩余的参数console.log(parAdd(3));//在调用的时候传入剩余的参数console.log(parAdd(4));//在调用的时候传入剩余的参数console.log(parAdd(5));//在调用的时候传入剩余的参数</code></pre><h3 id="偏函数的简单应用"><a href="#偏函数的简单应用" class="headerlink" title="偏函数的简单应用"></a>偏函数的简单应用</h3><ul><li><code>Function.prototype.bind()</code></li></ul><p>这是MDN对于<code>bind()</code>的描述：<code>bind()</code> 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当新函数被调用时 this 值绑定到 <code>bind()</code> 的第一个参数，该参数不能被重写。绑定函数被调用时，<code>bind()</code> 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。<br>不知道大家有木有发现在上面的描述中，出现了几个很重要的表述，创建一个新函数，具有相同的函数体，调用时的参数被提供给模拟函数，哈哈，这不正和我刚刚说的生产偏函数工厂相似吗。所以对于上面的应用，我们还可以这样改写：</p><pre><code class="js">function add(a,b)&#123;    return a + b;&#125;var obj = &#123;&#125;;obj.parAdd = add.bind(obj,1);console.log(obj.parAdd(2));//结果3</code></pre><h3 id="使用没有上下文的偏函数"><a href="#使用没有上下文的偏函数" class="headerlink" title="使用没有上下文的偏函数"></a>使用没有上下文的偏函数</h3><p>如果想固定一些参数，但不绑定<code>this</code>呢？</p><p>内置的<code>bind</code>不允许这样，我们不能忽略上下文并跳转到参数。幸运的是，可以仅绑定参数<code>partial</code>函数容易实现。</p><pre><code class="js">function partial(func, ...argsBound) &#123;  return function(...args) &#123; // (*)    return func.call(this, ...argsBound, ...args);  &#125;&#125;// Usage:let user = &#123;  firstName: &quot;John&quot;,  say(time, phrase) &#123;    alert(`[$&#123;time&#125;] $&#123;this.firstName&#125;: $&#123;phrase&#125;!`);  &#125;&#125;;// add a partial method that says something now by fixing the first argumentuser.sayNow = partial(user.say, new Date().getHours() + &#39;:&#39; + new Date().getMinutes());user.sayNow(&quot;Hello&quot;);// Something like:// [10:00] Hello, John!</code></pre><p>调用<code>partial(func[, arg1, arg2...])</code>函数的结果为调用func的包装器（*号行）：</p><p>this一致（因为<code>user.sayNow</code>是通过<code>user</code>调用的）<br>然后给其<code>...garsBound—— partial</code>使用该参数(“10:00”)进行调用。<br>然后提供参数<code>...gars</code>——提供给包装器的参数(“Hello“)<br>所以使用<code>spread</code>运算符很容易实现，是吗？<br>loadash库也提供了<code>—.partial</code>实现。</p><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>有时人们混淆上面提及的偏函数和另一个名称为<code>“柯里化”</code>函数功能，柯里化是另一个有趣的处理函数技术，这里我们必须要涉及。</p><p><strong>与柯里化的区别</strong>：</p><ul><li><p>柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数。</p></li><li><p>局部应用则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数。</p></li></ul><p><strong>柯里化（Currying）</strong>：转换一个调用函数<code>f(a,b,c)</code>为<code>f(a)(b)(c)</code>方式调用。</p><p>让我们实现柯里化函数，执行一个两元参数函数，即转换<code>f(a,b)</code>至<code>f(a)(b)</code>:</p><pre><code class="js">function curry(func) &#123;  return function(a) &#123;    return function(b) &#123;      return func(a, b);    &#125;;  &#125;;&#125;// usagefunction sum(a, b) &#123;  return a + b;&#125;let carriedSum = curry(sum);alert( carriedSum(1)(2) ); // 3</code></pre><p>上面是通过一系列包装器实现的。</p><p><code>curry(func)</code>的结果是<code>function(a)</code>的一个包装器。<br>当调用<code>sum(1)</code>是，参数被保存在词法环境中，然后返回新的包装器<code>function(b)</code><br>然后<code>sum(1)(2)</code>提供2并最终调用<code>function(b)</code>，然后传递调用给原始多参数函数<code>sum</code>。</p><p>有一些柯里化的高级实现，如lodash库中<code>_.curry</code>可以实现更复杂功能。其返回一个包装器,它允许函数提供全部参数被正常调用或返回偏函数。</p><pre><code class="js">function curry(func) &#123;  return function curried(...args) &#123;    if (args.length &gt;= func.length) &#123;      return func.apply(this, args);    &#125; else &#123;      return function(...args2) &#123;        return curried.apply(this, args.concat(args2));      &#125;    &#125;  &#125;;&#125;function sum(a, b, c) &#123;  return a + b + c;&#125;let curriedSum = curry(sum);// still callable normallyalert( curriedSum(1, 2, 3) ); // 6// get the partial with curried(1) and call it with 2 other argumentsalert( curriedSum(1)(2,3) ); // 6</code></pre><h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p>compose就是执行一系列的任务（函数），比如有以下任务队列，</p><pre><code class="js">let tasks = [step1, step2, step3, step4]</code></pre><p>每一个step都是一个步骤，按照步骤一步一步的执行到结尾，这就是一个compose<br>compose在函数式编程中是一个很重要的工具函数，在这里实现的compose有三点说明</p><ul><li>第一个函数是多元的（接受多个参数），后面的函数都是单元的（接受一个参数）</li><li>执行顺序的自右向左的</li><li>所有函数的执行都是同步的（异步的后面文章会讲到）</li></ul><p>还是用一个例子来说，比如有以下几个函数</p><pre><code class="js">let init = (...args) =&gt; args.reduce((ele1, ele2) =&gt; ele1 + ele2, 0)let step2 = (val) =&gt; val + 2let step3 = (val) =&gt; val + 3let step4 = (val) =&gt; val + 4</code></pre><p>这几个函数组成一个任务队列</p><pre><code class="js">steps = [step4, step3, step2, init]</code></pre><p>使用compose组合这个队列并执行</p><pre><code class="js">let composeFunc = compose(...steps)console.log(composeFunc(1, 2, 3)) //执行过程//6 -&gt; 6 + 2 = 8 -&gt; 8 + 3 = 11 -&gt; 11 + 4 = 15</code></pre><p>所以流程就是从init自右到左依次执行，下一个任务的参数是上一个任务的返回结果，并且任务都是同步的，这样就能保证任务可以按照有序的方向和有序的时间执行。</p><h3 id="实现compose的五种思路"><a href="#实现compose的五种思路" class="headerlink" title="实现compose的五种思路"></a>实现compose的五种思路</h3><p>所有思路的执行过程都是上面的例子，以下只讲compose实现</p><h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><p>这个思路就是使用递归的过程思想，不断的检测队列中是否还有任务，如果有任务就执行，并把执行结果往后传递，这里是一个局部的思维，无法预知任务何时结束。直观上最容易结束和理解。</p><pre><code class="js">const compose = function(...args) &#123;  let length = args.length  let count = length - 1  let result  return function f1 (...arg1) &#123;    result = args[count].apply(this, arg1)    if (count &lt;= 0) &#123;      count = length - 1      return result    &#125;    count--    return f1.call(null, result)  &#125;&#125;</code></pre><h4 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h4><p>这个思路是一种函数组合的思想，将函数两两组合，不断的生成新的函数，生成的新函数挟裹了函数执行的逻辑信息，然后再两两组合，不断的传递下去，这种思路可以提前遍历所有任务，将任务组合成一个可以展开的组合结构，最后执行的时候就像推导多米诺骨牌一样。</p><p>函数的组合过程</p><pre><code class="js">f1 = (...arg) =&gt; step2.call(null, init.apply(null, arg))f2 = (...arg) =&gt; step3.call(null, f1.apply(null, arg))f3 = (...arg) =&gt; step4.call(null, f2.apply(null, arg))</code></pre><p><code>compose实现</code></p><pre><code class="js">const _pipe = (f, g) =&gt; (...arg) =&gt; g.call(null, f.apply(null, arg))const compose = (...args) =&gt; args.reverse().reduce(_pipe, args.shift())</code></pre><h4 id="函数交织（AOP）"><a href="#函数交织（AOP）" class="headerlink" title="函数交织（AOP）"></a>函数交织（AOP）</h4><p>这个实现的灵感来自javascript设计模式中的高阶函数，因为<code>compose</code>的任务在本质上就是<strong>函数执行，再加上顺序</strong>，所以可以把实现顺序执行放到函数本身，对函数的原型进行方法的绑定。方法的作用对象是函数，面向对象封装的数据，面向函数封装的是函数的行为。</p><p>需要对函数绑定两个行为 <code>before</code> 和 <code>after</code>，<code>before</code>执行函数多元部分（启动），after执行函数单元部分</p><pre><code class="js">Function.prototype.before = function(fn) &#123;  const self = this  return function(...args) &#123;    let result = fn.apply(null, args)    return self.call(null, result)  &#125;&#125;Function.prototype.after = function(fn) &#123;  const self = this  return function(...args) &#123;    let result = self.apply(null, args)    return fn.call(null, result)  &#125;&#125;</code></pre><p>这里对函数进行方法的绑定，返回的是带着函数执行的规则的另外一个函数，在这里是次序的排列规则，对返回的函数依然可以进行链式调用。</p><p><code>compose 实现</code></p><pre><code class="js">const compose = function(...args) &#123;  let before = args.pop()  let start = args.pop()  if (args.length) &#123;    return args.reduce(function(f1, f2) &#123;      return f1.after(f2)    &#125;, start.before(before))  &#125;  return start.before(before)&#125;</code></pre><p>函数执行过程</p><pre><code class="js">step2.before(init).after(step3).after(step4)fn3.after(step4)fn3 = fn2.after(step3)fn2 = fn1.before(step1)fn1 = init -&gt; step2 -&gt; step3 -&gt; step4</code></pre><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>ES6引入了<code>Promise</code>，<code>Promise</code>可以指定一个<code>sequence</code>，来规定一个执行<code>then</code>的过程，<code>then</code>函数会等到执行完成后，再执行下一个<code>then</code>的处理。启动<code>sequence</code>可以使用<br><code>Promise.resolve()</code>这个函数。构建<code>sequence</code>可以使用reduce</p><p>compose实现</p><pre><code class="js">const compose = function(...args) &#123;  let init = args.pop()  return function(...arg) &#123;    return args.reverse().reduce(function(sequence, func) &#123;      return sequence.then(function(result) &#123;        return func.call(null, result)      &#125;)    &#125;, Promise.resolve(init.apply(null, arg)))  &#125;&#125;</code></pre><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p><code>Generator</code>主要使用<code>yield</code>来构建协程，采用中断，处理，再中断的流程。可以事先规定好协程的执行顺序，然后再下次处理的时候进行参数（结果）交接，有一点要注意的是，由于执行的第一个next是不能传递参数的，所以第一个函数的执行需要手动调用，再空耗一个<code>next</code>，后面的就可以同步执行了。<br><code>generator</code>构建</p><pre><code class="js">function* iterateSteps(steps) &#123;  let n  for (let i = 0; i &lt; steps.length; i++) &#123;    if (n) &#123;      n = yield steps[i].call(null, n)    &#125; else &#123;      n = yield    &#125;  &#125;&#125;</code></pre><p><code>compose实现</code></p><pre><code class="js">const compose = function(...steps) &#123;  let g = iterateSteps(steps)  return function(...args) &#123;    let val = steps.pop().apply(null, args)    // 这里是第一个值    console.log(val)    // 因为无法传参数 所以无所谓执行 就是空耗一个yield    g.next()    return steps.reverse.reduce((val, val1) =&gt; g.next(val).value, val)  &#125;&#125;</code></pre><h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><p><code>pipe</code>函数跟<code>compose</code>函数的左右是一样的，也是将参数平铺，只不过他的顺序是<strong>从左往右</strong>。我们来实现下，只需要将reduceRight改成reduce就行了：</p><pre><code class="js">const pipe = function()&#123;  const args = [].slice.apply(arguments);  return function(x) &#123;    return args.reduce((res, cb) =&gt; cb(res), x);  &#125;&#125;// 参数顺序改为从左往右let calculate = pipe(add, multiply);let res = calculate(10);console.log(res);    // 结果还是200</code></pre><p>ES6写法: </p><pre><code class="js">const pipe = (...args) =&gt; x =&gt; args.reduce((res, cb) =&gt; cb(res), x)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;原文地址&lt;br&gt;&lt;img src=&quot;https://blog.csdn.net/qq_42129063/article/details/81874314&quot; alt=&quot;https:/</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之二进制，十进制，十六进制，科学计数法</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/18/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8D%81%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%EF%BC%8C%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/18/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8D%81%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%EF%BC%8C%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/</id>
    <published>2021-01-18T10:08:11.000Z</published>
    <updated>2021-01-18T10:44:59.188Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://www.cnblogs.com/gaizai/p/4233780.html#_labelConvert11">原文地址</a></p><h1 id="进制转换算法（Convert）"><a href="#进制转换算法（Convert）" class="headerlink" title="进制转换算法（Convert）"></a>进制转换算法（Convert）</h1><h2 id="（二、八、十六进制）-→-（十进制）"><a href="#（二、八、十六进制）-→-（十进制）" class="headerlink" title="（二、八、十六进制） → （十进制）"></a>（二、八、十六进制） → （十进制）</h2><p><img src="https://images0.cnblogs.com/blog/48305/201501/191445576568629.png" alt="（二、八、十六进制） → （十进制）"></p><h3 id="二进制-→-十进制"><a href="#二进制-→-十进制" class="headerlink" title="二进制 → 十进制"></a>二进制 → 十进制</h3><p><strong>方法：二进制数从低位到高位（即从右往左）计算</strong>，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p><p>例：将二进制的(101011)B转换为十进制的步骤如下：</p><ol><li><p>第0位 1 x 2^0 = 1；</p></li><li><p>第1位 1 x 2^1 = 2；</p></li><li><p>第2位 0 x 2^2 = 0；</p></li><li><p>第3位 1 x 2^3 = 8；</p></li><li><p>第4位 0 x 2^4 = 0；</p></li><li><p>第5位 1 x 2^5 = 32；</p></li><li><p>读数，把结果值相加，1+2+0+8+0+32=43，即(101011)B=(43)D。</p></li></ol><h3 id="八进制-→-十进制"><a href="#八进制-→-十进制" class="headerlink" title="八进制 → 十进制"></a>八进制 → 十进制</h3><p><strong>方法：八进制数从低位到高位（即从右往左）计算</strong>，第0位的权值是8的0次方，第1位的权值是8的1次方，第2位的权值是8的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p><blockquote><p>八进制就是逢8进1，八进制数采用 0～7这八数来表达一个数。</p></blockquote><p>例：将八进制的(53)O转换为十进制的步骤如下：</p><ol><li><p>第0位 3 x 8^0 = 3；</p></li><li><p>第1位 5 x 8^1 = 40；</p></li><li><p>读数，把结果值相加，3+40=43，即(53)O=(43)D。</p></li></ol><h3 id="十六进制-→-十进制"><a href="#十六进制-→-十进制" class="headerlink" title="十六进制 → 十进制"></a>十六进制 → 十进制</h3><p><strong>方法：十六进制数从低位到高位（即从右往左）计算</strong>，第0位的权值是16的0次方，第1位的权值是16的1次方，第2位的权值是16的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p><blockquote><p>十六进制就是逢16进1，十六进制的16个数为0123456789ABCDEF。</p></blockquote><p>例：将十六进制的(2B)H转换为十进制的步骤如下：</p><ol><li><p>第0位 B x 16^0 = 11；</p></li><li><p>第1位 2 x 16^1 = 32；</p></li><li><p>读数，把结果值相加，11+32=43，即(2B)H=(43)D。</p></li></ol><h2 id="（十进制）-→-（二、八、十六进制）"><a href="#（十进制）-→-（二、八、十六进制）" class="headerlink" title="（十进制） → （二、八、十六进制）"></a>（十进制） → （二、八、十六进制）</h2><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446004698089.png" alt="（十进制） → （二、八、十六进制）"></p><h3 id="十进制-→-二进制"><a href="#十进制-→-二进制" class="headerlink" title="十进制 → 二进制"></a>十进制 → 二进制</h3><p><strong>方法：除2取余法</strong>，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。 </p><p>例：将十进制的(43)D转换为二进制的步骤如下：</p><ol><li><p>将商43除以2，商21余数为1；</p></li><li><p>将商21除以2，商10余数为1；</p></li><li><p>将商10除以2，商5余数为0；</p></li><li><p>将商5除以2，商2余数为1；</p></li><li><p>将商2除以2，商1余数为0； </p></li><li><p>将商1除以2，商0余数为1； </p></li><li><p>读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，101011，即(43)D=(101011)B。</p></li></ol><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446019539875.png" alt="十进制 → 二进制"></p><h3 id="十进制-→-八进制"><a href="#十进制-→-八进制" class="headerlink" title="十进制 → 八进制"></a>十进制 → 八进制</h3><p><strong>方法1：除8取余法</strong>，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。</p><p>例：将十进制的(796)D转换为八进制的步骤如下：</p><ol><li><p>将商796除以8，商99余数为4；</p></li><li><p>将商99除以8，商12余数为3；</p></li><li><p>将商12除以8，商1余数为4；</p></li><li><p>将商1除以8，商0余数为1；</p></li><li><p>读数，因为最后一位是经过多次除以8才得到的，因此它是最高位，读数字从最后的余数向前读，1434，即(796)D=(1434)O。</p></li></ol><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446033751877.png" alt="十进制 → 八进制"></p><p><strong>方法2：使用间接法，先将十进制转换成二进制，然后将二进制又转换成八进制</strong>；</p><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446059386793.png" alt="十进制 → 二进制 → 八进制"></p><h3 id="十进制-→-十六进制"><a href="#十进制-→-十六进制" class="headerlink" title="十进制 → 十六进制"></a>十进制 → 十六进制</h3><p><strong>方法1：除16取余法</strong>，即每次将整数部分除以16，余数为该位权上的数，而商继续除以16，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。</p><p>例：将十进制的(796)D转换为十六进制的步骤如下：</p><ol><li><p>将商796除以16，商49余数为12，对应十六进制的C；</p></li><li><p>将商49除以16，商3余数为1；</p></li><li><p>将商3除以16，商0余数为3；</p></li><li><p>读数，因为最后一位是经过多次除以16才得到的，因此它是最高位，读数字从最后的余数向前读，31C，即(796)D=(31C)H。</p></li></ol><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446083759737.png" alt="十进制 → 十六进制"></p><p><strong>方法2：使用间接法，先将十进制转换成二进制，然后将二进制又转换成十六进制</strong></p><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446107502896.png" alt="十进制 → 二进制 → 十六进制"></p><h2 id="（二进制）-↔-（八、十六进制）"><a href="#（二进制）-↔-（八、十六进制）" class="headerlink" title="（二进制） ↔ （八、十六进制）"></a>（二进制） ↔ （八、十六进制）</h2><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446126101198.png" alt="（二进制） ↔ （八、十六进制）"></p><h3 id="二进制-→-八进制"><a href="#二进制-→-八进制" class="headerlink" title="二进制 → 八进制"></a>二进制 → 八进制</h3><p><strong>方法：取三合一法</strong>，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。</p><p>例：将二进制的(11010111.0100111)B转换为八进制的步骤如下：</p><ol><li><p>小数点前111 = 7；</p></li><li><p>010 = 2；</p></li><li><p>11补全为011，011 = 3；</p></li><li><p>小数点后010 = 2；</p></li><li><p>011 = 3；</p></li><li><p>1补全为100，100 = 4；</p></li><li><p>读数，读数从高位到低位，即(11010111.0100111)B=(327.234)O。</p></li></ol><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446144855271.png" alt="二进制 → 八进制"></p><p>二进制与八进制编码对应表：</p><p>可以使用冒号来定义表格的对齐方式，如下：</p><table><thead><tr><th align="left">二进制</th><th align="right">八进制</th></tr></thead><tbody><tr><td align="left">000</td><td align="right">0</td></tr><tr><td align="left">001</td><td align="right">1</td></tr><tr><td align="left">010</td><td align="right">2</td></tr><tr><td align="left">011</td><td align="right">3</td></tr><tr><td align="left">100</td><td align="right">4</td></tr><tr><td align="left">101</td><td align="right">5</td></tr><tr><td align="left">110</td><td align="right">6</td></tr><tr><td align="left">111</td><td align="right">7</td></tr></tbody></table><h3 id="八进制-→-二进制"><a href="#八进制-→-二进制" class="headerlink" title="八进制 → 二进制"></a>八进制 → 二进制</h3><p><strong>方法：取一分三法</strong>，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。</p><p>例：将八进制的(327)O转换为二进制的步骤如下：</p><ol><li><p>3 = 011；</p></li><li><p>2 = 010；</p></li><li><p>7 = 111；</p></li><li><p>读数，读数从高位到低位，011010111，即(327)O=(11010111)B。</p></li></ol><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446161888058.png" alt="八进制 → 二进制"></p><h3 id="二进制-→-十六进制"><a href="#二进制-→-十六进制" class="headerlink" title="二进制 → 十六进制"></a>二进制 → 十六进制</h3><p><strong>方法：取四合一法</strong>，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。</p><p>例：将二进制的(11010111)B转换为十六进制的步骤如下：</p><ol><li><p>0111 = 7；</p></li><li><p>1101 = D；</p></li><li><p>读数，读数从高位到低位，即(11010111)B=(D7)H。</p></li></ol><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446167506929.png" alt="二进制 → 十六进制"></p><h3 id="十六进制-→-二进制"><a href="#十六进制-→-二进制" class="headerlink" title="十六进制 → 二进制"></a>十六进制 → 二进制</h3><p><strong>方法：取一分四法</strong>，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。</p><p>例：将十六进制的(D7)H转换为二进制的步骤如下：</p><ol><li><p>D = 1101；</p></li><li><p>7 = 0111；</p></li><li><p>读数，读数从高位到低位，即(D7)H=(11010111)B。</p></li></ol><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446194223347.png" alt="十六进制 → 二进制"></p><h2 id="（八进制）-↔-（十六进制）"><a href="#（八进制）-↔-（十六进制）" class="headerlink" title="（八进制） ↔ （十六进制）"></a>（八进制） ↔ （十六进制）</h2><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446216102748.png" alt="（八进制） ↔ （十六进制）"></p><h3 id="八进制-→-十六进制"><a href="#八进制-→-十六进制" class="headerlink" title="八进制 → 十六进制"></a>八进制 → 十六进制</h3><p>方法：<strong>将八进制转换为二进制，然后再将二进制转换为十六进制，小数点位置不变</strong>。</p><p>例：将八进制的(327)O转换为十六进制的步骤如下：</p><ol><li><p>3 = 011；</p></li><li><p>2 = 010；</p></li><li><p>7 = 111；</p></li><li><p>0111 = 7；</p></li><li><p>1101 = D；</p></li><li><p>读数，读数从高位到低位，D7，即(327)O=(D7)H。</p></li></ol><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446233756320.png" alt="八进制 → 十六进制"></p><h3 id="十六进制-→-八进制"><a href="#十六进制-→-八进制" class="headerlink" title="十六进制 → 八进制"></a>十六进制 → 八进制</h3><p><strong>方法：将十六进制转换为二进制，然后再将二进制转换为八进制，小数点位置不变</strong>。</p><p>例：将十六进制的(D7)H转换为八进制的步骤如下：</p><ol><li><p>7 = 0111；</p></li><li><p>D = 1101；</p></li><li><p>0111 = 7；</p></li><li><p>010 = 2；</p></li><li><p>011 = 3；</p></li><li><p>读数，读数从高位到低位，327，即(D7)H=(327)O。</p></li></ol><p><img src="https://images0.cnblogs.com/blog/48305/201501/191446253919136.png" alt="十六进制 → 八进制"></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol><li>包含小数的进制换算：</li></ol><pre><code class="js">(ABC.8C)H=10x16^2+11x16^1+12x16^0+8x16^-1+12x16^-2=2560+176+12+0.5+0.046875=(2748.546875)D</code></pre><ol start="2"><li>负次幂的计算：</li></ol><pre><code class="js">2^-5=2^(0-5)=2^0/2^5=1/2^5</code></pre><p>同底数幂相除，底数不变，指数相减，反过来</p><ol start="3"><li>我们需要了解一个数学关系，即23=8，24=16，而八进制和十六进制是用这关系衍生而来的，即用三位二进制表示一位八进制，用四位二进制表示一位十六进制数。接着，记住4个数字8、4、2、1（23=8、22=4、21=2、20=1）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/gaizai/p/4233780.html#_labelConvert11&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之Javascript引擎</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/15/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BJavascript%E5%BC%95%E6%93%8E/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/15/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BJavascript%E5%BC%95%E6%93%8E/</id>
    <published>2021-01-15T01:33:38.000Z</published>
    <updated>2021-01-15T02:45:19.865Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="各个浏览器引擎"><a href="#各个浏览器引擎" class="headerlink" title="各个浏览器引擎"></a>各个浏览器引擎</h2><table><thead><tr><th align="left">应用程序（实现）</th><th align="center">方言和最后版本</th><th align="right">ECMAScript版本</th></tr></thead><tbody><tr><td align="left">Chrome浏览器，V8引擎</td><td align="center">JavaScript</td><td align="right">ECMA-262，版本3</td></tr><tr><td align="left">Mozilla Firefox，Gecko排版引擎，SpiderMonkey和Rhino</td><td align="center">JavaScript 1.8.1</td><td align="right">ECMA-262，版本3</td></tr><tr><td align="left">Opera</td><td align="center">一些JavaScript 1.5特性及一些JScript扩展</td><td align="right">ECMA-262，版本3</td></tr><tr><td align="left">KHTML排版引擎，KDE项目的Konqueror与苹果的Safari</td><td align="center">JavaScript 1.5</td><td align="right">ECMA-262，版本3</td></tr><tr><td align="left">Adobe Acrobat</td><td align="center">JavaScript 1.5</td><td align="right">ECMA-262，版本3</td></tr><tr><td align="left">OpenLaszlo Platform</td><td align="center">JavaScript 1.4</td><td align="right">ECMA-262，版本3</td></tr><tr><td align="left">Max/MSP</td><td align="center">JavaScript 1.5</td><td align="right">ECMA-262，版本3</td></tr><tr><td align="left">ANT Galio 3</td><td align="center">JavaScript 1.5附带RMAI扩展</td><td align="right">ECMA-262，版本3</td></tr></tbody></table><p>我们一般说的javascript引擎指的就是就是Chrome的V8 引擎</p><h2 id="V8-引擎"><a href="#V8-引擎" class="headerlink" title="V8 引擎"></a>V8 引擎</h2><p>V8是Google Chrome浏览器内置的<code>JavaScript</code>脚本引擎。<br>Google Chrome使用V8的API，但引擎的内核部分是独立于浏览器之外的。<br>V8引擎编译和执行<code>JavaScript</code>源代码。<br>速度是V8追求的主要设计目标之一，它把<code>JavaScript</code>代码直接编译成机器码运行，比起传统的“中间代码+解释器”的引擎，优势不言而喻。<br>V8的团队说Chrome对脚本的解析和执行速度是Firefox和Safari的10倍，是IE的56倍。</p><p>V8 是一个全新的 <code>JavaScript</code> 引擎，它在设计之初就以高效地执行大型的 <code>JavaScript</code> 应用程序为目的。V8的<code>JavaScript</code>渲染引擎亮点在于更快速更强壮的<code>JavaScript</code>解析。V8是一个非常反传统的<code>JavaScript</code>引擎，它能够在后台动态的对JS的对象进行分类——一个在其他高级语言中很常见但JS本身不支持的特性。V8对JS的解析不是基于反复loop源代码进行解释而是直接将JS代码编译成机器码运行。换句话说，V8引擎实际上可以看做是JS的扩展和编译器——而传统上类似于JS的解释型语言恰恰是不需要编译器的。最后，高级语言的内存管理效能一直是决定其运行效率的重要因素，而当前的JS虚拟机在这方面做的比较基本，对内存的回收也非常保守。V8使用的是非常强势的内存管理策略，一切在运行堆栈里无用的数据都会被强行回收，从而可以大大提高JS代码的运行效率。+</p><h2 id="了解Javascript引擎的执行机制"><a href="#了解Javascript引擎的执行机制" class="headerlink" title="了解Javascript引擎的执行机制"></a>了解Javascript引擎的执行机制</h2><p><strong>首先,请牢记2点:</strong></p><blockquote><p>(1) JS是单线程语言</p><p>(2) JS的Event Loop是JS的执行机制。深入了解JS的执行,就等于深入了解JS里的event loop</p></blockquote><h3 id="三问"><a href="#三问" class="headerlink" title="三问"></a>三问</h3><p>技术的出现,都跟现实世界里的应用场景密切相关的。</p><p>同样的,我们就结合现实场景,来回答这三个问题</p><h4 id="JS为什么是单线程的"><a href="#JS为什么是单线程的" class="headerlink" title="JS为什么是单线程的?"></a>JS为什么是单线程的?</h4><p>JS最初被设计用在浏览器中,那么想象一下,如果浏览器中的JS是多线程的。</p><pre><code class="html">场景描述:那么现在有2个线程,process1 process2,由于是多线程的JS,所以他们对同一个dom,同时进行操作process1 删除了该dom,而process2 编辑了该dom,同时下达2个矛盾的命令,浏览器究竟该如何执行呢?</code></pre><p>这样想,JS为什么被设计成单线程应该就容易理解了吧。</p><h4 id="JS为什么需要异步"><a href="#JS为什么需要异步" class="headerlink" title="JS为什么需要异步?"></a>JS为什么需要异步?</h4><pre><code class="html">场景描述:如果JS中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。对于用户而言,阻塞就意味着&quot;卡死&quot;,这样就导致了很差的用户体验</code></pre><p>所以,JS中存在异步执行。</p><h4 id="JS单线程又是如何实现异步的呢"><a href="#JS单线程又是如何实现异步的呢" class="headerlink" title="JS单线程又是如何实现异步的呢?"></a>JS单线程又是如何实现异步的呢?</h4><p>既然JS是单线程的,只能在一条线程上执行,又是如何实现的异步呢?</p><p><strong><em>是通过的事件循环(event loop),理解了event loop机制,就理解了JS的执行机制</em></strong></p><h3 id="JS中的event-loop"><a href="#JS中的event-loop" class="headerlink" title="JS中的event loop"></a>JS中的event loop</h3><p>例1,观察它的执行顺序</p><pre><code class="js">  console.log(1)  setTimeout(function()&#123;      console.log(2)  &#125;,0)  console.log(3)  // 1 3 2</code></pre><p>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。</p><p>所以,这里我们首先知道了JS里的一种分类方式,就是将任务分为: <strong>同步任务和异步任务</strong></p><p>按照这种分类方式:JS的执行机制是</p><ol><li>首先判断JS是同步还是异步,同步就进入主线程,异步就进入event table</li><li>异步任务在event table中注册函数,当满足触发条件后,被推入event queue</li><li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中</li></ol><p>以上三步循环执行,这就是event loop</p><p>所以上面的例子,你是否可以描述它的执行顺序了呢?</p><pre><code class="html">console.log(1) 是同步任务,放入主线程里setTimeout() 是异步任务,被放入event table, 0秒之后被推入event queue里console.log(3 是同步任务,放到主线程里当 1、 3在控制条被打印后,主线程去event queue(事件队列)里查看是否有可执行的函数,执行setTimeout里的函数</code></pre><p>所以,上面关于event loop就是我对JS执行机制的理解,直到我遇到了下面这段代码</p><pre><code class="js"> setTimeout(function()&#123;     console.log(&#39;定时器开始啦&#39;) &#125;); new Promise(function(resolve)&#123;     console.log(&#39;马上执行for循环啦&#39;);     for(var i = 0; i &lt; 10000; i++)&#123;         i == 99 &amp;&amp; resolve();     &#125; &#125;).then(function()&#123;     console.log(&#39;执行then函数啦&#39;) &#125;); console.log(&#39;代码执行结束&#39;);// 马上执行for循环啦 --- 代码执行结束 --- 执行then函数啦 --- 定时器开始啦</code></pre><p>那么,难道是异步任务的执行顺序,不是前后顺序,而是另有规定? 事实上,按照异步和同步的划分方式,并不准确。</p><p>而准确的划分方式是:</p><ul><li>**macro-task(宏任务)**：包括整体代码script，setTimeout，setInterval</li><li>**micro-task(微任务)**：Promise，process.nextTick</li></ul><p><img src="https://segmentfault.com/img/bV1TKz?w=879&h=723" alt="js event loop"></p><p>按照这种分类方式:JS的执行机制是</p><ul><li>执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里</li><li>当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完</li></ul><p>尝试按照刚学的执行机制,去分析例2:</p><pre><code class="html">首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里遇到 new Promise直接执行,打印&quot;马上执行for循环啦&quot;遇到then方法,是微任务,将其放到微任务的【队列里】打印 &quot;代码执行结束&quot;本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印&quot;执行then函数啦&quot;到此,本轮的event loop 全部完成。下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印&quot;定时器开始啦&quot;</code></pre><h3 id="谈谈setTimeout"><a href="#谈谈setTimeout" class="headerlink" title="谈谈setTimeout"></a>谈谈setTimeout</h3><p>这段setTimeout代码什么意思? 我们一般说: 3秒后,会执行setTimeout里的那个函数</p><pre><code class="js"> setTimeout(function()&#123;    console.log(&#39;执行了&#39;) &#125;,3000)    </code></pre><p>准确的解释是: 3秒后,<code>setTimeout</code>里的函数被会推入<code>event queue</code>,而<code>event queue</code>(事件队列)里的任务,只有在主线程空闲时才会执行。</p><p>如果主线程执行内容很多,执行时间超过3秒,比如执行了10秒,那么这个函数只能10秒后执行了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;各个浏览器引擎&quot;&gt;&lt;a href=&quot;#各个浏览器引擎&quot; class=&quot;headerlink&quot; title=&quot;各个浏览器引擎&quot;&gt;&lt;/a&gt;各个浏览器引擎&lt;/h2&gt;&lt;table</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之耗性能操作和时间复杂度</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%80%97%E6%80%A7%E8%83%BD%E6%93%8D%E4%BD%9C%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/14/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%80%97%E6%80%A7%E8%83%BD%E6%93%8D%E4%BD%9C%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2021-01-14T02:42:05.000Z</published>
    <updated>2021-01-14T05:46:52.428Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.cn/post/6844903543640424461">原文地址</a></p><h2 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h2><p>算法的定义是这样的：解题方案的准确而完善的描述，是一系列解决问题的清晰指令。</p><h2 id="算法的效率"><a href="#算法的效率" class="headerlink" title="算法的效率"></a>算法的效率</h2><p>既然算法是解决问题的描述，那么就像一千个人眼中有一千个阿姆雷特他大姨夫一样，解决同一个问题的办法也是多种多样的，只是在这过程中我们所使用/消耗的时间或者时间以外的代价（计算机消耗的则为内存了）不一样。为了更快、更好、更强的发扬奥利奥..哦不，提高算法的效率。所以很多时候<strong>一个优秀的算法就在于它与其他实现同一个问题的算法相比，在时间或空间（内存）或者时间和空间（内存）上都得到明显的降低</strong>。</p><p>所以呢，算法的效率主要由以下两个复杂度来评估：</p><blockquote><p>时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。</p></blockquote><blockquote><p>空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。</p></blockquote><p>设计算法时，<strong>时间复杂度要比空间复杂度更容易出问题</strong>，所以一般情况一下我们只对时间复杂度进行研究。<br>一般面试或者工作的时候没有特别说明的话，复杂度就是指时间复杂度。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>接下来我们还需要知道另一个概念：<strong>时间频度</strong>。这个时候你可能会说：“不是说好一起学算法吗，这些东东是什么？赠品吗？”。非也非也，这是非卖品。</p><p>因为一个算法执行所消耗的时间理论上是不能算出来的，没错正是理论上，so我们任然可以在程序中测试获得。但是我们不可能又没必要对每个算法进行测试，只需要知道大概的哪个算法执行所花费的时间多，哪个花费的时间少就行了。如果一个算法所花费的时间与算法中代码语句执行次数成正比，那么那个算法执行语句越多，它的花费时间也就越多。我们把一个算法中的语句执行次数称为时间频度。通常（ps:很想知道通常是谁）用<code>T(n)</code>表示。</p><p>在时间频度<code>T(n)</code>中，n又代表着问题的规模，当n不断变化时，<code>T(n)</code>也会不断地随之变化。为了了解这个变化的规律，时间复杂度这一概念就被引入了。一般情况下算法基础本操作的重复执行次数为问题规模n的某个函数，用也就是时间频度<code>T(n)</code>。如果有某个辅助函数f(n)，当趋于无穷大的时候，<code>T(n)/f(n)</code>的极限值是不为零的某个常数，那么<code>f(n)</code>是<code>T(n)</code>的同数量级函数，记作<code>T(n)=O(f(n))</code>，被称为算法的渐进时间复杂度，又简称为时间复杂度。</p><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p><strong>用O(n)来体现算法时间复杂度的记法被称作大O表示法</strong></p><p>一般我们我们评估一个算法都是直接评估它的最坏的复杂度。</p><p>大O表示法O<code>(f(n))</code>中的<code>f(n)</code>的值可以为<code>1、n、logn、n^2</code> 等，所以我们将<code>O(1)、O(n)、O(logn)、O( n^2 )</code>分别称为常数阶、线性阶、对数阶和平方阶。下面我们来看看推导大O阶的方法：</p><p><strong>推导大O阶</strong></p><ul><li>1.用常数1取代运行时间中的所有加法常数</li><li>2.只保留最高阶项</li><li>3.去除最高阶的常数</li></ul><p><strong>举例</strong></p><ul><li>常数例</li></ul><pre><code class="js">let sum = 0, n = 10; // 语句执行一次 let sum = (1+n)*n/2; // 语句执行一次 console.log(`The sum is : $&#123;sum&#125;`) //语句执行一次 </code></pre><p>这样的一段代码它的执行次数为 3 ，然后我们套用规则1，则这个算法的时间复杂度为O(1)，也就是常数阶。</p><ul><li>线性阶</li></ul><pre><code class="js">let i =0; // 语句执行一次 while (i &lt; n) &#123; // 语句执行n次   console.log(`Current i is $&#123;i&#125;`); //语句执行n次  i++; // 语句执行n次&#125;</code></pre><p>这个算法中代码总共执行了 <code>3n + 1</code>次，根据规则 2-&gt;3，因此该算法的时间复杂度是<code>O(n)</code>。</p><ul><li>对数阶</li></ul><pre><code class="js">let number = 1 // 语句执行一次while (number &lt; n) &#123; // 语句执行logn次  number *= 2; // 语句执行logn次&#125;</code></pre><p>上面的算法中，<code>number</code>每次都放大两倍，我们假设这个循环体执行了m次，那么2^m = n即m = logn，所以整段代码执行次数为1 + 2*logn，则<code>f(n) = logn</code>，时间复杂度为O(logn)。</p><ul><li>平方阶</li></ul><pre><code class="js">for (let i = 0; i &lt; n; i++) &#123; // 语句执行n次   for (let j = 0; j &lt; n; j++) &#123; // 语句执行n^2次      console.log(&#39;I am here!&#39;); // 语句执行n^2  &#125;&#125;</code></pre><p>上面的嵌套循环中，代码共执行 <code>2*n^2 + n</code>，则<code>f(n) = n^2</code>。所以该算法的时间复杂度为<code>O(n^2 )</code></p><h3 id="常见时间复杂度的比较"><a href="#常见时间复杂度的比较" class="headerlink" title="常见时间复杂度的比较"></a>常见时间复杂度的比较</h3><p>常见的时间复杂度函数相信大家在大学中都已经见过了，这里也不多做解释了：</p><p><code>O(1)&lt;O(log n)&lt;O(n)&lt;O(n log n)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)</code></p><p>先从简单直观的 <code>O(1)</code> 和 <code>O(n)</code> 复杂度说起。<code>O(1)</code> 表示一次操作即可直接取得目标元素（比如字典或哈希表），<code>O(n)</code> 意味着先要检查 n 个元素来搜索目标，但是 <code>O(log n)</code> 是什么意思呢？</p><p>你第一次听说 <code>O(log n)</code> 时间复杂度可能是在学二分搜索算法的时候。二分搜索一定有某种行为使其时间复杂度为 log n。我们来看看是二分搜索是如何实现的。</p><p>因为在最好情况下二分搜索的时间复杂度是 O(1)，最坏情况（平均情况）下 <code>O(log n)</code>，我们直接来看最坏情况下的例子。已知有 16 个元素的有序数组。</p><p>举个最坏情况的例子，比如我们要找的是数字 13。</p><p><img src="https://camo.githubusercontent.com/40f76a3e99b36549d2f5ac233780ef275daacf4e/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a644f4e586b583670635a6c4a735734704a54326134772e6a706567" alt="demo1"></p><p>选中间的元素作为中心点（长度的一半）</p><p><img src="https://user-gold-cdn.xitu.io/2017/6/13/12726f93c83b795478e688fbe973ce77?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo2"></p><p>13 小于中心点，所以不用考虑数组的后一半</p><p><img src="https://user-gold-cdn.xitu.io/2017/6/13/bc3501220fdd4c705893aeeca3a286fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo3"></p><p>重复这个过程，每次都寻找子数组的中间元素</p><p><img src="https://user-gold-cdn.xitu.io/2017/6/13/3e61716a0b5ac34ffb52e35cb9ab39d0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo4"><br><img src="https://user-gold-cdn.xitu.io/2017/6/13/68d35559a005b7b177b804938ae0d3ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo5"></p><p>每次和中间元素比较都会使搜索范围减半。</p><p>所以为了从 16 个元素中找到目标元素，我们需要把数组平均分割 4 次，也就是说，</p><p><img src="https://user-gold-cdn.xitu.io/2017/6/13/faa38db12044c0150ead404b953ca668?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo6"></p><p>简化后的公式</p><p>类似的，如果有 n 个元素，</p><p><img src="https://user-gold-cdn.xitu.io/2017/6/13/873e481a75e31a6d23d57cff15094b95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo7"></p><p>归纳一下<br><img src="https://user-gold-cdn.xitu.io/2017/6/13/0ef16a72ef31ea8bee0002afb703dbaa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo8"></p><p>分子和分母代入指数<br><img src="https://user-gold-cdn.xitu.io/2017/6/13/710b9141e0f9e1e76b0b7ca6bf120589?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo9"></p><p>等式两边同时乘以 2^k<br><img src="https://user-gold-cdn.xitu.io/2017/6/13/c0d863682bbc66aa5ac1471edf0f3d17?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo10"></p><p>对数形式</p><p>所以 log n 的确是有意义的，不是吗？没有其他什么可以表示这种行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903543640424461&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法定义&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之纯函数，函数副作用和状态变化</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/13/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%8C%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8%E5%92%8C%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/13/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%8C%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8%E5%92%8C%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96/</id>
    <published>2021-01-13T02:34:05.000Z</published>
    <updated>2021-01-13T05:53:47.620Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="纯函数（pure-function）"><a href="#纯函数（pure-function）" class="headerlink" title="纯函数（pure function）"></a>纯函数（pure function）</h2><p><a href="http://huziketang.mangojuice.top/books/react/lesson32">原文地址</a></p><p>简单的来说，<strong>一个函数返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数</strong></p><p>1.函数的返回结果只依赖于它的参数<br>2.函数执行过程里面没有副作用</p><h3 id="函数的返回结果只依赖于它的参数"><a href="#函数的返回结果只依赖于它的参数" class="headerlink" title="函数的返回结果只依赖于它的参数"></a>函数的返回结果只依赖于它的参数</h3><pre><code class="js">const a = 1const foo = (b) =&gt; a + bfoo(2) // 3</code></pre><p><code>foo</code> 函数不是一个纯函数，因为它返回的结果依赖于外部变量 <code>a</code>，我们在不知道 <code>a</code> 的值的情况下，并不能保证 <code>foo(2)</code> 的返回值是 3。虽然 <code>foo</code> 函数的代码实现并没有变化，传入的参数也没有变化，但它的返回值却是不可预料的，现在 <code>foo(2)</code> 是 3，可能过了一会就是 4 了，因为 <code>a</code> 可能发生了变化变成了 2。</p><pre><code class="js">const a = 1const foo = (x, b) =&gt; x + bfoo(1, 2) // =&gt; 3</code></pre><p>现在 foo 的返回结果只依赖于它的参数 <code>x</code> 和 <code>b</code>，foo(1, 2) 永远是 3。今天是 3，明天也是 3，在服务器跑是 3，在客户端跑也 3，不管你外部发生了什么变化，foo(1, 2) 永远是 3。<em>只要 foo 代码不改变，你传入的参数是确定的，那么 foo(1, 2) 的值永远是可预料的</em>。</p><p>这就是纯函数的第一个条件：<strong>一个函数的返回结果只依赖于它的参数</strong>。</p><h3 id="函数执行过程没有副作用"><a href="#函数执行过程没有副作用" class="headerlink" title="函数执行过程没有副作用"></a>函数执行过程没有副作用</h3><p>一个函数执行过程对产生了外部可观察的变化那么就说这个函数是有副作用的。</p><p>我们修改了一下 <code>foo</code>:</p><pre><code class="js">const a = 1const foo = (obj, b) =&gt; &#123;  return obj.x + b&#125;const counter = &#123; x: 1 &#125;foo(counter, 2) // =&gt; 3counter.x // =&gt; 1</code></pre><p>我们把原来的 <code>x</code> 换成了 <code>obj</code>，我现在可以往里面传一个对象进行计算，计算的过程里面并不会对传入的对象进行修改，计算前后的 <code>counter</code> 不会发生任何变化，计算前是 1，计算后也是 1，它现在是纯的。但是我再稍微修改一下它：</p><pre><code class="js">const a = 1const foo = (obj, b) =&gt; &#123;  obj.x = 2  return obj.x + b&#125;const counter = &#123; x: 1 &#125;foo(counter, 2) // =&gt; 4counter.x // =&gt; 2</code></pre><p>现在情况发生了变化，我在 <code>foo</code> 内部加了一句 <code>obj.x = 2</code>，计算前 <code>counter.x</code> 是 1，但是计算以后 <code>counter.x</code> 是 2。foo 函数的执行对外部的 <code>counter</code> 产生了影响，它产生了副作用，因为它修改了外部传进来的对象，现在它是不纯的。</p><p>但是你在函数内部构建的变量，然后进行数据的修改不是副作用：</p><pre><code class="js">const foo = (b) =&gt; &#123;  const obj = &#123; x: 1 &#125;  obj.x = 2  return obj.x + b&#125;</code></pre><p>虽然 <code>foo</code> 函数内部修改了 <code>obj</code>，但是 <code>obj</code> 是内部变量，外部程序根本观察不到，修改 <code>obj</code> 并不会产生外部可观察的变化，这个函数是没有副作用的，因此它是一个纯函数。</p><p>除了修改外部的变量，一个函数在执行过程中还有很多方式产生外部可观察的变化，比如说调用 DOM API 修改页面，或者你发送了 <code>Ajax</code> 请求，还有调用 <code>window.reload</code> 刷新浏览器，甚至是 <code>console.log</code> 往控制台打印数据也是副作用。</p><p>纯函数很严格，也就是说你几乎除了计算数据以外什么都不能干，计算的时候还不能依赖除了函数参数以外的数据。</p><p>为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便。</p><h2 id="js副作用"><a href="#js副作用" class="headerlink" title="js副作用"></a>js副作用</h2><p><a href="https://www.jb51.net/article/28079.htm">原文地址</a></p><blockquote><p>函数副作用 指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并且降低程序的可读性。严格的函数式语言要求函数必须无副作用。</p></blockquote><p>函数的副作用相关的几个概念， <code>Pure Function</code>、 <code>Impure Function</code>、 <code>Referential Transparent</code>。</p><p><code>纯函数 ( Pure Function )</code><br>输入输出数据流全是显式（Explicit）的。 显式（Explicit）的意思是，函数与外界交换数据只有一个唯一渠道——参数和返回值。函数从函数外部接受的所有输入信息都通过参数传递到该函数内部。函数输出到函数外部的所有信息都通过返回值传递到该函数外部。</p><p><code>非纯函数 ( Impure Function )</code><br>与之相反。 隐式（Implicit）的意思是，函数通过参数和返回值以外的渠道，和外界进行数据交换。比如读取/修改全局变量，都叫作以隐式的方式和外界进行数据交换。</p><p><code>引用透明 ( Referential Transparent )</code><br>引用透明的概念与函数的副作用相关，且受其影响。 如果程序中两个相同值的表达式能在该程序的任何地方互相替换，而不影响程序的动作，那么该程序就具有引用透明性。它的优点是比非引用透明的语言的语义更容易理解，不那么晦涩。纯函数式语言没有变量，所以它们都具有引用透明性</p><p>以下示例说明了引用透明与函数副作用的结合</p><pre><code class="js">result1 = (fun(a) + b) / (fun(a) -c);temp = fun(a);result2 = (temp + b) / (temp -c);</code></pre><p>如果函数没有副作用，那么result1和result2将是等价的。然而如果fun有副作用，比如让b或c加1，那么result1和result2将不相等。因此，副作用违背了引用透明性。</p><p>在JavaScript中，引入了函数。但显然JS中的函数可以访问、修改全局变量（或定义在函数外的变量），如下</p><pre><code class="js">var a = 5;function fun()&#123;a = 10;&#125;fun(); // a 变成了10</code></pre><blockquote><p>JS中要想保证函数无副作用这项特性，只能依靠编程人员的习惯，即</p></blockquote><ul><li>1.函数入口使用参数运算，而不修改它</li><li>2.函数内不修改函数外的变量，如全局变量</li><li>3.运算结果通过函数返回给外部（出口）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;纯函数（pure-function）&quot;&gt;&lt;a href=&quot;#纯函数（pure-function）&quot; class=&quot;headerlink&quot; title=&quot;纯函数（pure </summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之Memoization</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/12/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BMemoization/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/12/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BMemoization/</id>
    <published>2021-01-12T01:19:00.000Z</published>
    <updated>2021-01-12T02:11:29.895Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://segmentfault.com/a/1190000016703106">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>memoization 来源于拉丁语 memorandum (“to be remembered”)，不要与 memorization 混淆了。</strong></p><p>简单来说，<code>memoization</code> 是一种优化技术，主要用于<strong>通过存储昂贵的函数调用的结果来加速计算机程序，并在再次发生相同的输入时返回缓存的结果</strong>。</p><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><h3 id="不使用memoization"><a href="#不使用memoization" class="headerlink" title="不使用memoization"></a>不使用memoization</h3><pre><code class="js">const factorial = n =&gt;&#123;  if(n === 1)&#123;    return 1  &#125;else&#123;    return factorial(n - 1) * n  &#125;&#125;</code></pre><h3 id="使用memoiztion"><a href="#使用memoiztion" class="headerlink" title="使用memoiztion"></a>使用memoiztion</h3><pre><code class="js">const cache = []const factorial = n =&gt;&#123;  if(n === 1)&#123;    return 1  &#125;else if(cache[n - 1])&#123;    return cache[n - 1]  &#125;else&#123;    let result = factorial(n - 1) * n    cache[n - 1] = result    return result  &#125;&#125;</code></pre><h3 id="使用闭包和memoiztion"><a href="#使用闭包和memoiztion" class="headerlink" title="使用闭包和memoiztion"></a>使用闭包和memoiztion</h3><p>常见的方式就是 闭包 和 memoiztion 一起搭配使用：</p><pre><code class="js">const factorialMemo = () =&gt;&#123;  const cache = []  const factorial = n =&gt;&#123;    if(n === 1)&#123;      return 1    &#125; else if(cache[n - 1])&#123;      console.log(`get factorial($&#123;n&#125;) from cache...`)      return cache[n - 1]    &#125;else &#123;      let result = factorial(n - 1) * n      cache[n - 1] = result      return result    &#125;  &#125;&#125;</code></pre><p>继续变形,下面这种编写方式是最常见的形式。</p><pre><code class="js">const factorMemo = func =&gt;&#123;  const cache = []  return function(n)&#123;    if(cache[n - 1])&#123;      console.log(`get factorial($&#123;n&#125;) from cache...`)      return cache[n - 1]    &#125;else&#123;      const result = func.apply(null,arguments)      cache[n - 1] = result      return result    &#125;  &#125;&#125;const factorial = factorMemo(function(n)&#123;  return n === 1 ? 1 : factorial(n - 1) * n&#125;)</code></pre><p>从阶乘的这个例子可以知道 <code>memoization</code> 是一个<em>空间换时间的方式</em>，存储执行结果，下次再次发生相同的输入会直接输出结果，提高了执行的速度。</p><h2 id="underscore-源码中的-memoization"><a href="#underscore-源码中的-memoization" class="headerlink" title="underscore 源码中的 memoization"></a>underscore 源码中的 memoization</h2><pre><code class="js">// Memoize an expensive function by storing its results._.memoize = function(func, hasher) &#123;    var memoize = function(key) &#123;        var cache = memoize.cache;        var address = &#39;&#39; + (hasher ? hasher.apply(this, arguments) : key);        if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);        return cache[address];    &#125;;    memoize.cache = &#123;&#125;;    return memoize;&#125;;</code></pre><p>代码一目了然，使用 <code>_.memoize</code> 来实现阶乘如下：</p><pre><code class="js">const factorial = _.memoize(function(n) &#123;    return n === 1 ? 1 : factorial(n - 1) * n&#125;);</code></pre><p>参照这个源码，上面的阶乘继续可以变形如下：</p><pre><code class="js">const factorialMemo = func =&gt; &#123;    const memoize = function(n) &#123;        const cache = memoize.cache        if (cache[n - 1]) &#123;            console.log(`get factorial($&#123;n&#125;) from cache...`)            return cache[n - 1]        &#125; else &#123;            const result = func.apply(null, arguments)            cache[n - 1] = result            return result        &#125;    &#125;    // CHANGE    memoize.cache = []    return memoize&#125;const factorial = factorialMemo(function(n) &#123;    return n === 1 ? 1 : factorial(n - 1) * n&#125;);</code></pre><h2 id="reselect-源码中的-memoization"><a href="#reselect-源码中的-memoization" class="headerlink" title="reselect 源码中的 memoization"></a>reselect 源码中的 memoization</h2><pre><code class="js">export function defaultMemoize(func, equalityCheck = defaultEqualityCheck) &#123;    let lastArgs = null    let lastResult = null    // we reference arguments instead of spreading them for performance reasons    return function () &#123;        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) &#123;            // apply arguments instead of spreading for performance.            lastResult = func.apply(null, arguments)        &#125;        lastArgs = arguments        return lastResult    &#125;&#125;;</code></pre><p>从源码可以知道当 <code>lastArgs</code> 与 <code>arguments</code> 相同的时候，就不会再执行 <code>func</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016703106&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之设计模式</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/11/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/11/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-01-11T01:15:43.000Z</published>
    <updated>2021-01-11T02:00:42.392Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.cn/post/6844903503266054157">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案</p></blockquote><p>当然我们可以用一个通俗的说法：设计模式是解决某个特定场景下对某种问题的解决方案。因此，当我们遇到合适的场景时，我们可能会条件反射一样自然而然想到符合这种场景的设计模式。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</p><p><strong>适用场景：</strong> 一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。</p><pre><code class="js">class CreateUser &#123;  contructor(name)&#123;    this.name = name;    this.getName()  &#125;  getName()&#123;    return this.name+  &#125;&#125;// 代理实现单例模式var ProxyMode = (function()&#123;  var instance = null  return function(name) &#123;    if(!instance)&#123;       instance = new CreateUser(name)    &#125;    return instance  &#125;&#125;)// 测试单例模式var a = new ProxyMode(&#39;aaa&#39;)var b = new ProxyMode(&#39;bbb&#39;)console.log(a === b) //true</code></pre><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>策略模式的定义：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。</p></blockquote><p>一个基于策略模式的程序至少由两部分组成。第一个部分<strong>是一组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程</strong>。第二个部分是<strong>环境类Context（不变），Context接受客户的请求，随后将请求委托给某一个策略类</strong>。要做到这一点，说明Context中要维持对某个策略对象的引用。</p><pre><code class="js">/*策略类*/var levelOBJ = &#123;    &quot;A&quot;: function(money) &#123;        return money * 4;    &#125;,    &quot;B&quot; : function(money) &#123;        return money * 3;    &#125;,    &quot;C&quot; : function(money) &#123;        return money * 2;    &#125; &#125;;/*环境类*/var calculateBouns =function(level,money) &#123;    return levelOBJ[level](money);&#125;;console.log(calculateBouns(&#39;A&#39;,10000)); // 40000</code></pre><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>代理模式的定义：为一个对象提供一个代用品或占位符，以便控制对它的访问</p></blockquote><p>常用的虚拟代理形式：<strong>某一个花销很大的操作，可以通过虚拟代理的方式延迟到这种需要它的时候才去创建</strong>（例：使用虚拟代理实现图片懒加载）</p><pre><code class="js">var imgFunc = (function()&#123;  var imgNode = document.createElement(&quot;img&quot;);  document.body.appendChild(imgNode)  return &#123;    setSrc(src)&#123;      img.src = src    &#125;  &#125;&#125;)()var proxyImg = (function()&#123;  var img = new Image();  img.onload = function()&#123;    imgFunc.setSrc(this.src)  &#125;  return &#123;    setSrc(src)&#123;      imgFunc.setSrc(&#39;./loading.gif&#39;)      img.src = src    &#125;  &#125;&#125;)()propxyImg.setSrc(&#39;./test.png&#39;)</code></pre><p>使用代理模式实现图片懒加载的优点还有符合单一职责原则。减少一个类或方法的粒度和耦合度。</p><h2 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h2><blockquote><p>中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。</p></blockquote><p>例如：现实生活中，航线上的飞机只需要和机场的塔台通信就能确定航线和飞行状态，而不需要和所有飞机通信。同时塔台作为中介者，知道每架飞机的飞行状态，所以可以安排所有飞机的起降和航线安排。</p><p>中介者模式适用的场景：例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p><pre><code class="js">var goods = &#123;   //手机库存    &#39;red|32G&#39;: 3,    &#39;red|64G&#39;: 1,    &#39;blue|32G&#39;: 7,    &#39;blue|32G&#39;: 6,&#125;;//中介者var mediator = (function() &#123;    var colorSelect = document.getElementById(&#39;colorSelect&#39;);    var memorySelect = document.getElementById(&#39;memorySelect&#39;);    var numSelect = document.getElementById(&#39;numSelect&#39;);    return &#123;        changed: function(obj) &#123;            switch(obj)&#123;                case colorSelect:                    //TODO                    break;                case memorySelect:                    //TODO                    break;                case numSelect:                    //TODO                    break;            &#125;        &#125;    &#125;&#125;)();colorSelect.onchange = function() &#123;    mediator.changed(this);&#125;;memorySelect.onchange = function() &#123;    mediator.changed(this);&#125;;numSelect.onchange = function() &#123;    mediator.changed(this);&#125;;</code></pre><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><blockquote><p>装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法。</p></blockquote><p>例如：现有4种型号的自行车分别被定义成一个单独的类，如果给每辆自行车都加上前灯、尾灯、铃铛这3个配件，如果用类继承的方式，需要创建4*3=12个子类。但如果通过装饰者模式，只需要创建3个类。</p><p>装饰者模式适用的场景：<strong>原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求</strong>；函数的解耦，将函数拆分成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，实现相同的效果但增强了复用性</p><p>例：用AOP装饰函数实现装饰者模式</p><pre><code class="js">Function.prototype.before = function()&#123;  var self = this;  return function()&#123;    beforefn.apply(this,arguments)    return self.apply(this,arguments)  &#125;&#125;Function.prototype.after = function () &#123;  return function()&#123;    var ret = self.apply(this,arguments)    afterfn.apply(this,arguments)    return ret  &#125;&#125;var func = function()&#123;  console.log(&#39;2&#39;)&#125;var func1 = function()&#123;  console.log(&#39;1&#39;)&#125;var func2 = function()&#123;  console.log(&#39;2&#39;)&#125;func = func.before(func1).after(func2)func()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903503266054157&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之类和工厂模式</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/08/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/08/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-01-08T01:19:07.000Z</published>
    <updated>2021-01-08T02:47:42.489Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是用于创建对象的模板。他们用代码封装数据以处理该数据。 JS中的类建立在原型上，但也具有某些语法和语义未与ES5类相似语义共享。</p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>实际上类是特殊的函数。类的语法有两个组成部分：<strong>类表达式和类声明</strong></p><p><strong>类声明</strong></p><pre><code class="js"> class Rectangle&#123;   constructor(height,width)&#123;     this.height = height     this.width = width   &#125; &#125;</code></pre><p><strong>类表达式</strong></p><pre><code class="js">let Rectangle = class Rectangle2 &#123;  constructor(height, width) &#123;    this.height = height;    this.width = width;  &#125;&#125;</code></pre><h3 id="使用-extends-扩展子类"><a href="#使用-extends-扩展子类" class="headerlink" title="使用 extends 扩展子类"></a>使用 extends 扩展子类</h3><p><code>extends</code>关键字在 类声明 或 类表达式 中用于创建一个类作为另一个类的一个子类。</p><pre><code class="js">class Animal &#123;  constructor(name) &#123;    this.name = name;  &#125;  speak() &#123;    console.log(`$&#123;this.name&#125; makes a noise.`);  &#125;&#125;class Dog extends Animal &#123;  constructor(name) &#123;    super(name); // 调用超类构造函数并传入name参数  &#125;  speak() &#123;    console.log(`$&#123;this.name&#125; barks.`);  &#125;&#125;var d = new Dog(&#39;Mitzie&#39;);d.speak();// &#39;Mitzie barks.&#39;</code></pre><h3 id="使用-super-调用超类"><a href="#使用-super-调用超类" class="headerlink" title="使用 super 调用超类"></a>使用 super 调用超类</h3><p><code>super</code> 关键字用于调用对象的父对象上的函数。</p><pre><code class="js">class Cat &#123;  constructor(name) &#123;    this.name = name;  &#125;  speak() &#123;    console.log(this.name + &#39; makes a noise.&#39;);  &#125;&#125;class Lion extends Cat &#123;  speak() &#123;    super.speak();    console.log(this.name + &#39; roars.&#39;);  &#125;&#125;</code></pre><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>Abstract Factory（抽象工厂）属于创建型模式，工厂类模式抽象程度从低到高分为：简单工厂模式 -&gt; 工厂模式 -&gt; 抽象工厂模式。</p><p><strong>提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。</strong></p><p>使用工厂函数，你可以根据需要创建任意数量的用户对象。假如你正在开发一个聊天应用，你会用一个用户对象表示当前用户，以及用很多个用户对象表示其他已登录和在聊天的用户，以便显示他们的名字和头像等等。</p><p>让我们把 user 对象转换为一个 <code>createUser()</code> 工厂方法:</p><pre><code class="js">const createUser = (&#123; userName, avatar &#125;) =&gt; (&#123;  userName,  avatar,  setUserName (userName) &#123;    this.userName = userName;    return this;  &#125;&#125;);console.log(createUser(&#123; userName: &#39;echo&#39;, avatar: &#39;echo.png&#39; &#125;));/*&#123;  &quot;avatar&quot;: &quot;echo.png&quot;,  &quot;userName&quot;: &quot;echo&quot;,  &quot;setUserName&quot;: [Function setUserName]&#125;*/</code></pre><p>最后，你还要切记，不要把事情搞复杂，工厂函数不是必需的，对于某个问题，你的解决思路应当是：</p><p><code>纯函数 &gt; 工厂函数 &gt; 函数式 Mixin &gt; 类</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;p&gt;类是用于创建对象的模板。他们用代码封装数据以处理该数据</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得的33个概念之Object.create和Object.assign</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/07/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BObject-create%E5%92%8CObject-assign/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/07/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BObject-create%E5%92%8CObject-assign/</id>
    <published>2021-01-07T01:23:17.000Z</published>
    <updated>2021-01-08T01:19:46.025Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>来源<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">MDN</a></p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p><code>Object.create()</code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p><pre><code class="js">const person = &#123;  isHuman: false,  printIntroduction: function() &#123;    console.log(`My name is $&#123;this.name&#125;. Am I human? $&#123;this.isHuman&#125;`);  &#125;&#125;;const me = Object.create(person);me.name = &#39;Matthew&#39;; // &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;me.isHuman = true; // inherited properties can be overwrittenme.printIntroduction();</code></pre><h2 id="Object-assign-target-…source"><a href="#Object-assign-target-…source" class="headerlink" title="Object.assign(target,…source)"></a>Object.assign(target,…source)</h2><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。</p><p><code>null</code> 或 <code>undefined</code> 源被视为空对象一样对待，不会对目标对象产生任何影响。”</p><pre><code class="js">const target1 = &#123;a: 1, b: 2&#125;const target2 = &#123;c: 3, d: 4&#125;const returnTarget = Object.assign(target1, target2)console.log(target1)console.log(returnTarget)</code></pre><h3 id="深拷贝的问题"><a href="#深拷贝的问题" class="headerlink" title="深拷贝的问题"></a>深拷贝的问题</h3><p>针对深拷贝，需要使用其他办法，因为 <code>Object.assign()</code>拷贝的是（可枚举）属性值。</p><p>假如源值是一个对象的引用，它仅仅会复制其引用值。</p><pre><code class="js">const log = console.log;function test() &#123;  &#39;use strict&#39;;  let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;  let obj2 = Object.assign(&#123;&#125;, obj1);  log(JSON.stringify(obj2));  // &#123; a: 0, b: &#123; c: 0&#125;&#125;  obj1.a = 1;  log(JSON.stringify(obj1));  // &#123; a: 1, b: &#123; c: 0&#125;&#125;  log(JSON.stringify(obj2));  // &#123; a: 0, b: &#123; c: 0&#125;&#125;  obj2.a = 2;  log(JSON.stringify(obj1));  // &#123; a: 1, b: &#123; c: 0&#125;&#125;  log(JSON.stringify(obj2));  // &#123; a: 2, b: &#123; c: 0&#125;&#125;  obj2.b.c = 3;  log(JSON.stringify(obj1));  // &#123; a: 1, b: &#123; c: 3&#125;&#125;  log(JSON.stringify(obj2));  // &#123; a: 2, b: &#123; c: 3&#125;&#125;  // Deep Clone  obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;  let obj3 = JSON.parse(JSON.stringify(obj1));  obj1.a = 4;  obj1.b.c = 4;  log(JSON.stringify(obj3));  // &#123; a: 0, b: &#123; c: 0&#125;&#125;&#125;test();</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;来源&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Object</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之原型继承及原型链</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/06/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/06/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2021-01-06T01:45:25.000Z</published>
    <updated>2021-01-06T03:17:02.004Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>JavaScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是<strong>利用原型让一个引用类型继承另一个引用类型的属性和方法</strong>。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针</p><p><img src="https://segmentfault.com/img/bVvUCD" alt="原型，构造函数，实例"></p><p>那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p><p>ECMAScript中无法实现接口继承.ECMAScript只支持<code>实现继承</code>,而且其 <strong>实现继承 主要是依靠原型链来实现的</strong>.</p><p>使用原型链后, 我们怎么去判断原型和实例的这种继承关系呢? 方法一般有两种.</p><blockquote><p>第一种是使用 <code>instanceof</code> 操作符, 只要用这个操作符来测试实例(instance)与原型链中出现过的构造函数,结果就会返回true. 以下几行代码就说明了这点.</p></blockquote><pre><code class="js">alert(instance instanceof Object);//truealert(instance instanceof Father);//truealert(instance instanceof Son);//true</code></pre><blockquote><p>第二种是使用 <code>isPrototypeOf()</code> 方法, 同样只要是原型链中出现过的原型,<code>isPrototypeOf()</code> 方法就会返回true, 如下所示.</p></blockquote><pre><code class="js">alert(Object.prototype.isPrototypeOf(instance));//truealert(Father.prototype.isPrototypeOf(instance));//truealert(Son.prototype.isPrototypeOf(instance));//true</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>原型链并非十分完美, 它包含如下两个问题.</p><blockquote><p>问题一: 当原型链中包含引用类型值的原型时,该引用类型值<strong>会被所有实例共享</strong>;<br>问题二: 在创建子类型(例如创建Son的实例)时,不能向超类型(例如Father)的构造函数中传递参数.</p></blockquote><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>为解决原型链中上述两个问题, 我们开始使用一种叫做<strong>借用构造函数</strong>(constructor stealing)的技术(也叫经典继承).</p><blockquote><p>基本思想:即在子类型构造函数的内部调用超类型构造函数.</p></blockquote><pre><code class="js">function Father()&#123;    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;function Son()&#123;    Father.call(this);//继承了Father,且向父类型传递参数&#125;var instance1 = new Son();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);//&quot;red,blue,green,black&quot;var instance2 = new Son();console.log(instance2.colors);//&quot;red,blue,green&quot; 可见引用类型值是独立的</code></pre><p>很明显,借用构造函数一举解决了原型链的两大问题:</p><p>其一, 保证了原型链中引用类型值的独立,不再被所有实例共享;<br>其二, 子类型创建时也能够向父类型传递参数.</p><p>随之而来的是, 如果仅仅借用构造函数,那么将无法避免构造函数模式存在的问题–<strong>方法都在构造函数中定义</strong>, 因此函数复用也就不可用了.而且超类型(如Father)中定义的方法,对子类型而言也是不可见的. 考虑此,借用构造函数的技术也很少单独使用.</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式.</p><blockquote><p>基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承.</p></blockquote><p>这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 如下所示.</p><pre><code class="js">function Father(name)&#123;    this.name = name;    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;Father.prototype.sayName = function()&#123;    alert(this.name);&#125;;function Son(name,age)&#123;    Father.call(this,name);//继承实例属性，第一次调用Father()    this.age = age;&#125;Son.prototype = new Father();//继承父类方法,第二次调用Father()Son.prototype.sayAge = function()&#123;    alert(this.age);&#125;var instance1 = new Son(&quot;louis&quot;,5);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);//&quot;red,blue,green,black&quot;instance1.sayName();//louisinstance1.sayAge();//5var instance1 = new Son(&quot;zhai&quot;,10);console.log(instance1.colors);//&quot;red,blue,green&quot;instance1.sayName();//zhaiinstance1.sayAge();//10</code></pre><p>组合继承避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为 JavaScript 中最常用的继承模式. 而且, instanceof 和 isPrototypeOf( )也能用于识别基于组合继承创建的对象.<br>同时我们还注意到组合继承其实调用了两次父类构造函数, 造成了不必要的消耗, 那么怎样才能避免这种不必要的消耗呢, 这个我们将在后面讲到.</p><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><blockquote><p>在<code>object()</code>函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例.</p></blockquote><pre><code class="js">function object(o)&#123;    function F()&#123;&#125;    F.prototype = o;    return new F();&#125;</code></pre><p>从本质上讲, <code>object()</code> 返回了一个引用传入对象的新对象. 这样<strong>可能带来一些共享数据的问题</strong>，如下.</p><pre><code class="js">var person = &#123;    friends : [&quot;Van&quot;,&quot;Louis&quot;,&quot;Nick&quot;]&#125;;var anotherPerson = object(person);anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.friends.push(&quot;Style&quot;);alert(person.friends);//&quot;Van,Louis,Nick,Rob,Style&quot;</code></pre><p>在 ECMAScript5 中,通过新增 <code>object.create()</code> 方法规范化了上面的原型式继承.</p><p><code>object.create()</code> 接收两个参数:</p><ul><li>一个用作新对象原型的对象</li><li>(可选的)一个为新对象定义额外属性的对象</li></ul><pre><code class="js">var person = &#123;    name : &quot;Van&quot;&#125;;var anotherPerson = Object.create(person, &#123;    name : &#123;        value : &quot;Louis&quot;    &#125;&#125;);alert(anotherPerson.name);//&quot;Louis&quot;</code></pre><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><blockquote><p>寄生式继承的思路与(寄生)构造函数和工厂模式类似, 即<strong>创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真的是它做了所有工作一样返回对象</strong>. 如下.</p></blockquote><pre><code class="js">function createAnother(original)&#123;    var clone = object(original);//通过调用object函数创建一个新对象    clone.sayHi = function()&#123;//以某种方式来增强这个对象        alert(&quot;hi&quot;);    &#125;;    return clone;//返回这个对象&#125;</code></pre><p>这个例子中的代码基于person返回了一个新对象–<code>anotherPerson</code>. 新对象不仅具有 <code>person</code> 的所有属性和方法, 而且还被增强了, 拥有了<code>sayH()</code>方法.</p><p><strong>注意</strong>: 使用寄生式继承来为对象添加函数, 会由于不能做到函数复用而降低效率;这一点与构造函数模式类似.</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>前面讲过,组合继承是 <code>JavaScript</code> 最常用的继承模式; 不过, 它也有自己的不足. 组合继承最大的问题就是无论什么情况下,都会调用<strong>两次父类构造函数</strong>;</p><p>一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部. </p><p><strong>寄生组合式继承就是为了降低调用父类构造函数的开销而出现的 .</strong></p><blockquote><p>其背后的基本思路是: 不必为了指定子类型的原型而调用超类型的构造函数</p></blockquote><pre><code class="js">function extend(subClass,superClass)&#123;    var prototype = object(superClass.prototype);//创建对象    prototype.constructor = subClass;//增强对象    subClass.prototype = prototype;//指定对象&#125;</code></pre><p><code>extend</code>的高效率体现在它没有调用<code>superClass</code>构造函数,因此避免了在<code>subClass.prototype</code>上面创建不必要,多余的属性. 于此同时,原型链还能保持不变; 因此还能正常使用 <code>instanceof</code> 和 <code>isPrototypeOf() </code>方法.</p><p>下面我们来看下<code>extend</code>的另一种更为有效的扩展.</p><pre><code class="js">function extend(subClass, superClass) &#123;  var F = function() &#123;&#125;;  F.prototype = superClass.prototype;  subClass.prototype = new F();   subClass.prototype.constructor = subClass;  subClass.superclass = superClass.prototype;  if(superClass.prototype.constructor == Object.prototype.constructor) &#123;    superClass.prototype.constructor = superClass;  &#125;&#125;</code></pre><p>我一直不太明白的是为什么要 “new F()”, 既然extend的目的是将子类型的 <code>prototype</code> 指向超类型的<code>prototype</code>,为什么不直接做如下操作呢?</p><pre><code class="js">subClass.prototype = superClass.prototype;//直接指向超类型prototype</code></pre><p>显然, 基于如上操作, 子类型原型将与超类型原型共用, 根本就没有继承关系.</p><p>那么最终,原型链继承可以这么实现,例如:</p><pre><code class="js">function Father(name)&#123;    this.name = name;    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;Father.prototype.sayName = function()&#123;    alert(this.name);&#125;;function Son(name,age)&#123;    Father.call(this,name);//继承实例属性，第一次调用Father()    this.age = age;&#125;extend(Son,Father)//继承父类方法,此处并不会第二次调用Father()Son.prototype.sayAge = function()&#123;    alert(this.age);&#125;var instance1 = new Son(&quot;louis&quot;,5);instance1.colors.push(&quot;black&quot;);console.log(instance1.colors);//&quot;red,blue,green,black&quot;instance1.sayName();//louisinstance1.sayAge();//5var instance1 = new Son(&quot;zhai&quot;,10);console.log(instance1.colors);//&quot;red,blue,green&quot;instance1.sayName();//zhaiinstance1.sayAge();//10</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h2&gt;&lt;p&gt;JavaScript 中描述了原型链的</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之new 与构造函数，instanceof 与实例</title>
    <link href="https://shinichikudo-fe.github.io/2021/01/05/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bnew-%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8Cinstanceof-%E4%B8%8E%E5%AE%9E%E4%BE%8B/"/>
    <id>https://shinichikudo-fe.github.io/2021/01/05/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8Bnew-%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8Cinstanceof-%E4%B8%8E%E5%AE%9E%E4%BE%8B/</id>
    <published>2021-01-05T07:42:16.000Z</published>
    <updated>2021-01-05T09:00:46.607Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在Javascript中，万物皆对象，如果需要在JavaScript中生成一个对象，而对象是单个实物的抽象，通常需要一个模版，表示某一类实物的共同特征，然后根据这个模板生成</p><p>在Javascript中构造函数就称为模板。一个构造函数可以生成多个实例对象，这些实例对象都有相同的结构,构造函数名字的<strong>第一个字母通常大写</strong></p><p>构造函数有两个特点：</p><blockquote><p>函数内部使用了this关键字，代表了所要生成的对象实例<br>生成对象的时候，必须使用new命令</p></blockquote><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new命令的作用，就是执行构造函数，返回一个实例对象。</p><p>new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。</p><p>如果忘了使用new命令，直接调用构造函数会发生什么事？</p><p>这种情况下，<strong>构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果</strong>。</p><h3 id="new的原理"><a href="#new的原理" class="headerlink" title="new的原理"></a>new的原理</h3><blockquote><ol><li>创建一个空对象，作为将要返回的对象实例。</li><li>将这个空对象的原型，指向构造函数的prototype属性。</li><li>将这个空对象赋值给函数内部的this关键字。</li><li>开始执行构造函数内部的代码。</li></ol></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实例就是通过构造函数创建出来的对象</p><pre><code class="js">var M = function()&#123;  this.name = &#39;Jane&#39;;&#125;var obj = new M();</code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><code>instanceof</code>表示的就是一种继承关系，或者原型链的结构。</p><p>由于所有的对象的原型链都会找到<code>Object.prototype</code>，因此所有的对象都会有<code>Object.prototype</code>的方法。这就是所谓的“继承”</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><pre><code class="js">function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式  var O = R.prototype;// 取 R 的显示原型  L = L.__proto__;// 取 L 的隐式原型  while (true) &#123;    if (L === null)      return false;    if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true      return true;    L = L.__proto__;  &#125; &#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>创建一个新的对象可以通过<code>new</code>关键字 + 构造函数 来生成新的实例对象，通过<code>instanceof</code> 可以找到实例的构造函数的原型</p><p><code>instanceof</code>找到的是实例在原型链中所有的构造函数，不容易找到直接创建实例的构造函数；</p><p><code>constructor</code>找到的是构造函数只有一个，就是直接创建这个实例的构造函数，所以用<code>constructor</code>找实例的构造函数更严谨。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;p&gt;在Javascript中，万物</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>如何在React中完美运用？</title>
    <link href="https://shinichikudo-fe.github.io/2020/12/28/React/%E5%A6%82%E4%BD%95%E5%9C%A8React%E4%B8%AD%E5%AE%8C%E7%BE%8E%E8%BF%90%E7%94%A8%EF%BC%9F/"/>
    <id>https://shinichikudo-fe.github.io/2020/12/28/React/%E5%A6%82%E4%BD%95%E5%9C%A8React%E4%B8%AD%E5%AE%8C%E7%BE%8E%E8%BF%90%E7%94%A8%EF%BC%9F/</id>
    <published>2020-12-28T08:27:03.000Z</published>
    <updated>2020-12-28T10:12:52.391Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.cn/post/6910863689260204039">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实如果运用熟练的话，TS 只是在第一次开发的时候稍微多花一些时间去编写类型，后续维护、重构的时候就会发挥它神奇的作用了，还是非常推荐长期维护的项目使用它的。</p><h2 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h2><p>阅读本文的前提条件是：</p><p>熟悉 React 的使用。<br>熟悉 TypeScript 中的类型知识。<br>本文会侧重使用 React Hook 作为示例，当然大部分类型知识都是通用的。</p><p>也就是说，这篇文章侧重点在于 「<strong>React 和 TypeScript 的结合」</strong>，而不是基础知识，基础知识阅读文档即可学习。</p><h2 id="组件-Props"><a href="#组件-Props" class="headerlink" title="组件 Props"></a>组件 Props</h2><p>先看几种定义 Props 经常用到的类型：</p><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><pre><code class="js">type BasicProps = &#123;  message: string;  count: number;  disabled: boolean;  /** 数组类型 */  names: string[];  /** 用「联合类型」限制为下面两种「字符串字面量」类型 */  status: &quot;waiting&quot; | &quot;success&quot;;&#125;;</code></pre><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><pre><code class="js">type ObjectOrArrayProps = &#123;  /** 如果你不需要用到具体的属性 可以这样模糊规定是个对象 ❌ 不推荐 */  obj: object;  obj2: &#123;&#125;; // 同上  /** 拥有具体属性的对象类型 ✅ 推荐 */  obj3: &#123;    id: string;    title: string;  &#125;;  /** 对象数组 😁 常用 */  objArr: &#123;    id: string;    title: string;  &#125;[];  /** key 可以为任意 string，值限制为 MyTypeHere 类型 */  dict1: &#123;    [key: string]: MyTypeHere;  &#125;;  dict2: Record&lt;string, MyTypeHere&gt;; // 基本上和 dict1 相同，用了 TS 内置的 Record 类型。&#125;</code></pre><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><pre><code class="js">type FunctionProps = &#123;  /** 任意的函数类型 ❌ 不推荐 不能规定参数以及返回值类型 */  onSomething: Function;  /** 没有参数的函数 不需要返回值 😁 常用 */  onClick: () =&gt; void;  /** 带函数的参数 😁 非常常用 */  onChange: (id: number) =&gt; void;  /** 另一种函数语法 参数是 React 的按钮事件 😁 非常常用 */  onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void;  /** 可选参数类型 😁 非常常用 */  optional?: OptionalType;&#125;</code></pre><h3 id="React-相关类型"><a href="#React-相关类型" class="headerlink" title="React 相关类型"></a>React 相关类型</h3><pre><code class="js">export declare interface AppProps &#123;  children1: JSX.Element; // ❌ 不推荐 没有考虑数组  children2: JSX.Element | JSX.Element[]; // ❌ 不推荐 没有考虑字符串 children  children4: React.ReactChild[]; // 稍微好点 但是没考虑 null  children: React.ReactNode; // ✅ 包含所有 children 情况  functionChildren: (name: string) =&gt; React.ReactNode; // ✅ 返回 React 节点的函数  style?: React.CSSProperties; // ✅ 推荐 在内联 style 时使用  // ✅ 推荐原生 button 标签自带的所有 props 类型  // 也可以在泛型的位置传入组件 提取组件的 Props 类型  props: React.ComponentProps&lt;&quot;button&quot;&gt;;  // ✅ 推荐 利用上一步的做法 再进一步的提取出原生的 onClick 函数类型   // 此时函数的第一个参数会自动推断为 React 的点击事件类型  onClickButton：React.ComponentProps&lt;&quot;button&quot;&gt;[&quot;onClick&quot;]&#125;</code></pre><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>最简单的：</p><pre><code class="js">interface AppProps = &#123; message: string &#125;;const App = (&#123; message &#125;: AppProps) =&gt; &lt;div&gt;&#123;message&#125;&lt;/div&gt;;</code></pre><p>包含 <code>children</code> 的：</p><p>利用 <code>React.FC</code> 内置类型的话，不光会包含你定义的 <code>AppProps</code> 还会自动加上一个 <code>children</code> 类型，以及其他组件上会出现的类型：</p><pre><code class="js">// 等同于AppProps &amp; &#123;   children: React.ReactNode   propTypes?: WeakValidationMap&lt;P&gt;;  contextTypes?: ValidationMap&lt;any&gt;;  defaultProps?: Partial&lt;P&gt;;  displayName?: string;&#125;// 使用interface AppProps = &#123; message: string &#125;;const App: React.FC&lt;AppProps&gt; = (&#123; message, children &#125;) =&gt; &#123;  return (    &lt;&gt;     &#123;children&#125;     &lt;div&gt;&#123;message&#125;&lt;/div&gt;    &lt;/&gt;  )&#125;;</code></pre><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><p><code>@types/react</code> 包在 16.8 以上的版本开始对 Hooks 的支持。</p><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>如果你的默认值已经可以说明类型，那么不用手动声明类型，交给 TS 自动推断即可：</p><pre><code class="js">// val: booleanconst [val, toggle] = React.useState(false);toggle(false)toggle(true)</code></pre><p>如果初始值是 <code>null</code> 或 <code>undefined</code>，那就要通过泛型手动传入你期望的类型。</p><pre><code class="js">const [user, setUser] = React.useState&lt;IUser | null&gt;(null);// later...setUser(newUser);</code></pre><p>这样也可以保证在你直接访问 <code>user</code> 上的属性时，提示你它有可能是 <code>null</code>。</p><p>通过 <code>optional-chaining</code> 语法（TS 3.7 以上支持），可以避免这个错误。</p><pre><code class="js">// ✅ okconst name = user?.name</code></pre><h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><p>需要用 <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions">Discriminated Unions</a> 来标注 Action 的类型。</p><pre><code class="js">const initialState = &#123; count: 0 &#125;;type ACTIONTYPE =  | &#123; type: &quot;increment&quot;; payload: number &#125;  | &#123; type: &quot;decrement&quot;; payload: string &#125;;function reducer(state: typeof initialState, action: ACTIONTYPE) &#123;  switch (action.type) &#123;    case &quot;increment&quot;:      return &#123; count: state.count + action.payload &#125;;    case &quot;decrement&quot;:      return &#123; count: state.count - Number(action.payload) &#125;;    default:      throw new Error();  &#125;&#125;function Counter() &#123;  const [state, dispatch] = React.useReducer(reducer, initialState);  return (    &lt;&gt;      Count: &#123;state.count&#125;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;decrement&quot;, payload: &quot;5&quot; &#125;)&#125;&gt;        -      &lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;increment&quot;, payload: 5 &#125;)&#125;&gt;        +      &lt;/button&gt;    &lt;/&gt;  );&#125;</code></pre><p>「<code>Discriminated Unions</code>」一般是一个联合类型，其中每一个类型都需要通过类似 type 这种特定的字段来区分，当你传入特定的 type 时，剩下的类型 payload 就会自动匹配推断。</p><p>这样：</p><ul><li>当你写入的 <code>type</code> 匹配到 <code>decrement</code> 的时候，TS 会自动推断出相应的 payload 应该是 string 类型。</li><li>当你写入的 <code>type</code> 匹配到 <code>increment</code> 的时候，则 payload 应该是 number 类型。</li></ul><p>这样在你 dispatch 的时候，输入对应的 <code>type</code>，就自动提示你剩余的参数类型啦。</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>这里主要需要注意的是，<code>useEffect</code> 传入的函数，它的返回值要么是一个方法（清理函数），要么就是<code>undefined</code>，其他情况都会报错。</p><p>比较常见的一个情况是，我们的 <code>useEffect</code> 需要执行一个 <code>async</code> 函数，比如：</p><pre><code class="js">// ❌ // Type &#39;Promise&lt;void&gt;&#39; provides no match // for the signature &#39;(): void | undefined&#39;useEffect(async () =&gt; &#123;  const user = await getUser()  setUser(user)&#125;, [])</code></pre><p>虽然没有在 <code>async</code> 函数里显式的返回值，但是 <code>async</code> 函数默认会返回一个 <code>Promise</code>，这会导致 TS 的报错。</p><p>推荐这样改写：</p><pre><code class="js">useEffect(() =&gt; &#123;  const getUser = async () =&gt; &#123;    const user = await getUser()    setUser(user)  &#125;  getUser()&#125;, [])</code></pre><p>或者用自执行函数？不推荐，可读性不好。</p><pre><code class="js">useEffect(() =&gt; &#123;  (async () =&gt; &#123;    const user = await getUser()    setUser(user)  &#125;)()&#125;, [])</code></pre><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>这个 <code>Hook</code> 在很多时候是没有初始值的，这样可以声明返回对象中 <code>current</code> 属性的类型：</p><pre><code class="js">const ref2 = useRef&lt;HTMLElement&gt;(null);</code></pre><p>以一个按钮场景为例：</p><pre><code class="js">function TextInputWithFocusButton() &#123;  const inputEl = React.useRef&lt;HTMLInputElement&gt;(null);  const onButtonClick = () =&gt; &#123;    if (inputEl &amp;&amp; inputEl.current) &#123;      inputEl.current.focus();    &#125;  &#125;;  return (    &lt;&gt;      &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt;      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt;    &lt;/&gt;  );&#125;</code></pre><p>当 <code>onButtonClick</code> 事件触发时，可以肯定 <code>inputEl</code> 也是有值的，因为组件是同级别渲染的，但是还是依然要做冗余的非空判断。</p><p><strong>有一种办法可以绕过去。</strong></p><pre><code class="js">const ref1 = useRef&lt;HTMLElement&gt;(null!);</code></pre><p>null! 这种语法是非空断言，跟在一个值后面表示你断定它是有值的，所以在你使用 <code>inputEl.current.focus()</code> 的时候，TS 不会给出报错。</p><p>但是这种语法比较危险，需要尽量减少使用。</p><p>在绝大部分情况下，<code>inputEl.current?.focus()</code> 是个更安全的选择，除非这个值真的不可能为空。（比如在使用之前就赋值了）</p><h3 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h3><p>推荐使用一个自定义的 <code>innerRef</code> 来代替原生的 <code>ref</code>，否则要用到 <code>forwardRef</code> 会搞的类型很复杂。</p><pre><code class="js">type ListProps = &#123;  innerRef?: React.Ref&lt;&#123; scrollToTop(): void &#125;&gt;&#125;function List(props: ListProps) &#123;  useImperativeHandle(props.innerRef, () =&gt; (&#123;    scrollToTop() &#123; &#125;  &#125;))  return null&#125;</code></pre><p>结合刚刚 <code>useRef</code> 的知识，使用是这样的：</p><pre><code class="js">function Use() &#123;  const listRef = useRef&lt;&#123; scrollToTop(): void &#125;&gt;(null!)  useEffect(() =&gt; &#123;    listRef.current.scrollToTop()  &#125;, [])  return (    &lt;List innerRef=&#123;listRef&#125; /&gt;  )&#125;</code></pre><p>很完美，是不是？</p><p>可以在线调试 <a href="https://www.typescriptlang.org/play#code/JYWwDg9gTgLgBAKjgQwM5wEoFNkGN4BmUEIcA5FDvmQNwCwAUKJLHAN5wCuqWAyjMhhYANFx4BRAgSz5R3LNgJyeASXBYog4ADcsACWQA7ACYAbLHAC+cIiXKU8MWo0YwAnmAsAZYKhgAFYjB0AF52Rjg4YENDDUUAfgAuTCoYADpFAB4OVFxiU1MAFQhisAAKAEpk7QhgYysAPkZLFwYCTkN8YAhDOB8-MrAg1GT+gOGK8IZI+TVPTRgdfSMzLEHhtOjYqEVRSrgQhrgytgjIuFz8opKIcsmOFumrCoqzyhhOKF7DTgLm1vanUWPTgAFUePtTk9cD0-HBTL4YIoDmIFFgCNkLnkIAViqVKtVavVLA0yj8CgBCV4MM7ySTSfBlfaHKbneGIxRpXCfSiGdKXHHXfHUyKWUQAbQAutS3lgPl9jmdIpkxlEYnF0SE2Ai-IprAB6JpPamWIA">useImperativeHandle</a> 的例子。</p><h3 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h3><p>如果你想仿照 useState 的形式，返回一个数组给用户使用，一定要记得在适当的时候使用 <code>as const</code>，标记这个返回值是个常量，告诉 TS 数组里的值不会删除，改变顺序等等……</p><p>否则，你的每一项都会被推断成是「所有类型可能性的联合类型」，这会影响用户使用。</p><pre><code class="js">export function useLoading() &#123;  const [isLoading, setState] = React.useState(false);  const load = (aPromise: Promise&lt;any&gt;) =&gt; &#123;    setState(true);    return aPromise.finally(() =&gt; setState(false));  &#125;;  // ✅ 加了 as const 会推断出 [boolean, typeof load]  // ❌ 否则会是 (boolean | typeof load)[]  return [isLoading, load] as const;[]&#125;</code></pre><p>对了，如果你在用 <code>React Hook</code> 写一个库，别忘了把类型也导出给用户使用。</p><h2 id="React-API"><a href="#React-API" class="headerlink" title="React API"></a>React API</h2><h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><p>函数式组件默认不可以加 ref，它不像类组件那样有自己的实例。这个 API 一般是函数式组件用来接收父组件传来的 ref。</p><p>所以需要标注好实例类型，也就是父组件通过 ref 可以拿到什么样类型的值。</p><pre><code class="js">type Props = &#123; &#125;;export type Ref = HTMLButtonElement;export const FancyButton = React.forwardRef&lt;Ref, Props&gt;((props, ref) =&gt; (  &lt;button ref=&#123;ref&#125; className=&quot;MyClassName&quot;&gt;    &#123;props.children&#125;  &lt;/button&gt;));</code></pre><p>由于这个例子里直接把 ref 转发给 button 了，所以直接把类型标注为 <code>HTMLButtonElement</code> 即可。</p><p>父组件这样调用，就可以拿到正确类型：</p><pre><code class="js">export const App = () =&gt; &#123;  const ref = useRef&lt;HTMLButtonElement&gt;()  return (    &lt;FancyButton ref=&#123;ref&#125; /&gt;  )&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6910863689260204039&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言</summary>
      
    
    
    
    <category term="React" scheme="https://shinichikudo-fe.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://shinichikudo-fe.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>谈谈前端CodeReview,埋点和监控</title>
    <link href="https://shinichikudo-fe.github.io/2020/12/23/%E6%9D%82%E6%96%87/CodeReview-%E5%9F%8B%E7%82%B9-%E7%9B%91%E6%8E%A7/"/>
    <id>https://shinichikudo-fe.github.io/2020/12/23/%E6%9D%82%E6%96%87/CodeReview-%E5%9F%8B%E7%82%B9-%E7%9B%91%E6%8E%A7/</id>
    <published>2020-12-23T07:09:49.000Z</published>
    <updated>2020-12-23T07:54:28.370Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.cn/post/6860365929927639047">原文地址(codereview)</a><br><a href="https://juejin.cn/post/6872583452160425997">原文地址(埋点和监控)</a></p><h1 id="代码review"><a href="#代码review" class="headerlink" title="代码review"></a>代码review</h1><h2 id="现状分析和意义"><a href="#现状分析和意义" class="headerlink" title="现状分析和意义"></a>现状分析和意义</h2><p>大多数开发人员，所认知的代码review，就是把代码拿出来给别人看，大家讨论讨论，脑子里面没有特别深刻的概念。</p><p>其实代码review所涉及的东西包括：<code>review的工具、review的规范、review的流程、review的方式、甚至人员参与度、时间把控</code>等等。</p><p>代码review的意义，<strong>当然就是通过流程管理，尽可能的减少线上问题</strong>。对于TL，通过这样的过程管理，能够对项目质量把控。</p><p>当然它也有一定的<strong>缺点</strong>，增加了软件开发的流程，一定程度上降低了效率。（不过这是假设我们的项目都是高质量的，如果项目的质量本身存在问题，等到线上修复的时候，代价会大的多）</p><h2 id="一些软性的见解"><a href="#一些软性的见解" class="headerlink" title="一些软性的见解"></a>一些软性的见解</h2><ul><li>1、代码review的环境塑造</li></ul><p>代码review是一个交流的过程，如果代码写的好，那就是展示自我的平台，向大家分享优秀的实践。<br>如果代码有问题，也没有关系，发现问题，并且解决问题。<br>一般而言，TL在这个过程的态度很重要，如果TL以一个批评的口气来说谁谁谁有问题，那天然的大家会对这件事起反感。<br>如果TL能在这个过程，一直输出一些优秀的思维方式，代码架构方式，其实是给底下人传授经验的过程，大家感觉有收获，自然会喜欢review。<br>特别的要注意态度的问题，人的情绪是非常敏感的，如果团队有人说出类似“这行代码真垃圾”这样的话，TL关注的点一定不能说这个代码的问题，而是团队中的某些人的语气问题了。<br>探讨别人的代码的时候，可以说，这行代码可以怎么怎么实现，表达自己的认知就行了，不要表达特殊（不好）情绪。<br>个人反而非常喜欢赞赏别人，比如代码量多，可以说别人这段时间幸苦了。逻辑复杂，可以说这个确实耗费了不少心力之类的话。</p><ul><li>2、代码review——如何推动</li></ul><p>其实人总是不想把自己的东西暴露出来，类似我写的代码，就是我的东西的感觉。<br>在推动代码review的时候，要从两方面下手，相辅相成。</p><p><strong>一方面是价值宣导，让大家认可这件事，认可代码review的重要性，另一方面是需要一定的强制性，因为这个是团队代码质量的需要，也是公司业务稳定性的</strong>需要。</p><p>依照个人经验，价值观宣导，可以从行业内大厂的做法，以及必要性，甚至团队成员的职业发展上说明，大概率是可以让大家认可的。<br>每次遇到重大问题的时候，其实也是机会，就看我们会不会利用，假如出现线上问题，提出代码review的事情，大家应该会接受。</p><ul><li>3、代码review——不忘初心</li></ul><p>时刻谨记，我们的目的是什么。<br>不要改一行样式代码，就要进行一次review。因为这个东西本身没有什么探讨的价值。<br>一般而言，代码量超过一定量的时候，其业务复杂度，代码的设计都是可以进行探讨的。</p><h2 id="review的规范"><a href="#review的规范" class="headerlink" title="review的规范"></a>review的规范</h2><p>review的规范，应该结合团队具体的情况，举行施行。</p><p>不过还是有一些共性的东西：比如review的要点有那些？review的参与人都有那些？review的粒度是什么？</p><h3 id="review的要点"><a href="#review的要点" class="headerlink" title="review的要点"></a>review的要点</h3><ul><li><p>1、代码格式是否符合规范<br>这一部分包括lint规范、命名规范等。lint规范一般使用工具可以解决，但是命名是否规范需要我们去审查。</p></li><li><p>2、代码的可读性<br>是不是有深层的if else嵌套。<br>是不是有难以理解的函数、或者一个函数过于长。</p></li><li><p>3、边界问题<br>是不是有开发人员没有想到的异常情况，这一般是和具体的业务场景相关。</p></li><li><p>4、代码架构<br>代码的组织方式，是不是有调整的空间。是不是有可复用的代码，提取出来？</p></li></ul><h3 id="参与人员"><a href="#参与人员" class="headerlink" title="参与人员"></a>参与人员</h3><p>如果比较小的团队，比如三四个人，大家做的东西，应该都比较了解，可以全员参与<br>如果比较大型的团队，其实也是按照所熟悉的业务，分为不同的方向，相关人员可以参与reivew。<br>不过具体执行层面，需要具体问题，具体分析。</p><h3 id="review的粒度"><a href="#review的粒度" class="headerlink" title="review的粒度"></a>review的粒度</h3><p>个人认为，一些简单的改动，是不需要代码review的。<br>但是团队成员的管理上，需要一些硬性规定，那么可以把代码量超过500行，算作一个临界点。</p><h3 id="review的工具"><a href="#review的工具" class="headerlink" title="review的工具"></a>review的工具</h3><p>review是一个系统的工程，有参与的人员、有相关规范，一定也有工具。<br>个人实践上，在阿里内部，其实有类似的工具。<br>但是考虑大多数公司可能没有自己确定的工具，那么个人推荐开源工具<a href="http://www.reviewboard.org.cn/">reviewboard</a>。</p><h1 id="什么是一个埋点系统"><a href="#什么是一个埋点系统" class="headerlink" title="什么是一个埋点系统"></a>什么是一个埋点系统</h1><p><strong>埋点系统 = 埋点SDK + 埋点可视化平台 + 埋点接入方式</strong></p><p>埋点SDK，解决的问题，就是埋点的一些通用的功能的实现，比如统计用户的UV、PV等等。它在内部主要通过向埋点服务后台发送相关的数据。它对外暴露一套统一个api，方便我们接入。<br>埋点可视化平台，解决的问题，就是当我这些埋点数据被上报之后，我能看到相关的数据。比如今天的UV、PV是多少，相比昨天的环比增长是多少等等。</p><p>埋点接入方式，这是埋点系统对外开放的能力，一般会需要申请一个appid，这个appid是唯一的，然后每次上报埋点的时候，就知道是哪个项目的数据了。</p><p>更详细一点的：<br>上面的说法比较笼统，比如埋点SDK，定义的更详细一点，本质上它就是一个js文件，这个js文件是由开发商提供的，当然我们也可以做自己的埋点SDK。<br>之所以称之为SDK，还有一层原因，就是SDK基本上是不变的，就和我们开发Vue项目一样，我们需要引入vue.js文件。我们不需要知道vue.js文件怎么实现的，我们只需要知道它提供的api是什么就行。</p><p>SDK内部所做的事情，就是上报数据，所谓的上报数据，无非就是发送一个http请求接口，发送到后台服务器。然后存入数据库中。<br>埋点可视化平台，就是从数据库中，把这些数据读取出来，展示出来而已。更深层次的，无非就是做数据分析，转化率分析之类。</p><h2 id="埋点和监控是两回事"><a href="#埋点和监控是两回事" class="headerlink" title="埋点和监控是两回事"></a>埋点和监控是两回事</h2><p>好多同学把埋点和监控混为一谈，其实在大厂内部，他们完全是不一样的。</p><ul><li><strong>从功能上说:</strong></li></ul><p>监控主要是进行JS错误监控、接口异常监控、页面性能监控、资源加载异常、以及一些自定义的异常。而埋点主要做的事情是数据上报，数据统计，数据分析。</p><ul><li><strong>从使用的角度来说:</strong></li></ul><p>监控能准确的定位到错误，不需要我们在代码中添加额外的东西，只需要引入监控的SDK，就能实现错误的监控。<br>而埋点更多的是业务行为，我们在业务层面，得自己决定，自己想知道什么数据，想要怎么埋点，然后再做什么样的分析，所以我们接入埋点SDK之后，还需要调用埋点的api进行数据上报。</p><p>所以一定要明确，埋点和监控是两回事。</p><h2 id="埋点和监控的实现是有差异的"><a href="#埋点和监控的实现是有差异的" class="headerlink" title="埋点和监控的实现是有差异的"></a>埋点和监控的实现是有差异的</h2><p>这里所说的实现，是<strong>指这个相关的SDK的实现原理</strong>。</p><ul><li><strong>埋点的实现原理是什么？</strong></li></ul><p>埋点的本质是数据上报，那一定离不开这么一些纬度的数据：地理位置、页面路径、浏览器信息、userId、时间戳等等。类似这样的信息，在用户上报的时候，应该都是自动携带的。<br>一些上报的数据，可能会和业务相关，提供的埋点api中，加一条类似业务标识的ID，让相关数据关联起来。</p><ul><li><strong>监控的实现原理是什么？</strong></li></ul><p>其实无非在SDK内部，实现几种异常监控。</p><p>JS错误，可以使用<code>window.onerror</code>的方式监控。</p><p>接口异常，现在的请求一般是<code>fetch或者是ajax请求</code>，我们只需要把他们包装一层，在相应的响应事件中，获取我们的信息，如果返回的不是200的请求，直接上报错误。</p><p>页面性能，主要通过浏览器提供的一个对象来实现，<code>Performance相关的api</code>，它记录了浏览器加载、解析资源的时间占用情况。</p><p>资源加载错误，最简单的方式，可以通过<code>onerror</code>事件来实现。script可以用，img标签都可以用。<br>这些表述，比较笼统，比如js错误里面，关于promise、关于vue的错误，在错误捕获上都需要做补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6860365929927639047&quot;&gt;原文地址(codereview)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="杂文" scheme="https://shinichikudo-fe.github.io/categories/%E6%9D%82%E6%96%87/"/>
    
    
    <category term="CodeReview" scheme="https://shinichikudo-fe.github.io/tags/CodeReview/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL vs Restful Api</title>
    <link href="https://shinichikudo-fe.github.io/2020/11/18/GraphQL/GraphQL-vs-Restful-Api/"/>
    <id>https://shinichikudo-fe.github.io/2020/11/18/GraphQL/GraphQL-vs-Restful-Api/</id>
    <published>2020-11-18T09:07:34.000Z</published>
    <updated>2020-11-19T03:50:42.329Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://cloud.tencent.com/developer/news/572892">原文地址</a></p><h2 id="与传统-REST-API-相比，GraphQL-提供了哪些优势？"><a href="#与传统-REST-API-相比，GraphQL-提供了哪些优势？" class="headerlink" title="与传统 REST API 相比，GraphQL 提供了哪些优势？"></a>与传统 REST API 相比，GraphQL 提供了哪些优势？</h2><p>我们将讨论 GraphQL 的设计原则，比较 GraphQL 与 REST 中的相同请求，并深入探讨 GraphQL 相对其他架构的优点。</p><p>为理解 GraphQL 作为 API 架构的好处，我们要讨论 API 在<code>客户端 - 服务器</code>结构中的作用。<strong>API（应用程序编程接口）是一个中间层，它允许服务器从客户端接收结构化数据请求，并针对请求的数据发送结构化的响应</strong>。设计 API 架构的方法有很多种。</p><p>让我们来研究一下促使 GraphQL 适合现代化 Web 应用程序的重要基本设计原则。</p><h2 id="GraphQL-服务器的设计原则"><a href="#GraphQL-服务器的设计原则" class="headerlink" title="GraphQL 服务器的设计原则"></a>GraphQL 服务器的设计原则</h2><p> 1.<strong>查询为分层结构</strong>，使用将查询与响应数据1对1匹配的分层和嵌套字段格式。查询和响应的形状类似于树，可查询每个项的其他嵌套字段。在 Facebook 的新闻推送中，这种结构允许一个查询返回一个帖子列表、每个特定帖子的评论，以及每个评论的点赞。</p><p> 2.<strong>该结构以产品为中心，关注前端希望如何接收数据，并构建交付所需的运行时</strong>。这使得 Facebook 的新闻推送可通过一次请求从后端获取需要的所有数据，使服务器按照 GraphQL 的规范从不同的端点获取数据。</p><p> 3.<strong>它使用特定于应用程序的类型系统，该系统使开发人员能在执行前确保查询使用了有效类型，并且语法正确</strong>。例如，新闻推送的 GraphQL 模式要求字段“<code>user</code>”必须包含一个字符串，而“<code>likes</code>”必须包含一个数字。如果查询试图添加不同类型的输入，GraphQL 将在执行查询前抛出一个错误。</p><p> 4.<strong>GraphQL 查询是在客户端指定的，因此，客户端确切知道它将以何种格式接收数据</strong>。这意味着，如果前端请求的格式是包含用户名、评论和点赞的 post 数据，那么来自 Facebook 新闻推送的请求会构建在一个对象中，而不是像其他架构那样构建多个单独的数据块。</p><p> 5.<strong>使用 GraphQL 的服务器结构必须是内省的，或者可由 GraphQL 自己查询</strong>。于是才有了像 <a href="https://github.com/graphql/graphiql">GraphiQL</a> 或 <a href="https://www.apollographql.com/docs/apollo-server/testing/graphql-playground/">GraphQL playground</a> 这样的强大工具。这两种工具都可以让 Facebook 开发人员准确地看到在他们的服务器上使用了哪些查询和字段。</p><h2 id="传统的-RESTful-架构"><a href="#传统的-RESTful-架构" class="headerlink" title="传统的 RESTful 架构"></a>传统的 RESTful 架构</h2><p>REST 架构的设计范式侧重于分配 HTTP 请求方法（<code>GET、POST、PUT、PATCH、DELETE</code>）和 URL 端点之间的关系。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-7350649/gmtfcrky41.png?imageView2/2/w/1620" alt="restful"></p><p><strong>在 REST 架构中，方法和端点的每个组合得到不同的封装功能</strong>。如果客户端需要的数据特定端点 / 方法不提供，则可能需要额外请求。从 REST 请求返回的数据格式依赖于端点—不能保证这些数据会按照前端需要的方式进行格式化。为使用来自响应的数据（格式与缺省情况下从端点返回的格式不同），必须在客户端编写数据解析和数据操作。</p><p>接下来，让我们看看 GraphQL 规范与 REST 的不同之处，以及它的优点。这些优点使这个新架构成为特别适合解决客户端和服务器之间数据交付问题的解决方案。</p><h2 id="GraphQL-架构"><a href="#GraphQL-架构" class="headerlink" title="GraphQL 架构"></a>GraphQL 架构</h2><p>与 RESTful API 一样，GraphQL API 设计用于处理 HTTP 请求并对这些请求提供响应。无论如何，这就是相似之处。**REST API 构建在请求方法和端点之间的连接上，而 GraphQL API 被设计为只通过一个端点，始终使用 POST 请求进行查询，其 URL 通常是 <code>yourdomain.com/graphql</code>**。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-7350649/yvuf86kzg2.jpeg?imageView2/2/w/1620" alt="graphql"></p><p>请求到达 GraphQL 端点后，客户端请求的载荷完全在请求体中处理。这个请求体必须遵循 GraphQL 规范，API 必须<strong>有适当的服务器端逻辑来处理这些请求并提供适当的响应</strong>。</p><p>这提供了比 RESTful API 更流畅的客户端体验，后者可能要求客户端针对多个数据块发出多个请求，并在数据返回后进行操作。</p><p>为了阐明 GraphQL 是如何实现这一点的，让我们分解一下 GraphQL 服务器的结构。</p><h2 id="GraphQL-服务器"><a href="#GraphQL-服务器" class="headerlink" title="GraphQL 服务器"></a>GraphQL 服务器</h2><p>启用 GraphQL 逻辑的服务器端逻辑由定义了服务器功能的 <code>Documents</code> 组成。这些 <code>Documents</code> 包含可执行文件和类型系统定义。顾名思义，类型系统定义为每个数据字段定义可接受的类型和格式输入及结果。</p><p>可执行文件包含要处理的可能的操作列表，其中包括操作类型（查询、修改或订阅）、操作名称、要查询或写入的字段和一个选择集，该选择集准确定义了将从操作返回的数据。选择集是 GraphQL 的最大价值所在——它们允许客户端查询特定的数据集并接收包含所请求信息的响应：不多不少。</p><p>有关 GraphQL 规范的结构和语法的更多信息，请参阅 <a href="http://spec.graphql.org/June2018/#sec-Overview">GraphQL 的文档</a>。</p><p>接下来，我们将看下 GraphQL 中查询的结构。</p><h2 id="GraphQL-查询解析"><a href="#GraphQL-查询解析" class="headerlink" title="GraphQL 查询解析"></a>GraphQL 查询解析</h2><p>下面是一个结构化的 GraphQL 查询，用于获取特定书籍的数据，包括作者的姓和名。</p><pre><code class="js">GET /graphql?query=&#123; books(id:12) &#123; authors &#123; firstName, lastName &#125; title, yearPublished, length &#125; &#123;   Query &#123;                 //  operation type  books (id:12) &#123;         //  operation endpoint     authors &#123;            //  requested fields        firstName        lastName     &#125;      title     yearPublished        &#125;  &#125;&#125;</code></pre><p>这一切都可以通过一个查询由 GraphQL 服务器逻辑解析和处理完成。当把它与 REST 架构中相同结构的请求进行比较时，GraphQL 的优势就开始显现出来了。</p><p>让我们看看下面的 REST 请求结构，然后重点讨论其中的一些差异！</p><h2 id="REST-请求解析"><a href="#REST-请求解析" class="headerlink" title="REST 请求解析"></a>REST 请求解析</h2><p>要向 REST API 发出相同的请求，客户端首先需要向能够返回图书数据的端点发送一个请求，并将图书 id 作为参数传入：</p><pre><code class="js">GET /books/12</code></pre><p>这个请求可能会返回一个包含特定图书所有数据的对象，例如：</p><pre><code class="js">&#123;   “title” : “The Hitchhiker&#39;s Guide to the Galaxy”,  “authorID”: 42,  “yearPublished” : 1978,  “length”: 208,  “genre”: “Science Fiction”&#125;</code></pre><p>在我们的例子里，与相同的 GraphQL 查询相比，该响应有两个缺点：</p><ul><li>1.REST 响应包含类似 genre 这样的额外数据，返回的信息超出了我们的需求。</li><li>2.REST 需要再发送一个请求来获得我们实际上正在查找的数据：这个特定作者的所有书籍。</li></ul><p>为了获得这些数据，我们需要使用我们的 <code>authorID</code> 发出一个额外的请求：</p><pre><code class="js">GET /authors/42</code></pre><p>这个请求的响应应该包含我们正在查找的所有数据：</p><pre><code class="js">&#123;   “firstName” : “Douglas”,  “lastName”: “Adams”&#125;</code></pre><p>现在我们已经有了需要的所有书籍和作者数据，响应解析由客户端完成。现在，前端应用程序必须将来自不同端点的数据组合在一起，用于实现期望的功能。总的来说，与 REST API 相比，GraphQL 提供的性能优势可以为前端开发人员带来回报。使用 GraphQL 规范创建服务器可能需要更多的设置以及编写预测性的服务器端逻辑来解析和处理请求。</p><p>虽然 GraphQL 的设置成本可能比传统的 REST 架构要高，但是，更易于维护的代码、健壮的开发工具和精简的客户端查询所带来的好处通常会超过成本。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相同： 都拥有资源这个概念，而且都可以指定资源的身份<br>相同： 都能通过 HTTP GET 和一个 URL 来获取信息<br>相同： 请求的返回值都是 JSON 数据<br>不同： 在 REST 中，你所访问的终端就是所需对象的身份，在 GraphQL 中，对象的身份和获取的方式是独立存在的<br>不同： 在 REST 中，资源的形式和大小是由服务器所决定的。在 GraphQL 中，服务器声明哪些资源可以获得，而客户端会对其所需资源作出请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/news/572892&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;与传统-REST-AP</summary>
      
    
    
    
    <category term="GraphQL" scheme="https://shinichikudo-fe.github.io/categories/GraphQL/"/>
    
    
    <category term="GraphQL" scheme="https://shinichikudo-fe.github.io/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL 基础实践</title>
    <link href="https://shinichikudo-fe.github.io/2020/11/11/GraphQL/GraphQL%20%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/"/>
    <id>https://shinichikudo-fe.github.io/2020/11/11/GraphQL/GraphQL%20%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-11-11T05:18:03.000Z</published>
    <updated>2020-11-11T08:07:34.956Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.im/post/6844903641996869645#heading-19">原文地址</a></p><p><a href="https://ppt.baomitu.com/d/4248c64a#/1">PPT讲解地址</a></p><h1 id="什么是GraphQL"><a href="#什么是GraphQL" class="headerlink" title="什么是GraphQL"></a>什么是GraphQL</h1><p><code>GraphQL</code> 是一款由 Facebook 主导开发的数据查询和操作语言， 写过 SQL 查询的同学可以把它想象成是 SQL 查询语言，但 <code>GraphQL</code> 是给客户端查询数据用的。虽然这让你听起来觉得像是一款数据库软件，但实际上 <code>GraphQL</code> 并不是数据库软件。<strong>你可以将 <code>GraphQL</code> 理解成一个中间件，是连接客户端和数据库之间的一座桥梁，客户端给它一个描述，然后从数据库中组合出符合这段描述的数据返回</strong>。这也意味着 <code>GraphQL</code> 并不关心数据存在什么数据库上。</p><p>同时 GraphQL 也是一套标准，在这个标准下不同平台不同语言有相应的实现。GraphQL 中还设计了一套类型系统，在这个类型系统的约束下，可以获得与 <code>TypeScript</code> 相近的相对安全的开发体验。</p><h2 id="GraphQL-解决了什么问题"><a href="#GraphQL-解决了什么问题" class="headerlink" title="GraphQL 解决了什么问题"></a>GraphQL 解决了什么问题</h2><p>我们先来回顾一下我们已经非常熟悉的 RESTful API 设计。简单的说 RESTful API 主要是使用 URL 的方式表达和定位资源，用 HTTP 动词来描述对这个资源的操作。</p><p>我们以 IMDB 电影信息详情页为例子，看看我们得需要什么样的 API 才能满足 RESTful API 设计的要求。先来看看主页面上都需要什么信息。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzuD8b0MhgbohicKNzDDHlXNjCdTl00r1vryK0nicEnnlHWN5o1ibteyjRQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="imdb demo"></p><p>可以看到页面上由<em>电影基本信息，演员和评分/评论信息组成</em>，按照设计要求，我们需要将这三种资源放在不同 API 之下。首先是电影基本信息，我们有 API <code>/movie/:id</code>，给定一个电影ID返回基本信息数据。</p><p>假装 GET 一下获得一个 JSON 格式的数据：</p><pre><code class="js">&#123;  name: “Manchester by the Sea”,  ratings: “PG-13”,  score: 8.2,  release: “2016”,  actors:[“https://api/movie/1/actor/1/”],  reviews:[“https://api/movie/1/reviews”]&#125;</code></pre><p>这里面包含了我们所需的电影名、分级等信息，以及一种叫做 <code>HyperMedia</code> 的数据，通常是一个 URL，指明了能够获取这个资源的 API 端点地址。如果我们跟着 <code>HyperMedia</code> 指向的连接请求下去，我们就能得到我们页面上所需的所有信息。</p><p><code>GET /api/movue/1/actor/1</code></p><pre><code class="js">&#123;  name: “Ben Affleck”,  dob: “1971-01-26”,  desc: “blablabla”,  movies:[“https://api/movie/1”]&#125;</code></pre><p><code>GET /api/movie/1/reviews</code></p><pre><code class="js">[  &#123;     content: “Its’s as good as…”,     score: 9  &#125;]</code></pre><p>最后根据需要，我们要将所有包含需要信息的 API 端点都请求一遍，<strong>对于移动端来说，发起一个 HTTP 请求还是比较消耗资源的</strong>，特别是在一些网络连接质量不佳的情况下，一下发出多个请求反而会导致不好的体验。</p><p>而且在这样的 API 设计之中，特定资源分布在特定的 API 端点之中，对于后端来说写起来是挺方便的，但对于Web端或者客户端来说并不一定。例如在 Android 或 iOS 客户端上，发版升级了一个很爆炸的功能，同一个API上可能为了支持这个功能而多吐一些数据。但是对于未升级的客户端来说，这些新数据是没有意义的，也造成了一定的资源浪费。如果单单将所有资源整合到一个 API 之中，还有可能会因为整合了无关的数据而导致数据量的增加。</p><p>而 <code>GraphQL</code> 就是为了解决这些问题而来的，<strong>向服务端发送一次描述信息，告知客户端所需的所有数据，数据的控制甚至可以精细到字段</strong>，达到一次请求获取所有所需数据的目的。</p><h2 id="GraphQL-Hello-World"><a href="#GraphQL-Hello-World" class="headerlink" title="GraphQL Hello World"></a>GraphQL Hello World</h2><h3 id="GraphQL-请求体"><a href="#GraphQL-请求体" class="headerlink" title="GraphQL 请求体"></a>GraphQL 请求体</h3><p>我们先来看一下一个 GraphQL 请求长什么样：</p><pre><code class="js">query myQry ($name: String!) &#123;  movie(name: “Manchester”) &#123;    name    desc    ratings  &#125;&#125;</code></pre><p>那么，上面的这个请求描述称为一个 <code>GraphQL</code> 请求体，请求体即用来描述你要从服务器上取什么数据用的。一般请求体由几个部分组成，从里到外了解一下。</p><p>首先是字段，字段请求的是一个数据单元。同时在 <code>GraphQL</code> 中，标量字段是粒度最细的一个数据单元了，同时作为返回 JSON 响应数据中的最后一个字段。也就是说，如果是一个 Object，还必须选择至少其中的一个字段。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzViawDHFfDRibXSlV3o9tLpPTWK9OU42F887H8AIREaAbnj0DUibsQ6dSA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="字段"></p><p>把我们所需要的字段合在一起，我们把它称之为某某的选择集。上面的 <code>name、desc、ratings</code> 合在一起则称之为 <code>movie</code> <code>的选择集，同理，movie</code> 是 <code>myQry</code> 的选择集。需要注意的是，在标量上不能使用选择集这种操作，因为它已经是最后一层了。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzhKXezDO26xBpnuyiaX1LP2ich5JvESXXBXJqibg5jc2ckQgjIv7luy8KQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="选择集"></p><p>在 <code>movie</code> 的旁边，<code>name: &quot;Manchester&quot;</code>，这个代表着传入 <code>movie</code> 的参数，参数名为 <code>name</code> 值为<code>Manchester</code>，利用这些参数向服务器表达你所需的数据需要符合什么条件。</p><p>最后我们来到请求体的最外层：</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdz4daRBcWjtx0slTOtNUtkwvyZFEafEqvzyic2CvwGp8qKvJcZ5Bws7Jg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="最外层"></p><ul><li><p><code>操作类型</code>：指定本请求体要对数据做什么操作，类似与 <code>REST</code> 中的 <code>GET POST</code>。<code>GraphQL</code> 中基本操作类型有 <code>query 表示查询，mutation 表示对数据进行操作</code>，例如增删改操作，<code>subscription 订阅操作</code>。</p></li><li><p><code>操作名称</code>：操作名称是个可选的参数，操作名称对整个请求并不产生影响，只是赋予请求体一个名字，可以作为调试的依据。</p></li><li><p><code>变量定义</code>：在 <code>GraphQL</code> 中，声明一个变量使用<code>$</code>符号开头，冒号后面紧跟着变量的传入类型。如果要使用变量，直接引用即可，例如上面的 <code>movie</code> 就可以改写成 <code>movie(name: $name)</code>。</p></li></ul><p>如果上述三者都没有提供，那么这个请求体默认会被视为一个 query 操作。</p><h3 id="请求的结果"><a href="#请求的结果" class="headerlink" title="请求的结果"></a>请求的结果</h3><p>如果我们执行上面的请求体，我们将会得到如下的数据：</p><pre><code class="js">&#123;  &quot;data&quot;: &#123;    &quot;movie&quot;: &#123;      &quot;name&quot;: &quot;Manchester By the Sea&quot;,      &quot;desc&quot;: &quot;A depressed uncle is asked to take care of his teenage nephew after the boy&#39;s father dies. &quot;,      &quot;ratings&quot;: &quot;R&quot;    &#125;  &#125;&#125;</code></pre><p>仔细对比结果和请求体的结构，你会发现，与请求体的结构是完全一致的。也就是说，<strong>请求体的结构也确定了最终返回数据的结构</strong>。</p><h3 id="GraphQL-Server"><a href="#GraphQL-Server" class="headerlink" title="GraphQL Server"></a>GraphQL Server</h3><p>在前面的 <code>REST</code> 举例中，我们请求多个资源有多个 API 端点。在 GraphQL 中，只有一个 API 端点，同样也接受 <code>GET</code> 和 <code>POST</code> 动词，如要操作 <code>mutation</code> 则使用 <code>POST</code> 请求。</p><p>前面还提到 <code>GraphQL</code> 是一套标准，怎么用呢，我们可以借助一些库去解析。例如 Facebook 官方的 <code>GraphQL.js</code>。以及 Meteor 团队开发的 <code>Apollo</code>，同时开发了客户端和服务端，同时也支持流行的 Vue 和 React 框架。调试方面，可以使用 <code>Graphiql</code> 进行调试，得益于 <code>GraphQL</code> 的类型系统和 <code>Schema</code>，我们还可以在 <code>Graphiql</code> 调试中使用自动完成功能。</p><h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><p>前面我们提到，<code>GraphQL</code> 拥有一个类型系统，那么每个字段的类型是怎么约定的呢？答案就在本小节中。在 <code>GraphQL</code> 中，<strong>类型的定义以及查询本身都是通过 <code>Schema</code> 去定义的</strong>。<code>GraphQL</code> 的 <code>Schema</code> 语言全称叫 <code>Schema Definition Language</code>。<code>Schema</code> 本身并不代表你数据库中真实的数据结构，它的定义决定了<strong>这整个端点能干些什么事情，确定了我们能向端点要什么，操作什么</strong>。再次回顾一下前面的请求体，请求体决定了返回数据的结构，而 <code>Schema</code> 的定义决定了端点的能力。</p><p>接下来我们就通过一个一个的例子了解一下 <code>Schema</code>。</p><h3 id="类型系统、标量类型、非空类型、参数"><a href="#类型系统、标量类型、非空类型、参数" class="headerlink" title="类型系统、标量类型、非空类型、参数"></a>类型系统、标量类型、非空类型、参数</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzibIm98cIybzWGqaEHhRI4mCY0icrkn9DnwnK2MKruYib1LCWnib0jjJD1A/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="schema"></p><p>先看右边的 <code>Schema</code>：<code>type</code> 是 GraphQL <code>Schema</code> 中最基本的一个概念，表示一个 GraphQL 对象类型，可以简单地将其理解为 JavaScript 中的一个对象，在 JavaScript 中一个对象可以包含各种 key，在 GraphQL 中，<code>type</code> 里面同样可以包含各种字段（field）,而且字段类型不仅仅可以是标量类型，还可以是 <code>Schema</code> 中定义的其他 <code>type</code>。例如上面的 <code>Schema</code> 中， Query 下的 movie 字段的类型就可以是 Movie。</p><p>在 GraphQL 中，有如下几种标量类型：<code>Int, Float, String, Boolean, ID</code> ，分别表示<code>整型、浮点型、字符串、布尔型以及一个ID类型</code>。ID类型<strong>代表着一个独一无二的标识，ID 类型最终会被转化成String类型，但它必须是独一无二的</strong>，例如 mongodb 中的 _id 字段就可以设置为ID类型。同时这些标量类型可以理解为 JavaScript 中的原始类型，上面的标量类型同样可以对应 JavaScript 中的 <code>Number, Number, String, Boolean, Symbol</code> 。</p><p>通过上面的类型定义，可以看到 <code>GraphQL</code> 中的类型系统起到了很重要的角色。在本例中，Schema 定义了 name 为 String类型，那么你就不能传 Int类型进去，此时会抛出类型不符的错误。同样的，如果传出的 <code>ratings</code> 数据类型不为 <code>String</code>，也同样会抛出类型不符的错误。</p><h3 id="列表（List）、枚举类型（Enum）"><a href="#列表（List）、枚举类型（Enum）" class="headerlink" title="列表（List）、枚举类型（Enum）"></a>列表（List）、枚举类型（Enum）</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzVM5h5I7ibtMbRh9HMGqVAeLfqHUSbArCBYaHUWdET4QfeONw0kO0aeg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><p>如果我们的某个字段返回不止一个标量类型的数据，而是一组，则需要使用List类型声明，在该标量类型两边使用中括号<code>[]</code>包围即可，与 JavaScript 中数组的写法相同，而且返回的数据也将会是数组类型。</p><p>需要注意的是<code>[Movie]!</code>与 <code>[Movie!]</code>两种写法的含义是不同的：<strong>前者表示 <code>movies</code>字段始终返回不可为空但Movie元素可以为空</strong>。<strong>后者表示<code>movies</code>中返回的 Movie 元素不能为空，但 <code>movies</code>字段的返回是可以为空的</strong>。</p><p>你可能在请求体中注意到，<code>genre</code> 参数的值没有被双引号括起来，也不是任何内置类型。看到 <code>Schema</code> 定义，COMEDY是枚举类型MovieTypes中的枚举成员。枚举类型用于声明一组取值常量列表，如果声明了某个参数为某个枚举类型，那么该参数只能传入该枚举类型内限定的常量名。</p><h3 id="传入复杂结构的参数（Input）"><a href="#传入复杂结构的参数（Input）" class="headerlink" title="传入复杂结构的参数（Input）"></a>传入复杂结构的参数（Input）</h3><p>前面的例子中，传入的参数均为标量类型，那么如果我们想传入一个拥有复杂结构的数据该怎么定义呢。答案是使用<strong>关键字input</strong>。其使用方法和type完全一致。</p><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdz7tz9DrrcqantibfXNo5Z2NZ3ymRE51y16Teeawibf5kjuE81HiaqLDibeQ/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="input"></p><p>根据本例中的 <code>Schema</code> 定义，我们在查询 search时data的参数必须为</p><pre><code class="js">&#123; term: &quot;Deepwater Horizon&quot; &#125;</code></pre><h3 id="别名（Alias）"><a href="#别名（Alias）" class="headerlink" title="别名（Alias）"></a>别名（Alias）</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdz87vwwe8S2CXvu20MPo6UzrDhY1gW3A87xRbicPW7f5DDibLvecSAyK1A/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="alias"></p><p>想象这么一个页面，我要列出两个电影的信息做对比，为了发挥 <code>GraphQL</code> 的优势，我要同时查询这两部电影的信息，在请求体中请求 <code>movie</code> 数据。前面我们说到，请求体决定了返回数据的结构。在数据返回前查出两个 key 为 <code>movie</code> 的数据，合并之后由于 key 重复而只能拿到一条数据。那么在这种情况下我们需要使用别名功能。</p><p>别名即为返回字段使用另一个名字，使用方法也很简单，只需要在请求体的字段前面使用别名<code>:</code>的形式即可，返回的数据将会自动替换为该名称。</p><h3 id="片段（Fragment）、片段解构（Fragment-Spread）"><a href="#片段（Fragment）、片段解构（Fragment-Spread）" class="headerlink" title="片段（Fragment）、片段解构（Fragment Spread）"></a>片段（Fragment）、片段解构（Fragment Spread）</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdz4duFiaoiaB7n6rSXibEqibDwFAaKibGUc2VUm4JkYVCSmqDibdNia4KaZweWA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="片段"></p><p>在上面的例子中，我们需要对比两部电影的数据。如果换作是硬件对比网站，需要查询的硬件数量往往不止两个。此时编写冗余的选择集显得非常的费劲、臃肿以及难维护。为了解决这个问题，我们可以使用片段功能。**<code>GraphQL</code> 允许定义一段公用的选择集，叫片段**。定义片段使用 <code>fragment name on Type</code> 的语法，其中 name为自定义的片段名称，Type为片段来自的类型。</p><p>本例中的请求体的选择集公共部分提取成片段之后为</p><pre><code class="js">fragment movieInfo on Movie &#123;   name   desc&#125;</code></pre><p>在正式使用片段之前，还需要向各位介绍<code>片段解构功能</code>。类似于 JavaScript 的结构。<strong>GraphQL 的片段结构符号将片段内的字段“结构”到选择集中</strong>。</p><p><img src="https://mmbiz.qlogo.cn/mmbiz/MpGQUHiaib4ib5EjuicgHA4YxH7DOsVHGbdzvOpicOCfiajJPfWgs5LFr4Ujym34VqhZwicMITEOIGiamdNicr1DvbQhNcg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1&retryload=2" alt="片段解构"></p><h3 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h3><p>与其他大多数语言一样，<code>GraphQL</code> 也提供了定义接口的功能。接口指的是 <code>GraphQL</code> 实体类型本身提供字段的集合，定义一组与外部沟通的方式。使用了 <code>implements</code>的类型必须包含接口中定义的字段。</p><pre><code class="js">interface Basic &#123;    name: String!    year: Number!&#125;type Song implements Basic &#123;    name: String!    year: Number!    artist: [String]!&#125;type Video implements Basic &#123;    name: String!    year: Number!    performers: [String]!&#125;Query &#123;    search(term: String!): [Basic]!&#125;</code></pre><p>在本例中，定义了一个<code>Basic</code>接口，<code>Song</code>以及<code>Video</code>类型都要实现该接口的字段。然后在search查询中返回该接口。</p><p><code>searchMedia</code>查询返回一组<code>Basic</code>接口。由于该接口中的字段是所有实现了该接口的类型所共有的，在请求体上可以直接使用。而对于特定类型上的其他非共有字段，例如<code>Video</code>中的performers，直接选取是会有问题的，因为<code>searchMedia</code>在返回的数据中类型可能是所有实现了该接口的类型，而在 <code>Song</code>类型中就没有performers字段。此时我们可以借助内联片段的帮助（下面介绍）</p><h3 id="联合类型（Union）"><a href="#联合类型（Union）" class="headerlink" title="联合类型（Union）"></a>联合类型（Union）</h3><p>联合类型与接口概念差不多相同，不同之处在于联合类型下的类型之间没有定义公共的字段。在 <code>Union</code> 类型中必须使用内联片段的方式查询，原因与上面的接口类型一致。</p><pre><code class="js">union SearchResult = Song | VideoQuery &#123;  search(term: String!): [SearchResult]!&#125;</code></pre><h3 id="内联片段（Inline-Fragment）"><a href="#内联片段（Inline-Fragment）" class="headerlink" title="内联片段（Inline Fragment）"></a>内联片段（Inline Fragment）</h3><p>对接口或联合类型进行查询时，由于返回类型的不同导致选取的字段可能不同，此时需要通过内联片段的方式决定在特定类型下使用特定的选择集。内联选择集的概念和用法与普通片段基本相同，不同的是<strong>内联片段直接声明在选择集内，并且不需要fragment声明</strong>。</p><p>查询接口的例子：</p><pre><code class="js">query &#123;  searchMedia(term: &quot;AJR&quot;) &#123;    name    year    ...on Song &#123;        artist    &#125;    ...on Video &#123;        performers    &#125;  &#125;&#125;</code></pre><p>首选我们需要该接口上的两个公共字段，并且结果为Song类型时选取artist字段，结果为Video类型时选取performers字段</p><h3 id="GraphQL-内置指令"><a href="#GraphQL-内置指令" class="headerlink" title="GraphQL 内置指令"></a>GraphQL 内置指令</h3><p>GraphQL 中内置了两款逻辑指令，指令跟在字段名后使用。</p><h4 id="include"><a href="#include" class="headerlink" title="@include"></a>@include</h4><p>当条件成立时，查询此字段</p><pre><code class="js">query &#123;    search &#123;        actors @include(if: $queryActor) &#123;            name        &#125;    &#125;&#125;</code></pre><h4 id="skip"><a href="#skip" class="headerlink" title="@skip"></a>@skip</h4><p>当条件成立时，不查询此字段</p><pre><code class="js">query &#123;  search &#123;    comments @skip(if: $noComments) &#123;      from    &#125;  &#125;&#125;</code></pre><h2 id="Resolvers"><a href="#Resolvers" class="headerlink" title="Resolvers"></a>Resolvers</h2><p>前面我们已经了解了请求体以及 Schema，那么我们的数据到底怎么来呢？答案是来自 <code>Resolver</code> 函数。</p><p><code>Resolver</code> 的概念非常简单。<code>Resolver</code> 对应着 Schema 上的字段，当请求体查询某个字段时，对应的 <code>Resolver</code> 函数会被执行，由 <code>Resolver</code> 函数负责到数据库中取得数据并返回，最终将请求体中指定的字段返回。</p><pre><code class="js">type Movie &#123;    name    genre&#125;type Query &#123;    movie: Movie!&#125;</code></pre><p>当请求体查询movie时，同名的 <code>Resolver</code> 必须返回Movie类型的数据。当然你还可以单独为name字段使用独立的 <code>Resolver</code> 进行解析。后面的代码例子中将会清楚地了解 <code>Resolver</code></p><h2 id="GraphQL-的优缺点"><a href="#GraphQL-的优缺点" class="headerlink" title="GraphQL 的优缺点"></a>GraphQL 的优缺点</h2><blockquote><p>优点</p></blockquote><ul><li>所见即所得：所写请求体即为最终数据结构</li><li>减少网络请求：复杂数据的获取也可以一次请求完成</li><li>Schema 即文档：定义的 Schema 也规定了请求的规则</li><li>类型检查：严格的类型检查能够消除一定的认为失误</li></ul><blockquote><p>缺点</p></blockquote><ul><li>增加了服务端实现的复杂度：一些业务可能无法迁移使用 GraphQL，虽然可以使用<code>中间件的方式</code>将原业务的请求进行代理，这无疑也将增加复杂度和资源的消耗</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903641996869645#heading-19&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="GraphQL " scheme="https://shinichikudo-fe.github.io/categories/GraphQL/"/>
    
    
    <category term="GraphQL " scheme="https://shinichikudo-fe.github.io/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>Typescript基础及问题汇总</title>
    <link href="https://shinichikudo-fe.github.io/2020/11/02/Ts/Typescript%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://shinichikudo-fe.github.io/2020/11/02/Ts/Typescript%E5%9F%BA%E7%A1%80%E5%8F%8A%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2020-11-02T02:18:00.000Z</published>
    <updated>2020-11-02T11:33:24.069Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="是否可以将多个js文件合并为1个ts文件？如果是怎么做？"><a href="#是否可以将多个js文件合并为1个ts文件？如果是怎么做？" class="headerlink" title="是否可以将多个js文件合并为1个ts文件？如果是怎么做？"></a>是否可以将多个js文件合并为1个ts文件？如果是怎么做？</h2><p>可以合并为一个文件，为此我们需要添加–outFile[OutputJSFileName]编译选项</p><pre><code class="js">$tsc --outFile common.js file1.ts file2.js file3.js</code></pre><p>上述命令将三个文件合并到common.js文件中</p><h2 id="ts的基础类型都有哪些？与js有哪些区别？"><a href="#ts的基础类型都有哪些？与js有哪些区别？" class="headerlink" title="ts的基础类型都有哪些？与js有哪些区别？"></a>ts的基础类型都有哪些？与js有哪些区别？</h2><p>ts必须指定数据类型，可以分为3种：</p><ul><li>1.js有的类型</li></ul><p>blooean类型，number类型，string类型，null类型，undefined,数组类型</p><ul><li>2.ts特有的类型</li></ul><p>tuple类型（元组类型），emnu类型（枚举类型），any类型（任意类型）</p><ul><li>3.特别的类型</li></ul><p>void类型（没有任何类型）表示定义方法没有返回值</p><p>never类型：是undefind,null的子类型，表示从不会出现的值，这意味着声明never变量只能被never类型所赋值</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>1.定义数组的方式</p><pre><code class="ts">let arr1:number[] = [1,2,3,4,5]let arr2:Array[number] = [1,2,3,4,5]let arr3:[number,string] = [1,2,3,4,5]</code></pre><p>2.定义emnu枚举类型方法</p><pre><code class="ts">emnu flag&#123;success=1,error=2&#125;let s:flag = flag.successconsole.log(s)</code></pre><p>3.定义any任意类型方法</p><pre><code class="ts">let num1:any:truenum1 = true</code></pre><p>4.undefined类型</p><pre><code class="ts">let num2 =  number | undefinedconsole.log(num2)</code></pre><p>5.vold类型，函数没有返回值</p><pre><code class="ts">function run():void &#123;  console.log(&#39;run&#39;)&#125;</code></pre><p>6.never类型定义方法</p><pre><code class="ts">let c:never;c = (()=&gt;&#123;  throw new Error(&#39;error&#39;)&#125;)</code></pre><h2 id="ts为什么会流行？与ECMA新规范的关系？"><a href="#ts为什么会流行？与ECMA新规范的关系？" class="headerlink" title="ts为什么会流行？与ECMA新规范的关系？"></a>ts为什么会流行？与ECMA新规范的关系？</h2><ul><li>TypeScript快速、简单，最重要的是，容易学习。</li><li>TypeScript支持面向对象的编程特性，比如类、接口、继承、泛型等等。</li><li>TypeScript在编译时提供了错误检查功能。它将编译代码，如果发现任何错误，它将在运行脚本之前突出显示这些错误。</li><li>TypeScript支持所有JavaScript库，因为它是JavaScript的超集。</li><li>TypeScript通过使用继承来支持可重用性。</li><li>TypeScript使应用程序开发尽可能的快速和简单，并且TypeScript的工具支持为我们提供了自动完成、类型检查和源文档。</li><li>TypeScript支持最新的JavaScript特性，包括ECMAScript 2015。</li><li>TypeScript提供了ES6的所有优点和更高的生产力。</li><li>TypeScript支持静态类型、强类型、模块、可选参数等。</li></ul><h2 id="tslint都能配置哪些功能？对开发流程有何影响？"><a href="#tslint都能配置哪些功能？对开发流程有何影响？" class="headerlink" title="tslint都能配置哪些功能？对开发流程有何影响？"></a>tslint都能配置哪些功能？对开发流程有何影响？</h2><h2 id="如何使用ts实现类型约束，枚举等特性？"><a href="#如何使用ts实现类型约束，枚举等特性？" class="headerlink" title="如何使用ts实现类型约束，枚举等特性？"></a>如何使用ts实现类型约束，枚举等特性？</h2><h2 id="如何理解接口，泛型"><a href="#如何理解接口，泛型" class="headerlink" title="如何理解接口，泛型?"></a>如何理解接口，泛型?</h2><h2 id="和JS的区别"><a href="#和JS的区别" class="headerlink" title="和JS的区别"></a>和JS的区别</h2><p><img src="https://img-blog.csdnimg.cn/20201019091205642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODMyOA==,size_16,color_FFFFFF,t_70#pic_center" alt="区别"></p><h2 id="TS的接口"><a href="#TS的接口" class="headerlink" title="TS的接口"></a>TS的接口</h2><p>接口是在我们的应用程序中充当契约的结构。它定义了要遵循的类的语法，这意味着实现接口的类必须实现它的所有成员。它不能被实例化，但是可以被实现它的类对象引用。无论对象是否具有特定的结构，TypeScript编译器都使用接口进行类型检查</p><pre><code class="js">interface name&#123;  // 字段声明  // 方法声明&#125;</code></pre><p>接口只是声明方法和字段，它不能用来建造任何东西。不需要将接口转换为<code>JavaScript</code>来执行，它们对运行时<code>JavaScript</code>没有任何影响。因此，它们的唯一目的是在开发阶段提供帮助。</p><h2 id="你如何理解Typescript中的类？列出类的一些特性。"><a href="#你如何理解Typescript中的类？列出类的一些特性。" class="headerlink" title="你如何理解Typescript中的类？列出类的一些特性。"></a>你如何理解Typescript中的类？列出类的一些特性。</h2><p><code>TypeScript</code>是一种面向对象的<code>JavaScript</code>语言，支持OOP编程特性，比如类、接口等。与Java一样，类是用于创建可重用组件的基本实体。它是一组具有公共属性的对象。类是创建对象的模板或蓝图。它是一个逻辑实体。“class”关键字用于在<code>Typescript</code>中声明一个类。</p><pre><code class="js">class Student &#123;      studCode: number;      studName: string;      constructor(code: number, name: string) &#123;        this.studName = name;        this.studCode = code;      &#125;      getGrade() : string &#123;        return &quot;A+&quot; ;      &#125;    &#125;    </code></pre><p>类的特征是：</p><p>继承，封装，多态性，抽象</p><ul><li>类(Class)：定义了一件事物的抽象特点，包含它的属性和方法</li><li>对象（Object）：类的实例，通过 new 生成</li><li>面向对象（OOP）的三大特性：封装、继承、多态</li><li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li><li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li><li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat还是 Dog，就可以直接调用 eat方法，程序会自动判断出来应该如何执行 eat</li><li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li><li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。<br>比如 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li><li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li><li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li><li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承可以通过使用<code>extend</code>关键字来实现。</p><pre><code class="js">class Shape &#123;        Area:number        constructor(area:number) &#123;           this.Area = area       &#125;     &#125;     class Circle extends Shape &#123;        display():void &#123;           console.log(&quot;圆的面积: &quot;+this.Area)        &#125;     &#125;    var obj = new Circle(320);     obj.display()  </code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在模块中声明的变量、函数、类和接口不能在模块外部直接访问。</p><pre><code class="js">//可以使用export关键字创建模块，也可以在其他模块中使用import关键字。module module_name&#123;    class xyz&#123;      export sum(x, y)&#123;        return x+y;      &#125;    &#125;  &#125;  </code></pre><p><img src="https://img-blog.csdnimg.cn/20201019093902395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODMyOA==,size_16,color_FFFFFF,t_70#pic_center" alt="模块"></p><p>“内部模块”现在称做“<code>命名空间</code>”。<br>“外部模块”现在则简称为“模块”模块在其自身的作用域里执行，而不是在全局作用域里;</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><pre><code class="js">/** * 新建一个db.ts 将数据库方法封装并且暴露出来 * 暴露一个获取数据的方法 */export function getData():any[]&#123;  return [      &#123;          name:&#39;123&#39;,          ahe:20      &#125;,      &#123;          name:&#39;123425&#39;,          age:30      &#125;  ]&#125;export function saveData():boolean&#123;    console.log(&#39;保存数据成功！&#39;)    return true;&#125;/** * 在index.ts文件中引入 * 在这里引入我暴露的函数 */import &#123;getData&#125; from &#39;./modules/db&#39;console.log(getData());saveData();</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code class="js">/** * 暴露一个获取数据的方法 */function getData():any[]&#123;  return [    &#123;        name:&#39;123&#39;,        ahe:20    &#125;,    &#123;        name:&#39;123425&#39;,        age:30    &#125;  ]&#125;function saveData():boolean&#123;    console.log(&#39;保存数据成功！&#39;)    return true;&#125;export &#123;getData, saveData&#125;/** * 在index.ts文件中引入 * 在这里引入我暴露的函数 */import &#123;getData&#125; from &#39;./modules/db&#39;console.log(getData());saveData();</code></pre><h3 id="命名空间："><a href="#命名空间：" class="headerlink" title="命名空间："></a>命名空间：</h3><p>它封装了共享某些关系的特性和对象。名称空间也称为内部模块。名称空间还可以包括接口、类、函数和变量，以支持一组相关功能。<br><strong>注意</strong>: 名称空间可以在多个文件中定义，并允许将每个文件都定义在一个地方。它使代码更容易维护。</p><pre><code class="ts">namespace &lt;namespace_name&gt; &#123;      export interface I1 &#123; &#125;      export class c1&#123; &#125;    &#125;    </code></pre><h2 id="TypeScript是如何在函数中支持可选参数的？"><a href="#TypeScript是如何在函数中支持可选参数的？" class="headerlink" title="TypeScript是如何在函数中支持可选参数的？"></a>TypeScript是如何在函数中支持可选参数的？</h2><p>我们可以通过使用问号符号(‘?’)来使用可选参数。这意味着可以或不可以接收值的参数可以附加一个”?”可选的。</p><pre><code class="js">function Demo(arg1: number, arg2? :number) &#123;              &#125;</code></pre><p>因此，<code>arg1</code>总是必需的，而<code>arg2</code>是一个可选参数要放后面。<br>注意: 可选参数必须遵循要求的参数。如果我们想让<code>arg1</code>成为可选的，而不是arg2，那么我们需要改变顺序，<code>arg1</code>必须放在<code>arg2</code>之后。</p><pre><code class="js">function Demo(arg2: number, arg1? :number) &#123;  &#125;  </code></pre><h2 id="什么是TypeScript-Declare关键字"><a href="#什么是TypeScript-Declare关键字" class="headerlink" title="什么是TypeScript Declare关键字?"></a>什么是TypeScript Declare关键字?</h2><p>我们知道所有的<code>JavaScript</code>库/框架都没有<code>TypeScript</code>声明文件，但是我们希望在<code>TypeScript</code>文件中使用它们时不会出现编译错误。为此，我们使用<code>declare</code>关键字。在我们希望定义可能存在于其他地方的变量的环境声明和方法中，可以使用<code>declare</code>关键字。</p><p>例如，假设我们有一个名为myLibrary的库，它没有<code>TypeScript</code>声明文件，在全局命名空间中有一个名为myLibrary的命名空间。如果我们想在TypeScript代码中使用这个库，我们可以使用以下代码:</p><pre><code class="ts">declare var myLibrary;</code></pre><h2 id="解释TypeScript中的泛型？"><a href="#解释TypeScript中的泛型？" class="headerlink" title="解释TypeScript中的泛型？"></a>解释TypeScript中的泛型？</h2><p><code>TypeScript</code>泛型是一个提供创建可重用组件方法的工具。它能够创建可以处理多种数据类型而不是单一数据类型的组件。泛型在不影响性能或生产率的情况下提供类型安全性。泛型允许我们创建泛型类、泛型函数、泛型方法和泛型接口。</p><p>在泛型中，类型参数写<code>在开(&lt;)和闭(&gt;)</code>括号之间，这使得它是强类型集合。泛型使用一种特殊类型的类型变量，它表示类型。泛型集合只包含类似类型的对象。</p><pre><code class="ts">function identity&lt;T&gt;(arg: T): T &#123;          return arg;      &#125;      let output1 = identity&lt;string&gt;(&quot;myString&quot;);      let output2 = identity&lt;number&gt;( 100 );    console.log(output1);    console.log(output2);     </code></pre><h2 id="TS的“接口”和“type”语句有什么区别？"><a href="#TS的“接口”和“type”语句有什么区别？" class="headerlink" title="TS的“接口”和“type”语句有什么区别？"></a>TS的“接口”和“type”语句有什么区别？</h2><pre><code class="ts">interface X &#123;      a: number      b: string  &#125;  type X = &#123;      a: number      b: string  &#125;;  </code></pre><p><img src="https://img-blog.csdnimg.cn/20201019100145600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzY5ODMyOA==,size_16,color_FFFFFF,t_70#pic_center" alt="type与interface"></p><h2 id="什么是TypeScript中的类型断言？"><a href="#什么是TypeScript中的类型断言？" class="headerlink" title="什么是TypeScript中的类型断言？"></a>什么是TypeScript中的类型断言？</h2><p>类型断言的工作方式类似于其他语言中的类型转换，但是它不像其他语言一样执行C＃和Java那样的类型检查或数据重组。类型转换附带运行时支持，而类型断言对运行时没有影响。但是，类型断言仅由编译器使用，并向编译器提供有关我们希望如何分析代码的提示。</p><pre><code class="ts">let empCode: any = 111;     let employeeCode = &lt;number&gt; code;     console.log(typeof(employeeCode)); // : number  </code></pre><p>例将 something 断言成 string</p><pre><code class="ts">function getLength(something: string | number): number &#123;  if ((&lt;string&gt;something).length) &#123;      return (&lt;string&gt;something).length;  &#125; else &#123;      return something.toString().length;  &#125;&#125;</code></pre><h2 id="TypeScript的as语法是什么？"><a href="#TypeScript的as语法是什么？" class="headerlink" title="TypeScript的as语法是什么？"></a>TypeScript的as语法是什么？</h2><p>as是TypeScript中类型断言的附加语法，引入as-语法的原因是<strong>原始语法()与JSX冲突</strong>。</p><pre><code class="js">let empCode: any = 111;     let employeeCode = code as number;   </code></pre><p>当使用带有JSX的TypeScript时，只允许as风格的断言。</p><h2 id="什么是JSX？我们可以在TypeScript中使用JSX吗？"><a href="#什么是JSX？我们可以在TypeScript中使用JSX吗？" class="headerlink" title="什么是JSX？我们可以在TypeScript中使用JSX吗？"></a>什么是JSX？我们可以在TypeScript中使用JSX吗？</h2><p>JSX只不过是带有不同扩展名的Javascript。Facebook提出了这个新的扩展，以便与JavaScript中类似xml的HTML实现区分开来。</p><p>JSX是一种可嵌入的类似xml的语法。它将被转换成有效的JavaScript。JSX随着React框架而流行起来。TypeScript支持嵌入、类型检查和直接将JSX编译成JavaScript。</p><p>要使用JSX，我们必须做两件事。</p><p><code>使用.tsx扩展名命名文件</code><br><code>启用jsx选项</code></p><h2 id="什么是Rest参数？"><a href="#什么是Rest参数？" class="headerlink" title="什么是Rest参数？"></a>什么是Rest参数？</h2><p>rest参数用于向函数传递零个或多个值。它是通过在参数前加上三个点字符(‘…’)来声明的。它允许函数在不使用arguments对象的情况下拥有可变数量的参数。当我们有不确定数量的参数时，这是非常有用的。</p><p>rest参数要遵循的规则:</p><ol><li>一个函数中只允许有一个rest参数。</li><li>它必须是数组类型。</li><li>它必须是参数列表中的最后一个参数。</li></ol><pre><code class="js">function sum(a: number, ...b: number[]): number &#123;     let result = a;     for (var i = 0; i &lt; b.length; i++) &#123;     result += b[i];     &#125;     console.log(result);    &#125;    let result1 = sum(3, 5);    let result2 = sum(3, 5, 7, 9);   </code></pre><h2 id="解释TypeScript的Enum枚举类型？"><a href="#解释TypeScript的Enum枚举类型？" class="headerlink" title="解释TypeScript的Enum枚举类型？"></a>解释TypeScript的Enum枚举类型？</h2><p>枚举或枚举是一种数据类型，允许我们定义一组命名常量。使用枚举可以更容易地记录意图，或者创建一组不同的案例。它是相关值的集合，可以是数值或字符串值。</p><pre><code class="js">enum Gender &#123;    Male,    Female    Other  &#125;  console.log(Gender.Female); // : 1  // 我们还可以通过enum值的number值来访问它console.log(Gender[1]); // : Female</code></pre><h2 id="解释相对模块和非相对模块的导入"><a href="#解释相对模块和非相对模块的导入" class="headerlink" title="解释相对模块和非相对模块的导入"></a>解释相对模块和非相对模块的导入</h2><ul><li>非相对</li><li>非相对导入可以相对于baseUrl解析，也可以通过路径映射解析。换句话说，我们在导入任何外部依赖项时使用非相对路径。 例子:</li></ul><pre><code class="js"> import * as $ from “jquery”;  import &#123; Component &#125; from “@angular/core”;</code></pre><ul><li>相对</li><li>相对导入可以用于我们自己的模块，这些模块保证在运行时维护它们的相对位置。相对导入以/、./或…/开头。 例子:</li></ul><pre><code class="js"> import Entry from “./components/Entry”;  import &#123;DefaultHeaders&#125; from “../constants/http”;</code></pre><h2 id="什么是匿名函数？"><a href="#什么是匿名函数？" class="headerlink" title="什么是匿名函数？"></a>什么是匿名函数？</h2><p>匿名函数是声明时没有任何命名标识符的函数。这些函数是在运行时动态声明的。与标准函数一样，匿名函数可以接受输入和返回输出。匿名函数在初始创建之后通常是不可访问的。</p><pre><code class="js">let myAdd = function(x: number, y: number): number &#123;       return x + y;   &#125;;  console.log(myAdd())  </code></pre><h2 id="什么是声明合并？"><a href="#什么是声明合并？" class="headerlink" title="什么是声明合并？"></a>什么是声明合并？</h2><p><code>声明合并</code>是编译器随后合并两个或多个独立声明的过程。将具有相同名称的声明声明为单个定义。这个合并的定义具有两个原始声明的特性。</p><p>最简单也是最常见的声明合并类型是接口合并。在最基本的层次上，merge将两个声明的成员机械地连接到一个具有相同名称的接口中</p><pre><code class="js">interface Cloner &#123;      clone(animal: Animal): Animal;  &#125;  interface Cloner &#123;      clone(animal: Sheep): Sheep;  &#125;  interface Cloner &#123;      clone(animal: Dog): Dog;      clone(animal: Cat): Cat;  &#125;  // 这三个接口将合并为一个单独的声明interface Cloner &#123;    clone(animal: Dog): Dog;    clone(animal: Cat): Cat;    clone(animal: Sheep): Sheep;    clone(animal: Animal): Animal;  &#125;  </code></pre><p>注: 在TypeScript中不是所有的合并都允许。目前，类不能与其他类或变量合并。</p><h2 id="TypeScript中的方法重写是什么"><a href="#TypeScript中的方法重写是什么" class="headerlink" title="TypeScript中的方法重写是什么?"></a>TypeScript中的方法重写是什么?</h2><p>如果子类(子类)具有与父类中声明的相同的方法，则称为方法覆盖。换句话说，在派生类或子类中重新定义基类方法。</p><p>方法重写的规则:</p><ol><li>该方法必须具有与父类相同的名称</li><li>该方法必须具有与父类相同的参数。</li><li>必须有一个IS-A关系(继承)。</li></ol><pre><code class="js">class NewPrinter extends Printer &#123;      doPrint(): any &#123;          super.doPrint();          console.log(&quot;Called Child class.&quot;);      &#125;      doInkJetPrint(): any &#123;          console.log(&quot;Called doInkJetPrint().&quot;);      &#125;  &#125;  let printer: new () =&gt; NewPrinter;  printer.doPrint();  printer.doInkJetPrint();  </code></pre><h2 id="Lambda-箭头函数是什么？"><a href="#Lambda-箭头函数是什么？" class="headerlink" title="Lambda/箭头函数是什么？"></a>Lambda/箭头函数是什么？</h2><p>ES6版本的<code>TypeScript</code>提供了定义匿名函数的简写语法，也就是用于函数表达式。<br>这些箭头函数也称为<code>Lambda</code>函数。<code>lambda</code>函数是没有名称的函数，箭头函数省略了<code>function</code>关键字。</p><pre><code class="js">let sum = (a: number, b: number): number =&gt; &#123;      return a + b;    &#125;    console.log(sum(20, 30)); //returns 50    </code></pre><p>在上面，<code>?=&gt;?</code>是一个lambda操作符，(a + b)是函数的主体，(a: number, b: number)是内联参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;是否可以将多个js文件合并为1个ts文件？如果是怎么做？&quot;&gt;&lt;a href=&quot;#是否可以将多个js文件合并为1个ts文件？如果是怎么做？&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/categories/Ts/"/>
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之DOM树和渲染过程</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/30/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BDOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/30/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BDOM%E6%A0%91%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</id>
    <published>2020-09-30T01:15:38.000Z</published>
    <updated>2020-09-30T02:18:26.765Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><p>平时中因为有各个框架的API使用，使我们对DOM的操作，慢慢变得淡忘，但是我们要知道的是各个框架也是操作dom的，只是将方法暴露出来，方便我们使用。通过学习DOM操作，加深对Javascript的理解</p><p>DOM操作并没有你想象的那么难。</p><p><img src="https://user-gold-cdn.xitu.io/2016/11/29/8d195c29c5f16f86e390d4c6f26084da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="dom操作"></p><h3 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h3><p>让我们开始创建HTML元素，为了创建元素，你需要用<code>document.createElement(tagName) </code>方法：</p><pre><code class="js">const h1 = document.createElement(&#39;h1&#39;)//</code></pre><h3 id="修改文本内容"><a href="#修改文本内容" class="headerlink" title="修改文本内容"></a>修改文本内容</h3><pre><code class="js">h1.textContent = &#39;hello world&#39;</code></pre><h3 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h3><pre><code class="js">h1.setAttributes(&#39;class&#39;,&#39;hello&#39;)</code></pre><p>为了管理类，用<code>element.className</code>属性</p><pre><code class="js">h1.className = &#39;world&#39;</code></pre><p>然而，最好的办法还是用<code>classList</code></p><pre><code class="js">h1.classList.add(&#39;hello&#39;)h1.classList.remove(&#39;hello&#39;)</code></pre><p>要设置元素的ID,你可以用attribute或者直接设置id属性</p><pre><code class="js">h1.setAttribute(&#39;id&#39;, &#39;hello-world&#39;)h1.id = &#39;hello-world&#39;</code></pre><blockquote><p>如果你不确定是用attributes还是properties，那就用attributes，除了表单元素的状态，像value和checked</p></blockquote><p>除了下面这些，你不能用<code>element.setAttribute(someBoolean, false)</code>来设置bool值：</p><pre><code class="js">input.checked = true// input.checked = false// input.setAttribute(‘checked’, ‘’)// input.removeAttribute(&#39;checked&#39;)// </code></pre><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><pre><code class="js">document.body.appendChild(h1)</code></pre><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><pre><code class="js">document.body.removeChild(h1)</code></pre><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><pre><code class="js">document.getElementById(id)element.childNodes[i]element.firstChild === element.childNodes[0]element.lastChild === element.childNodes[element.childNodes.length - 1]element.getElementsByTagName(tagName)element.getElementsByClassName(className)element.querySelector(query)element.querySelectorAll(query)</code></pre><p><strong>注意</strong>：<code>getElementsByTagName, getElementsByClassName 和 querySelectorAll</code>返回的不是数组，而是一个<code>NodeList</code>，所以不能用ES5的数组迭代器迭代，这里有一些关于<a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList#Workarounds">NodeList的介绍</a></p><h3 id="元素之间插入元素"><a href="#元素之间插入元素" class="headerlink" title="元素之间插入元素"></a>元素之间插入元素</h3><pre><code class="js"> document.body.insertBefore(h1, document.body.firstChild)</code></pre><h3 id="创建很多元素"><a href="#创建很多元素" class="headerlink" title="创建很多元素"></a>创建很多元素</h3><pre><code class="js">const data = [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ]  ]const table = document.createElement(&#39;table&#39;)data.forEach(row =&gt; &#123;  const tr = document.createElement(&#39;tr&#39;)  row.forEach(cell =&gt; &#123;    const td = document.createElement(&#39;td&#39;)    td.textContent = cell    tr.appendChild(td)  &#125;)  table.appendChild(tr)&#125;)document.body.appendChild(table)</code></pre><h3 id="更新一系列元素"><a href="#更新一系列元素" class="headerlink" title="更新一系列元素"></a>更新一系列元素</h3><pre><code class="js">const table = document.createElement(&#39;table&#39;)document.body.appendChild(table)updateTable(table, [  [ 1, 2 ],  [ 3, 4, 5 ],  [ 6, 7, 8, 9 ]  ])setTimeout(() =&gt; &#123;  updateTable(table, [    [ 1, 2, 3, 4 ],    [ 5, 6, 7 ],    [ 8, 9 ]  ])  &#125;, 1000)function updateTable (table, data) &#123;  const rowLookup = table._lookup || (table._lookup = [])  setChildren(table, updateRows(rowLookup, data))&#125;function updateRows (rowLookup, rows) &#123;  return rows.map((row, y) =&gt; &#123;    const tr = rowLookup[y] || (rowLookup[y] = document.createElement(&#39;tr&#39;))    const cellLookup = tr._lookup || (tr._lookup = [])    setChildren(tr, updateCells(cellLookup, row))    return tr  &#125;)&#125;function updateCells (cellLookup, cells) &#123;  return cells.map((cell, x) =&gt; &#123;      const td = cellLookup[x] || (cellLookup[x] = document.createElement(&#39;td&#39;))      td.textContent = cell      return td    &#125;)&#125;function setChildren (parent, children) &#123;  let traverse = parent.firstChild  for (let i = 0; i &lt; children.length; i++) &#123;    const child = children[i]    if (child == null) &#123;      return    &#125;    if (child === traverse) &#123;      traverse = traverse.nextSibling    &#125; else if (traverse) &#123;      parent.insertBefore(child, traverse)    &#125; else &#123;      parent.appendChild(child)    &#125;  &#125;  while (traverse) &#123;    const next = traverse.nextSibling    parent.removeChild(traverse)    traverse = next  &#125;&#125;</code></pre><p>这里发生了两件事：</p><ul><li>1.这里有一个隐藏的元素<code>element._lookup = []</code>，用来查找子元素（可能是一个有id的元素），用这个方法我们可以重复利用已经存在的dom，更新他们</li><li>2.<code>setChildren(parent, children)</code>方法里有包含子元素的列表</li></ul><p>你还可以用<code>setChildren</code>方法来<code>mount/unmount</code>子元素</p><pre><code class="js">setChildren(login, [  email,  !forgot &amp;&amp; pass])</code></pre><h2 id="DOM树的渲染"><a href="#DOM树的渲染" class="headerlink" title="DOM树的渲染"></a>DOM树的渲染</h2><h3 id="CSS-不会阻塞-DOM-的解析"><a href="#CSS-不会阻塞-DOM-的解析" class="headerlink" title="CSS 不会阻塞 DOM 的解析"></a>CSS 不会阻塞 DOM 的解析</h3><p>首先在头部插入<code>&lt;script defer src=&quot;/js/logDiv.js&quot;&gt;&lt;/script&gt;</code>，JS文件的内容是：</p><pre><code class="js">const div = document.querySelector(&#39;div&#39;);console.log(div);</code></pre><p><code>defer</code>属性相信大家也很熟悉了，MDN对此的描述是用来通知浏览器该脚本将在文档完成解析后，触发 <code>DOMContentLoaded</code> 事件前执行。设置这个属性，能保证DOM解析后马上打印出div。</p><p>浏览器是解析DOM生成<code>DOM Tree</code>，结合CSS生成的<code>CSS Tree</code>，最终组成<code>render tree</code>，再渲染页面。由此可见，在此过程中CSS完全无法影响<code>DOM Tree</code>，因而无需阻塞DOM解析。然而，<code>DOM Tree</code>和<code>CSS Tree</code>会组合成<code>render tree</code>，那CSS会不会页面阻塞渲染呢？</p><h3 id="CSS-阻塞页面渲染"><a href="#CSS-阻塞页面渲染" class="headerlink" title="CSS 阻塞页面渲染"></a>CSS 阻塞页面渲染</h3><p>如果脚本的内容是获取元素的样式，宽高等CSS控制的属性，浏览器是需要计算的，也就是依赖于CSS。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行JS。因而造成了之前例子的情况。</p><h3 id="JS-阻塞-DOM-解析"><a href="#JS-阻塞-DOM-解析" class="headerlink" title="JS 阻塞 DOM 解析"></a>JS 阻塞 DOM 解析</h3><p>浏览器遇到<code> &lt;script&gt;</code> 标签时，会触发页面渲染</p><p>每次碰到<code>&lt;script&gt;</code>标签时，浏览器都会渲染一次页面。这是基于同样的理由，浏览器不知道脚本的内容，因而碰到脚本时，只好先渲染页面，确保脚本能获取到最新的DOM元素信息，尽管脚本可能不需要这些信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;DOM操作&quot;&gt;&lt;a href=&quot;#DOM操作&quot; class=&quot;headerlink&quot; title=&quot;DOM操作&quot;&gt;&lt;/a&gt;DOM操作&lt;/h2&gt;&lt;p&gt;平时中因为有各个框架的</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习JavaScript应懂得33个概念之按位操作符, 类数组对象和类型化数组</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/29/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/29/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84/</id>
    <published>2020-09-29T01:25:07.000Z</published>
    <updated>2020-09-29T06:33:06.082Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="先了解下十进制与二进制互转"><a href="#先了解下十进制与二进制互转" class="headerlink" title="先了解下十进制与二进制互转"></a>先了解下十进制与二进制互转</h2><h3 id="十进制转二进制"><a href="#十进制转二进制" class="headerlink" title="十进制转二进制"></a>十进制转二进制</h3><p><strong>正整数转成二进制</strong>，除二取余，然后倒序排列，高位补零</p><p><img src="https://exp-picture.cdn.bcebos.com/c255efc595ee41c19c2f7ce08d88912ca5ca9b5f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo"></p><p><strong>负整数转二进制</strong>，先是将对应的正整数转换成二进制后，对二进制取反（1取0，0取1），然后对结果再加一</p><p><strong>tip: 和0相加是0，0和1相加是1，1和1相加是0但要产生一个进位1，加到下一列。如果最高位相加后产生进位，则最后得到的结果要加1。</strong></p><p><img src="https://exp-picture.cdn.bcebos.com/906dbbcadce8904832f4a744130e5f204371925f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo1"></p><p><strong>小数转换为二进制的方法</strong>,对小数点以后的数乘以2，有一个结果吧，取结果的整数部分（不是1就是0喽），然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小数部分为0或者位数已经够了就OK了</p><p><img src="https://exp-picture.cdn.bcebos.com/5e615d715fdb362080321d3aabc5260f88358d5f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo2"></p><h3 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h3><p><strong>整数二进制转换为十进制</strong>,首先将二进制数补齐位数，首位如果是0就代表是正整数，如果首位是1则代表是负整数。</p><p><img src="https://exp-picture.cdn.bcebos.com/3931cb413a8ca608e307444fdb8c9bcec7f8fe5f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo3"></p><p><strong>二进制的负数转为十进制</strong>,二进制转十进制跟十进制转二进制互为逆操作；</p><p><img src="https://exp-picture.cdn.bcebos.com/bf6e59704618dfda8cd40c3589214f5792567746.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo4"></p><p><strong>有小数的二进制转换为十进制</strong>,将二进制中的四位数分别于下边（如图9所示）对应的值相乘后相加得到的值即为换算后的十进制</p><p><img src="https://exp-picture.cdn.bcebos.com/6a408cdd3340b6f3c78fd3af12c0affce186ee5f.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1" alt="demo5"></p><h2 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h2><p><code>按位操作符（Bitwise operators）</code> 将其操作数（operands）当作32位的比特序列（由0和1组成），而不是十进制、十六进制或八进制数值。</p><p>例如，十进制数9，用二进制表示则为1001。<em>按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值</em>。</p><table><thead><tr><th align="left">运算符</th><th align="left">用法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">按位与（ AND）</td><td align="left">a &amp; b</td><td align="left">对于每一个比特位，只有两个操作数相应的比特位都是1时，结果才为1，否则为0。</td></tr><tr><td align="left">按位或（OR）</td><td align="left">a I b</td><td align="left">对于每一个比特位，当两个操作数相应的比特位至少有一个1时，结果为1，否则为0。</td></tr><tr><td align="left">按位异或（XOR）</td><td align="left">a ^ b</td><td align="left">对于每一个比特位，当两个操作数相应的比特位有且只有一个1时，结果为1，否则为0。</td></tr><tr><td align="left">按位非（NOT）</td><td align="left">~ a</td><td align="left">反转操作数的比特位，即0变成1，1变成0。</td></tr><tr><td align="left">左移（Left shift）</td><td align="left">a &lt;&lt; b</td><td align="left">将 a 的二进制形式向左移 b (&lt; 32) 比特位，右边用0填充。</td></tr><tr><td align="left">有符号右移</td><td align="left">a &gt;&gt; b</td><td align="left">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位。</td></tr><tr><td align="left">无符号右移</td><td align="left">a &gt;&gt;&gt; b</td><td align="left">将 a 的二进制表示向右移 b (&lt; 32) 位，丢弃被移出的位，并使用 0 在左侧填充。</td></tr></tbody></table><h2 id="有符号32位整数"><a href="#有符号32位整数" class="headerlink" title="有符号32位整数"></a>有符号32位整数</h2><p>所有的按位操作符的操作数都会被转成补码（two’s complement）形式的有符号32位整数。<br><strong>补码形式是指一个数的负对应值（negative counterpart）（如 5和-5）为数值的所有比特位反转后，再加1。</strong><br>反转比特位即该数值进行’非‘位运算，也即该数值的反码。</p><ul><li><p>0 是所有比特数字0组成的整数。<br><code>0 (base 10) = 00000000000000000000000000000000 (base 2)</code></p></li><li><p>-1 是所有比特数字1组成的整数。<br><code>-1 (base 10) = 11111111111111111111111111111111 (base 2)</code></p></li><li><p>-2147483648（十六进制形式：-0x80000000）是除了最左边为1外，其他比特位都为0的整数。<br><code>-2147483648 (base 10) = 10000000000000000000000000000000 (base 2)</code></p></li><li><p>2147483647（十六进制形式：0x7fffffff）是除了最左边为0外，其他比特位都为1的整数。<br><code>2147483647 (base 10) = 01111111111111111111111111111111 (base 2)</code></p></li></ul><p>数字<code>-2147483648</code> 和 <code>2147483647</code> 是32位有符号数字所能表示的最小和最大整数。</p><h3 id="按位逻辑操作符"><a href="#按位逻辑操作符" class="headerlink" title="按位逻辑操作符"></a>按位逻辑操作符</h3><h4 id="amp-（按位与）"><a href="#amp-（按位与）" class="headerlink" title="&amp;（按位与）"></a>&amp;（按位与）</h4><p>对每对比特位执行<code>与（AND）</code>操作。只有 a 和 b 都是 1 时，a AND b 才是 1。将任一数值 x 与 0 执行按位与操作，其结果都为 0。将任一数值 x 与 -1 执行按位与操作，其结果都为 x。</p><h4 id="（按位或）"><a href="#（按位或）" class="headerlink" title="|（按位或）"></a>|（按位或）</h4><p>对每一对比特位执行<code>或（OR）</code>操作。如果 a 或 b 为 1，则 a OR b 结果为 1。将任一数值 x 与 0 进行按位或操作，其结果都是 x。将任一数值 x 与 -1 进行按位或操作，其结果都为 -1。。</p><h4 id="（按位非）"><a href="#（按位非）" class="headerlink" title="~（按位非）"></a>~（按位非）</h4><p>对每一个比特位执行<code>非（NOT）</code>操作。NOT a 结果为 a 的反转（即反码）。对任一数值 x 进行按位非操作的结果为 -(x + 1)</p><h4 id="（按位异或）"><a href="#（按位异或）" class="headerlink" title="^（按位异或）"></a>^（按位异或）</h4><p>对每一对比特位执行<code>异或（XOR）</code>操作。当 a 和 b 不相同时，a XOR b 的结果为 1。将任一数值 x 与 0 进行异或操作，其结果为 x。将任一数值 x 与 -1 进行异或操作，其结果为 ~x。</p><h3 id="按位移动操作符"><a href="#按位移动操作符" class="headerlink" title="按位移动操作符"></a>按位移动操作符</h3><p>按位移动操作符有两个操作数：<strong>第一个是要被移动的数字，而第二个是要移动的长度</strong>。移动的方向根据操作符的不同而不同。</p><h4 id="lt-lt-左移"><a href="#lt-lt-左移" class="headerlink" title="&lt;&lt; (左移)"></a>&lt;&lt; (左移)</h4><p>该操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。</p><p>For example,<code>9 &lt;&lt; 2</code> yields 36:</p><pre><code class="js">9 (base 10): 00000000000000000000000000001001 (base 2)//--------------------------------9 &lt;&lt; 2 (base 10): 00000000000000000000000000100100 (base 2) = 36 (base 10)</code></pre><p>在数字 <code>x</code> 上左移<code> y</code> 比特得到 <code>x * 2y</code>.</p><h4 id="gt-gt-右移"><a href="#gt-gt-右移" class="headerlink" title="&gt;&gt; (右移)"></a>&gt;&gt; (右移)</h4><p>该操作符会<strong>将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变</strong>。</p><p>例如， <code>9 &gt;&gt; 2</code> 得到 2:</p><pre><code class="js">9 (base 10): 00000000000000000000000000001001 (base 2)//--------------------------------9 &gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</code></pre><p>相比之下， <code>-9 &gt;&gt; 2</code> 得到 -3，因为符号被保留了。</p><pre><code class="js"> -9 (base 10): 11111111111111111111111111110111 (base 2)//---------------------------------9 &gt;&gt; 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)</code></pre><h4 id="gt-gt-gt-无符号右移"><a href="#gt-gt-gt-无符号右移" class="headerlink" title="&gt;&gt;&gt; (无符号右移)"></a>&gt;&gt;&gt; (无符号右移)</h4><p>该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的</p><p><strong>对于非负数，有符号右移和无符号右移总是返回相同的结果</strong>。例如 <code>9 &gt;&gt;&gt; 2</code> 和 <code>9 &gt;&gt; 2</code> 一样返回 2：</p><pre><code class="js">9 (base 10): 00000000000000000000000000001001 (base 2)// --------------------------------9 &gt;&gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)</code></pre><p><strong>但是对于负数却不尽相同</strong>。<code>-9 &gt;&gt;&gt; 2</code>产生<code> 1073741821</code> 这和 <code>-9 &gt;&gt; 2</code> 不同：</p><pre><code class="js">-9 (base 10): 11111111111111111111111111110111 (base 2)//---------------------------------9 &gt;&gt;&gt; 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10)</code></pre><h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><p>JavaScript类型化数组是一种类似数组的对象，并提供了一种用于访问原始二进制数据的机制。 </p><p>正如你可能已经知道，Array 存储的对象能动态增多和减少，并且可以存储任何JavaScript值。JavaScript引擎会做一些内部优化，以便对数组的操作可以很快。</p><p>然而，随着Web应用程序变得越来越强大，尤其一些新增加的功能例如：<code>音频视频编辑，访问WebSockets的原始数据</code>等，很明显有些时候如果使用JavaScript代码可以快速方便地通过<strong>类型化数组来操作原始的二进制数据</strong>将会非常有帮助。</p><p>类型数组不等于数组，可以使用<code>Array.isArray</code>可以判断出类型数组为<code>false</code></p><h3 id="缓冲和视图：类型数组架构"><a href="#缓冲和视图：类型数组架构" class="headerlink" title="缓冲和视图：类型数组架构"></a>缓冲和视图：类型数组架构</h3><p>为了达到最大的灵活性和效率，JavaScript 类型数组（Typed Arrays）将实现拆分为<strong>缓冲</strong>和<strong>视图</strong>两部分。</p><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><p><code>ArrayBuffer</code> 是一种数据类型，用来表示一个通用的、固定长度的二进制数据缓冲区。你不能直接操纵一个<code>ArrayBuffer</code>中的内容；你需要创建一个类型化数组的视图或一个描述缓冲数据格式的<code>DataView</code>，使用它们来读写缓冲区中的内容.</p><h4 id="类型数组视图"><a href="#类型数组视图" class="headerlink" title="类型数组视图"></a>类型数组视图</h4><p>类型化数组视图具有自描述性的名字和所有常用的数值类型像<code>Int8</code>，<code>Uint32</code>，<code>Float64</code> 等等。有一种特殊类型的数组<code>Uint8ClampedArray</code>。它仅操作0到255之间的数值。</p><h4 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h4><p><code>DataView</code> 是一种底层接口，它提供有可以操作缓冲区中任意数据的读写接口。这对操作不同类型数据的场景很有帮助，例如：类型化数组视图都是运行在本地字节序模式(参考 Endianness)，可以通过使用 <code>DataView</code> 来控制字节序。默认是大端字节序(Big-endian)，但可以调用读写接口改为小端字节序(Little-endian)。</p><h3 id="使用类型数组的Web-API"><a href="#使用类型数组的Web-API" class="headerlink" title="使用类型数组的Web API"></a>使用类型数组的Web API</h3><p><code>FileReader.prototype.readAsArrayBuffer()</code><br><code>FileReader.prototype.readAsArrayBuffer()</code> 读取对应的<code>Blob</code> 或 <code>File</code>的内容</p><p><code>XMLHttpRequest.prototype.send()</code><br><code>XMLHttpRequest</code> 实例的 send() 方法现在使用支持类型化数组和 <code>ArrayBuffer</code> 对象作为参数。</p><p><code>ImageData.data</code><br>是一个 <code>Uint8ClampedArray</code> 对象，用来描述包含按照RGBA序列的颜色数据的一维数组，其值的范围在0到255（包含255）之间。</p><p><code>ImageData</code> 接口描述 <code>&lt;canvas&gt;</code> 元素的一个隐含像素数据的区域。使用 <code>ImageData()</code> 构造函数创建或者使用和 <code>canvas</code> 在一起的 <code>CanvasRenderingContext2D</code> 对象的创建方法： <code>createImageData() 和 getImageData()</code>。也可以使用 <code>putImageData()</code> 设置 <code>canvas</code> 的一部分。</p><h2 id="ArrayBuffer-1"><a href="#ArrayBuffer-1" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h2><p><strong>ArrayBuffer又称类型化数组</strong>。</p><blockquote><p>javascript数组（Array）长什么样子，相信大家都清楚，那么我说说差别应该就可以了解这究竟是个什么了！</p></blockquote><ul><li>数组里面可以放数字、字符串、布尔值以及对象和数组等，<code>ArrayBuffer</code>放0和1组成的二进制数据</li><li>数组放在堆中，<code>ArrayBuffer</code>则把数据放在栈中（所以取数据时后者快）</li><li><code>ArrayBuffer</code>初始化后固定大小，数组则可以自由增减。(准确的说，视图才应该跟数组来比较这个特点)</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="js">// new ArrayBuffer(Bytelength);var arraybuffer = new ArrayBuffer(8);//类方法ArrayBuffer.isView() 判断某对象是否为 视图(这是什么？往下看)var int8a = new Int8Array(arraybuffer);ArrayBuffer.isView(int8a)  //return true//类属性ArrayBuffer.length 默认值1，暂未发现用处ArrayBuffer.length //return 1//返回的对象具有byteLength属性 值为参数Bytelengtharraybuffer.byteLength //return 8</code></pre><p>如上所诉：实例化一个对象的时候，仅需要传入一个参数，即字节数。</p><p><code>字节(Byte)</code>：存储空间的基本计量单位。一个字节等于8位(bit)，每一位用0或1表示。</p><h3 id="视图："><a href="#视图：" class="headerlink" title="视图："></a>视图：</h3><p><code>ArrayBuffer</code>对象并没有提供任何读写内存的方法，而是允许在其上方建立“视图”，从而插入与读取内存中的数据。如上：我们在内存中分配了16个格子也就是两个字节，如果我们要划分出A视图与B视图来瓜分这16个格子的话，代码是这样的：</p><pre><code class="js">var arraybuffer = new ArrayBuffer(8);var aView = new Int8Array(arraybuffer,0,1);var bView = new Int8Array(arraybuffer,1,1);aView[0] = 1;  //二进制00000001bView[0] = 2;  //二进制00000010</code></pre><table><thead><tr><th align="left">视图类型</th><th align="left">数据类型</th><th align="left">占用位数</th><th align="left">占用字节</th><th align="left">有无符号</th></tr></thead><tbody><tr><td align="left">Int8Array</td><td align="left">整数</td><td align="left">8</td><td align="left">1</td><td align="left">有</td></tr><tr><td align="left">Uint8Array</td><td align="left">整数</td><td align="left">8</td><td align="left">1</td><td align="left">无</td></tr><tr><td align="left">Uint8ClampedArray</td><td align="left">整数</td><td align="left">8</td><td align="left">1</td><td align="left">无</td></tr><tr><td align="left">Int16Array</td><td align="left">整数</td><td align="left">16</td><td align="left">2</td><td align="left">有</td></tr><tr><td align="left">Uint16Array</td><td align="left">整数</td><td align="left">16</td><td align="left">2</td><td align="left">无</td></tr><tr><td align="left">Int32Array</td><td align="left">整数</td><td align="left">32</td><td align="left">4</td><td align="left">有</td></tr><tr><td align="left">Uint32Array</td><td align="left">整数</td><td align="left">32</td><td align="left">4</td><td align="left">无</td></tr><tr><td align="left">Float32Array</td><td align="left">浮点数</td><td align="left">32</td><td align="left">4</td><td align="left">\</td></tr><tr><td align="left">Float64Array</td><td align="left">浮点数</td><td align="left">64</td><td align="left">8</td><td align="left">\</td></tr></tbody></table><p> <strong>有无符号则表示该类数据类型是否包含负数</strong>，如：Int8Array代表8位有符号整数，其范围为 -128<del>127，而Uint8Array代表8位无符号整数，范围是 0</del>255。</p><h3 id="DataView视图"><a href="#DataView视图" class="headerlink" title="DataView视图"></a>DataView视图</h3><p>为了解决各种硬件设备、数据传输等对默认字节序的设定不一而导致解码时候会发生的混乱问题，javascript提供了<code>DataView</code>类型的视图来让开发者在对内存进行读写时手动设定字节序的类型。</p><p>（一）DataView构造函数</p><pre><code class="js">//new DataView(arraybuffer,byteOffset [, byteLength])var arraybuffer = new ArrayBuffer(8);var dv1 = new DataView(arraybuffer);    //0-7var dv2 = new DataView(arraybuffer,2);    //2-7var dv3 = new DataView(arraybuffer,3,2);    //3-4</code></pre><p>（二）DataView实例化后的对象所具有的功能</p><table><thead><tr><th align="left">Read</th><th align="left">Write</th></tr></thead><tbody><tr><td align="left">getInt8()</td><td align="left">setInt8()</td></tr><tr><td align="left">getUint8()</td><td align="left">setUint8()</td></tr><tr><td align="left">getInt16()</td><td align="left">setInt16()</td></tr><tr><td align="left">getUint16()</td><td align="left">setUint16()</td></tr><tr><td align="left">getInt32()</td><td align="left">setInt32()</td></tr><tr><td align="left">getUint32()</td><td align="left">setUint32()</td></tr><tr><td align="left">getFloat32()</td><td align="left">setFloat32()</td></tr><tr><td align="left">getFloat64()</td><td align="left">setFloat64()</td></tr></tbody></table><p>你可以通过如下的方式来<strong>判断运行当前javascript的机器使用哪一种字节序</strong></p><pre><code class="js">var littleEndian = (function() &#123;  var buffer = new ArrayBuffer(2);  new DataView(buffer).setInt16(0, 256, true);  return new Int16Array(buffer)[0] === 256;&#125;)();console.log(littleEndian); // true ----&gt;littleEndian                            //false ----&gt;BigEndian</code></pre><h3 id="ArrayBuffer与字符串"><a href="#ArrayBuffer与字符串" class="headerlink" title="ArrayBuffer与字符串"></a>ArrayBuffer与字符串</h3><p>javascript的字符串使用<code>UTF-16</code>编码的方式，所以我们可以这样来做：</p><pre><code class="js">function Uint162Str(arraybuffer)&#123;  return String.fromCharCode.apply(null,new Uint16Array(arraybuffer));&#125;function Str2Uint16(str)&#123;  //假设字符串”abc“ length=3,使用16位，则每一个字母占据2字节，总字节为length乘以2  var arraybuffer =new ArrayBuffer(str.length*2);  var view = new Uint16Array(arraybuffer);  for(var i=0,l=str.length;i&lt;l;i++)&#123;      view[i] = str.charCodeAt(i);  &#125;  return view;&#125;    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;先了解下十进制与二进制互转&quot;&gt;&lt;a href=&quot;#先了解下十进制与二进制互转&quot; class=&quot;headerlink&quot; title=&quot;先了解下十进制与二进制互转&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习JavaScript应懂得33个概念之封装多态继承</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/28/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E5%A4%9A%E6%80%81%E7%BB%A7%E6%89%BF/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/28/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0JavaScript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%B0%81%E8%A3%85%E5%A4%9A%E6%80%81%E7%BB%A7%E6%89%BF/</id>
    <published>2020-09-28T05:36:18.000Z</published>
    <updated>2020-09-28T06:19:51.422Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://juejin.im/post/6844903480868470798">原文地址</a></p><p><img src="https://user-gold-cdn.xitu.io/2017/6/8/99f977fcc9ad71ee0c197cbdaecd52b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="面向对象编程"></p><p>先上一张图，可以对面向对象有一个大致的了解，然而什么是面向对象呢，用java中的一句经典语句来说就是：万事万物皆对象。面向对象的思想主要是以对象为主，将一个问题抽象出具体的对象，并且将抽象出来的对象和对象的属性和方法封装成一个类。</p><blockquote><p>面向对象是把<strong>构成问题事务分解成各个对象</strong>，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p></blockquote><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>面向对象和面向过程是两种不同的编程思想，我们经常会听到两者的比较，刚开始编程的时候，大部分应该都是使用的面向过程的编程，但是随着我们的成长，还是面向对象的编程思想比较好一点~其实面向对象和面向过程并不是完全相对的，也并不是完全独立的。我认为面向对象和面向过程的主要区别是面向过程主要是以动词为主，解决问题的方式是按照顺序一步一步调用不同的函数。而面向对象主要是以名词为主，将问题抽象出具体的对象，而这个对象有自己的属性和方法，在解决问题的时候是将不同的对象组合在一起使用。所以说面向对象的好处就是可扩展性更强一些，解决了代码重用性的问题。</p><ul><li>面向过程就是分析出解决问题所需要的步骤，然后<strong>用函数把这些步骤一步一步实现</strong>，使用的时候一个一个依次调用就可以了。</li><li>面向对象是把<strong>构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤</strong>，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li></ul><p>有一个知乎的高票回答很有意思，给大家分享一下~</p><blockquote><p>面向对象： 狗.吃(屎)<br>面向过程： 吃.(狗,屎)</p></blockquote><p>具体的实现我们看一下最经典的“<code>把大象放冰箱</code>”这个问题</p><h3 id="面向过程的解决方法"><a href="#面向过程的解决方法" class="headerlink" title="面向过程的解决方法"></a>面向过程的解决方法</h3><p>在面向过程的编程方式中实现“把大象放冰箱”这个问题答案是耳熟能详的，一共分三步：</p><ul><li>开门（冰箱）；</li><li>装进（冰箱，大象）；</li><li>关门（冰箱）。面向对象的解决方法</li></ul><h3 id="面向对象的解决方法"><a href="#面向对象的解决方法" class="headerlink" title="面向对象的解决方法"></a>面向对象的解决方法</h3><ul><li>冰箱.开门（）</li><li>冰箱.装进（大象）</li><li>冰箱.关门（）</li></ul><p>可以看出来面向对象和面向过程的侧重点是不同的，<strong>面向过程是以动词为主</strong>，完成一个事件就是将不同的动作函数按顺序调用。<strong>面向对象是以主谓为主</strong>。将主谓看成一个一个的对象，然后对象有自己的属性和方法。</p><p>比如说，冰箱有自己的id属性，有开门的方法。然后就可以直接调用冰箱的开门方法给其传入一个参数大象就可以了。简单的例子面向对象和面向过程的好处还不是很明显。</p><h3 id="五子棋例子"><a href="#五子棋例子" class="headerlink" title="五子棋例子"></a>五子棋例子</h3><p>下面是一个我认为比较能够说明两者区别的一个栗子~：例如五子棋，面向过程的设计思路就是首先分析问题的步骤：</p><ol><li>开始游戏</li><li>黑子先走</li><li>绘制画面</li><li>判断输赢</li><li>轮到白子</li><li>绘制画面</li><li>判断输赢</li><li>返回步骤2</li></ol><p>把上面每个步骤用分别的函数来实现，问题就解决了。<br>而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为 </p><ul><li>黑白双方，这两方的行为是一模一样的</li><li>棋盘系统，负责绘制画面</li></ul><p>第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的i变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。<br>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了总多步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。<br>功能上的统一保证了面向对象设计的可扩展性。比如我要加入悔棋的功能，如果要改动面向过程的设计，那么从输入到判断到显示这一连串的步骤都要改动，甚至步骤之间的循序都要进行大规模调整。如果是面向对象的话，只用改动棋盘对象就行了，棋盘系统保存了黑白双方的棋谱，简单回溯就可以了，而显示和规则判断则不用顾及，同时整个对对象功能的调用顺序都没有变化，改动只是局部的。<br>再比如我要把这个五子棋游戏改为围棋游戏，如果你是面向过程设计，那么五子棋的规则就分布在了你的程序的每一个角落，要改动还不如重写。但是如果你当初就是面向对象的设计，那么你只用改动规则对象就可以了，五子棋和围棋的区别不就是规则吗？（当然棋盘大小好像也不一样，但是你会觉得这是一个难题吗？直接在棋盘对象中进行一番小改动就可以了。）而下棋的大致步骤从面向对象的角度来看没有任何变化。<br>当然，要达到改动只是局部的需要设计的人有足够的经验，使用对象不能保证你的程序就是面向对象，初学者或者很蹩脚的程序员很可能以面向对象之虚而行面向过程之实，这样设计出来的所谓面向对象的程序很难有良好的可移植性和可扩展性。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象有三大特性，<code>封装、继承和多态</code>。对于ES5来说，没有<code>class</code>的概念，并且由于js的函数级作用域（在函数内部的变量在函数外访问不到），所以我们就可以模拟 <code>class</code>的概念，在es5中，类其实就是保存了一个函数的变量，这个函数有自己的属性和方法。将属性和方法组成一个类的过程就是封装。</p><blockquote><p>封装：<strong>把客观事物封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口。</strong></p></blockquote><h3 id="通过构造函数添加"><a href="#通过构造函数添加" class="headerlink" title="通过构造函数添加"></a>通过构造函数添加</h3><p>javascript提供了一个构造函数（Constructor）模式，用来在创建对象时初始化对象。构造函数其实就是普通的函数，只不过有以下的特点</p><ul><li>首字母大写（建议构造函数首字母大写，即使用大驼峰命名，非构造函数首字母小写）</li><li>内部使用this</li><li>使用 new生成实例</li></ul><p>通过构造函数添加属性和方法实际上也就是通过this添加的属性和方法。因为this总是指向当前对象的，所以通过this添加的属性和方法只在当前对象上添加，是该对象自身拥有的。所以我们实例化一个新对象的时候，this指向的属性和方法都会得到相应的创建，也就是会在内存中复制一份，这样就造成了内存的浪费。</p><pre><code class="js">function Cat(name,color)&#123;  this.name = name;  this.color = color;  this.eat = function () &#123;      alert(&#39;吃老鼠&#39;)  &#125;&#125;//复制代码生成实例：var cat1 = new Cat(&#39;tom&#39;,&#39;red&#39;)复制代码通过this定义的属性和方法，我们实例化对象的时候都会重新复制一份</code></pre><h3 id="通过原型prototype"><a href="#通过原型prototype" class="headerlink" title="通过原型prototype"></a>通过原型prototype</h3><p>在类上通过 this的方式添加属性和对象会导致内存浪费的问题，我们就考虑，有什么方法可以让实例化的类所使用的方法直接使用指针指向同一个方法。于是，就想到了原型的方式</p><p>Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。也就是说，对于那些不变的属性和方法，我们可以直接将其添加在类的prototype 对象上。</p><pre><code class="js">function Cat(name,color)&#123;　this.name = name;　this.color = color;&#125;Cat.prototype.type = &quot;猫科动物&quot;;Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;复制代码然后生成实例var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);alert(cat1.type); // 猫科动物cat1.eat(); // 吃老鼠复制代码这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</code></pre><h3 id="在类的外部通过-语法添加"><a href="#在类的外部通过-语法添加" class="headerlink" title="在类的外部通过.语法添加"></a>在类的外部通过.语法添加</h3><p>我们还可以在类的外部通过. 语法进行添加，因为在实例化对象的时候，并不会执行到在类外部通过. 语法添加的属性，所以实例化之后的对象是不能访问到. 语法所添加的对象和属性的，只能通过该类访问。</p><h3 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h3><p>通过构造函数、原型和. 语法三者都可以在类上添加属性和方法。但是三者是有一定的区别的。构造函数：通过this添加的属性和方法总是指向当前对象的，所以在实例化的时候，通过this添加的属性和方法都会在内存中复制一份，这样就会造成内存的浪费。但是这样创建的好处是即使改变了某一个对象的属性或方法，不会影响其他的对象（因为每一个对象都是复制的一份）。原型：通过原型继承的方法并不是自身的，我们要在原型链上一层一层的查找，这样创建的好处是只在内存中创建一次，实例化的对象都会指向这个prototype 对象，但是这样做也有弊端，因为实例化的对象的原型都是指向同一内存地址，改动其中的一个对象的属性可能会影响到其他的对象. 语法：在类的外部通过. 语法创建的属性和方法只会创建一次，但是这样创建的实例化的对象是访问不到的，只能通过类的自身访问</p><h3 id="javascript也有private-public-protected"><a href="#javascript也有private-public-protected" class="headerlink" title="javascript也有private public protected"></a>javascript也有private public protected</h3><p>对于java程序员来说<code>private public protected</code>这三个关键字应该是很熟悉的哈，但是在js中，并没有类似于<code>private public protected</code>这样的关键字，但是我们又希望我们定义的属性和方法有一定的访问限制，于是我们就可以模拟<code>private public protected</code>这些访问权限。不熟悉java的小伙伴可能不太清楚<code>private public protected</code>概念（其他语言我也不清楚有没有哈，但是应该都是类似的<del>），先来科普一下小知识点</del></p><ul><li>public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用</li><li>private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。</li><li>protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。</li></ul><h4 id="js中的private"><a href="#js中的private" class="headerlink" title="js中的private"></a>js中的private</h4><p>因为javascript函数级作用域的特性（在函数中定义的属性和方法外界访问不到），所以我们在函数内部直接定义的属性和方法都是私有的。</p><h4 id="js中的public"><a href="#js中的public" class="headerlink" title="js中的public"></a>js中的public</h4><p>通过new关键词实例化时，this定义的属性和变量都会被复制一遍，所以通过this定义的属性和方法就是公有的。通过prototype创建的属性在类的实例化之后类的实例化对象也是可以访问到的，所以也是公有的。</p><h4 id="js中的protected"><a href="#js中的protected" class="headerlink" title="js中的protected"></a>js中的protected</h4><p>在函数的内部，我们可以通过this定义的方法访问到一些类的私有属性和方法，在实例化的时候就可以初始化对象的一些属性了。</p><h4 id="new的实质"><a href="#new的实质" class="headerlink" title="new的实质"></a>new的实质</h4><p>虽然很多人都已经了解了new的实质，那么我还是要再说一下new 的实质 var o = new Object()</p><ol><li>新建一个对象o</li><li><code>o. __proto__ = Object.prototype</code> 将新创建的对象的<code>__proto__</code>属性指向构造函数的<code>prototype</code></li><li>将this指向新创建的对象</li><li>返回新对象，但是这里需要看构造函数有没有返回值，如果构造函数的返回值为基本数据类型<code>string,boolean,number,null,undefined</code>,那么就返回新对象，如果构造函数的返回值为对象类型，那么就返回这个对象类型</li></ol><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code class="js">var Book = function (id, name, price) &#123;  //private(在函数内部定义，函数外部访问不到，实例化之后实例化的对象访问不到)  var num = 1;  var id = id;  function checkId() &#123;      console.log(&#39;private&#39;)  &#125;  //protected(可以访问到函数内部的私有属性和私有方法，在实例化之后就可以对实例化的类进行初始化拿到函数的私有属性)  this.getName = function () &#123;      console.log(id)  &#125;  this.getPrice = function () &#123;      console.log(price)  &#125;  //public(实例化的之后，实例化的对象就可以访问到了~)  this.name = name;  this.copy = function () &#123;      console.log(&#39;this is public&#39;)  &#125;&#125;//在Book的原型上添加的方法实例化之后可以被实例化对象继承Book.prototype.proFunction = function () &#123;  console.log(&#39;this is proFunction&#39;)&#125;//在函数外部通过.语法创建的属性和方法，只能通过该类访问，实例化对象访问不到Book.setTime = function () &#123;  console.log(&#39;this is new time&#39;)&#125;var book1 = new Book(&#39;111&#39;,&#39;悲惨世界&#39;,&#39;$99&#39;)book1.getName();        // 111 getName是protected，可以访问到类的私有属性，所以实例化之后也可以访问到函数的私有属性book1.checkId();        //报错book1.checkId is not a functionconsole.log(book1.id)   // undefined id是在函数内部通过定义的，是私有属性，所以实例化对象访问不到console.log(book1.name) //name 是通过this创建的，所以在实例化的时候会在book1中复制一遍name属性，所以可以访问到book1.copy()            //this is publicbook1.proFunction();    //this is proFunctionBook.setTime();         //this is new timebook1.setTime();        //报错book1.setTime is not a function</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承：子类可以使用父类的所有功能，并且对这些功能进行扩展。继承的过程，就是从一般到特殊的过程。</p></blockquote><p>其实继承都是基于以上封装方法的三个特性来实现的。</p><h3 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h3><p>所谓的类式继承就是使用的原型的方式，将方法添加在父类的原型上，然后子类的原型是父类的一个实例化对象。</p><pre><code class="js">//声明父类  var SuperClass = function () &#123;      var id = 1;      this.name = [&#39;javascript&#39;];      this.superValue = function () &#123;          console.log(&#39;superValue is true&#39;);          console.log(id)      &#125;  &#125;;  //为父类添加共有方法  SuperClass.prototype.getSuperValue = function () &#123;      return this.superValue();  &#125;;  //声明子类  var SubClass = function () &#123;      this.subValue = function () &#123;          console.log(&#39;this is subValue &#39;)      &#125;  &#125;;  //继承父类  SubClass.prototype = new SuperClass() ;  //为子类添加共有方法  SubClass.prototype.getSubValue= function () &#123;      return this.subValue()  &#125;;  var sub = new SubClass();  var sub2 =  new  SubClass();  sub.getSuperValue();   //superValue is true  sub.getSubValue();     //this is subValue  console.log(sub.id);    //undefined  console.log(sub.name);  //javascript  sub.name.push(&#39;java&#39;);  //[&quot;javascript&quot;]  console.log(sub2.name)  //[&quot;javascript&quot;, &quot;java&quot;]</code></pre><p>其中最核心的一句代码是<code>SubClass.prototype = new SuperClass()</code> ;类的原型对象<code>prototype</code>对象的作用就是为类的原型添加共有方法的，但是类不能直接访问这些方法，只有将类实例化之后，新创建的对象复制了父类构造函数中的属性和方法，并将原型<code>__proto__ </code>指向了父类的原型对象。这样子类就可以访问父类的<code>public</code> 和<code>protected </code>的属性和方法，同时，父类中的<code>private</code> 的属性和方法不会被子类继承。</p><p>如上述代码的最后一段，使用类继承的方法，如果父类的构造函数中有引用类型，就会在子类中被所有实例共用，因此<strong>一个子类的实例如果更改了这个引用类型，就会影响到其他子类的实例</strong>。</p><p>提一个小问题~<strong>为什么一个子类的实例如果更改了这个引用类型，就会影响到其他子类的实例呢，在javascript中，什么是引用类型呢，引用类型和其他的类型又有什么区别呢？</strong></p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>正式因为有了上述的缺点，才有了构造函数继承，构造函数继承的核心思想就是<code>SuperClass.call(this,id)</code>,直接改变this的指向，使通过this创建的属性和方法在子类中复制一份，因为是单独复制的，所以各个实例化的子类互不影响。但是会造成内存浪费的问题</p><pre><code class="js">//构造函数继承//声明父类function SuperClass(id) &#123;    var name = &#39;javascript&#39;    this.books=[&#39;javascript&#39;,&#39;html&#39;,&#39;css&#39;];    this.id = id&#125;//声明父类原型方法SuperClass.prototype.showBooks = function () &#123;    console.log(this.books)&#125;//声明子类function SubClass(id) &#123;    SuperClass.call(this,id)&#125;//创建第一个子类实例var subclass1 = new SubClass(10);var subclass2 = new SubClass(11);console.log(subclass1.books);console.log(subclass2.id);console.log(subclass1.name);   //undefinedsubclass2.showBooks();</code></pre><h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>类继承    </p><ul><li>核心思想:子类的原型是父类实例化的对象</li><li>优点:子类实例化对象的属性和方法都指向父类的原型</li><li>缺点:子类之间可能会互相影响</li></ul><p>构造函数继承</p><ul><li>核心思想:<code>SuperClass.call(this,id)</code></li><li>优点:每个实例化的子类互不影响</li><li>缺点:内存浪费</li></ul><p>所以组合式继承就是汲取两者的优点，即避免了内存浪费，又使得每个实例化的子类互不影响。</p><pre><code class="js">//组合式继承//声明父类var SuperClass = function (name) &#123;    this.name = name;    this.books=[&#39;javascript&#39;,&#39;html&#39;,&#39;css&#39;]&#125;;//声明父类原型上的方法SuperClass.prototype.showBooks = function () &#123;    console.log(this.books)&#125;;//声明子类var SubClass = function (name) &#123;    SuperClass.call(this, name)&#125;;//子类继承父类（链式继承）SubClass.prototype = new SuperClass();//实例化子类var subclass1 = new SubClass(&#39;java&#39;);var subclass2 = new SubClass(&#39;php&#39;);subclass2.showBooks();subclass1.books.push(&#39;ios&#39;);    //[&quot;javascript&quot;, &quot;html&quot;, &quot;css&quot;]console.log(subclass1.books);  //[&quot;javascript&quot;, &quot;html&quot;, &quot;css&quot;, &quot;ios&quot;]console.log(subclass2.books);   //[&quot;javascript&quot;, &quot;html&quot;, &quot;css&quot;]</code></pre><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><p>组合式继承的方法固然好，但是会导致一个问题，<strong>父类的构造函数会被创建两次（call()的时候一遍，new的时候又一遍）</strong>，所以为了解决这个问题，又出现了寄生组合继承。</p><p>刚刚问题的关键是<strong>父类的构造函数在类继承和构造函数继承的组合形式中被创建了两遍，但是在类继承中我们并不需要创建父类的构造函数，我们只是要子类继承父类的原型</strong>即可。所以说我们先给父类的原型创建一个副本，然后修改子类<code>constructor</code>属性，最后在设置子类的原型就可以了~</p><pre><code class="js">//原型式继承//原型式继承其实就是类式继承的封装,实现的功能是返回一个实例，改实例的原型继承了传入的o对象function inheritObject(o) &#123;    //声明一个过渡函数对象    function F() &#123;&#125;    //过渡对象的原型继承父对象    F.prototype = o;    //返回一个过渡对象的实例，该实例的原型继承了父对象    return new F();&#125;//寄生式继承//寄生式继承就是对原型继承的第二次封装，使得子类的原型等于父类的原型。并且在第二次封装的过程中对继承的对象进行了扩展function inheritPrototype(subClass, superClass)&#123;    //复制一份父类的原型保存在变量中，使得p的原型等于父类的原型    var p = inheritObject(superClass.prototype);    //修正因为重写子类原型导致子类constructor属性被修改    p.constructor = subClass;    //设置子类的原型    subClass.prototype = p;&#125;//定义父类var SuperClass = function (name) &#123;    this.name = name;    this.books = [&#39;javascript&#39;,&#39;html&#39;,&#39;css&#39;]&#125;;//定义父类原型方法SuperClass.prototype.getBooks = function () &#123;    console.log(this.books)&#125;;//定义子类var SubClass = function (name) &#123;    SuperClass.call(this,name)&#125;inheritPrototype(SubClass,SuperClass);var subclass1 = new SubClass(&#39;php&#39;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903480868470798&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://use</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之setTimeout, setInterval 和 requestAnimationFrame</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/27/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BsetTimeout-setInterval-%E5%92%8C-requestAnimationFrame/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/27/Js/33%E4%B8%AAJS%E6%A6%82%E5%BF%B5/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8BsetTimeout-setInterval-%E5%92%8C-requestAnimationFrame/</id>
    <published>2020-09-27T08:58:52.000Z</published>
    <updated>2020-09-27T09:32:27.065Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>[原文地址](https://segmentfault.com/a/1190000014661035)<h2 id="一-常见定时器"><a href="#一-常见定时器" class="headerlink" title="一.常见定时器"></a>一.常见定时器</h2><pre><code class="html">我们常见的定时器有以下两种1. window.setTimeout 用于在指定的毫秒数后执行某段既定的代码2. window.setInterval 用于每隔一段毫秒数重复执行既定的代码这两个方法都可以通过手工设置时间来设定是多少毫秒后执行这段代码，或者是每隔多少毫秒执行这段代码。  </code></pre><blockquote><p>虽然我们期待浏览器按照我们设定的时间精确的执行代码，但是js却不能保证代码能恰好在那个时间点被运行，原因有两个。</p></blockquote><ul><li><p>大多数浏览器并没有精确到毫秒级别的触发事件，例如，我们设定某个函数在3毫秒后执行，在老版本的IE中，这个函数至少会在15毫秒以后执行。而在现代浏览器中，这个数值会短一点，但时间差一般也会超过1毫秒。</p></li><li><p>第二个原因与js的运行机制有关，具体见<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a>.简单来说，就是js是一个单线程的解释器，一段时间只能执行一段代码，所以运行时分为主线程和任务队列两部分。而我们在定时器中设置的时间，仅代表1000毫秒后把这个任务插入到任务队列中，而此时必须要等到主线程的代码执行完毕，才能执行任务队列中的定时器的任务（在任务队列中也有调度，不一定第一个执行当前任务），因此时间是无法保证的。</p></li></ul><h2 id="二、requestAnimationFrame"><a href="#二、requestAnimationFrame" class="headerlink" title="二、requestAnimationFrame"></a>二、requestAnimationFrame</h2><p>那有没有时间准确的定时器呢？有一种选择是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">requestAnimationFrame</a>. 示例如下：</p><pre><code class="js"> function animateMe()&#123;    requestAnimationFrame(function()&#123;      console.log(new Date());      animateMe();    &#125;)&#125;animateMe();</code></pre><p>这个api的原理<strong>是在由系统来决定回调函数的执行时机</strong>，在每一次系统绘制之前，会主动调用requestAnimationFrame中的回调函数，而频率也紧紧跟随浏览器的刷新频率。比如一般电脑的刷新频率通常为<code>60Hz</code>，即一秒钟重绘<code>60</code>次，那么回调函数就等于<code>1000/60=16.7</code>毫秒被执行一次，而如果刷新频率变为<code>75Hz</code>，那么这个时间就变为<code>1000/75=13.3</code>毫秒被执行一次。这样能保证回调函数在每一次绘制的间隔时间内只被执行一次，因此它的时间是可靠的。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="阿里前端面试题：requestAnimationFrame实现类似setInterval-setTimeout的计时器"><a href="#阿里前端面试题：requestAnimationFrame实现类似setInterval-setTimeout的计时器" class="headerlink" title="阿里前端面试题：requestAnimationFrame实现类似setInterval,setTimeout的计时器"></a>阿里前端面试题：requestAnimationFrame实现类似setInterval,setTimeout的计时器</h3><pre><code class="js">const RAF = &#123;  intervalTimer: null,  timeoutTimer: null,  setTimeout (cb, interval) &#123; // 实现setTimeout功能    let now = Date.now    let stime = now()    let etime = stime    let loop = () =&gt; &#123;    this.timeoutTimer = requestAnimationFrame(loop)    etime = now()    if (etime - stime &gt;= interval) &#123;      cb()      cancelAnimationFrame(this.timeoutTimer)    &#125;  &#125;    this.timeoutTimer = requestAnimationFrame(loop)    return this.timeoutTimer  &#125;,    clearTimeout () &#123;    cancelAnimationFrame(this.timeoutTimer)  &#125;,  setInterval (cb, interval) &#123; // 实现setInterval功能    let now = Date.now    let stime = now()    let etime = stime    let loop = () =&gt; &#123;      this.intervalTimer = requestAnimationFrame(loop)      etime = now()      if (etime - stime &gt;= interval) &#123;        stime = now()        etime = stime        cb()      &#125;    &#125;    this.intervalTimer = requestAnimationFrame(loop)    return this.intervalTimer  &#125;,    clearInterval () &#123;    cancelAnimationFrame(this.intervalTimer)  &#125;&#125;</code></pre><p>调用：</p><pre><code class="js">let count = 0function a() &#123;console.log(count)count++&#125;RAF.setInterval(a, 1000)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
[原文地址](https://segmentfault.com/a/1190000014661035)

&lt;h2 id=&quot;一-常见定时器&quot;&gt;&lt;a href=&quot;#一-常见定时器&quot; class</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
</feed>
